import numpy
import types
import io
import sys
import mosek

def _():
  import types

  class Enum:
    @staticmethod
    def __inst(c,name):
      o = c()
      o.name  = name
      o.value = len(c.__members__)
      c.__members__.append(o)
      setattr(c, name, o)

    @classmethod
    def fromInt(c,value):
      return c.members[value]

    @staticmethod
    def new(name,membernames):
      members = []
      c = type(name, (Enum,),{ '__members__' : members })
      for n in membernames:
        Enum.__inst(c,n)
      return c
    @classmethod
    def members(c):
      return iter(c.__members__)

    def __str__(self):
      return self.__class__.__name__ + "." + self.name
    def __repr__(self):
      return self.__class__.__name__ + "." + self.name
  return Enum

class _monty:
  Enum = _()
  @staticmethod
  def deduceShape(l,dim):
    def _deduceShape(l,dim):
      if dim > 1:
        shplst = [ _deduceShape(i,dim-1) for i in l ]
        if all([shplst[0] == i for i in shplst ]):
          shplst[0].append(len(l))
          return shplst[0]
        else:
          raise TypeError("Irregular array shape")
      else:
        return [len(dim)]
    return tuple(reversed(_deduceShape(l,dim)))
  @staticmethod
  def checkShape(l,dim):
    def _checkShape(l,dim):
      if dim > 1:
        shplst = [ _checkShape(i,dim-1) for i in l ]
        if all([shplst[0] == i for i in shplst ]):
          pass
        else:
          raise TypeError("Irregular array shape")
        return len(l)
      else:
        try:
          return len(l)
        except TypeError:
          raise TypeError("Wrong or irregular array shape")
    _checkShape(l,dim)
    return dim

  @staticmethod
  def initJaggedArray(data, nd):
    dims = []
    d = data
    for i in range(nd):
      dims.append(len(d))
      d = d[0]

    res = numpy.zeros(dims,dtype=object)
    res.__setitem__([ slice(d) for d in dims ], data)

    return res


  @staticmethod
  def makeJaggedArray(src,ndims,dtype):
    if src is None:
      return None
    elif len(ndims) == 1:
      if ndims[0] == 1:
        r = numpy.zeros((len(src),),dtype=dtype)
        r[:] = src
      else:
        d = _monty.deduceDims(src,ndims[0])
        r = numpy.zeros(d,dtype=dtype)
        r.__setitem__(tuple([slice(None)]*ndims[0]),src) # basically: r[:,...,:] = src
      return r
    elif ndims[0] == 1:
      r = numpy.zeros((len(src),),dtype=numpy.dtype(object))
      # Note: This is a bit tricky to do reliably with numpy as it
      # tends to think we are dealing with multidimensional arrays and
      # explode
      for i,s in enumerate(src):
        r[i] = _monty.makeJaggedArray(s,ndims[1:],dtype)

      #r[:] = [ _monty.makeJaggedArray(s,ndims[1:],dtype) for s in src ]
      return r
    else:
      d = _monty.deduceDims(src,ndims[0])
      def _(src,nd):
        if nd == 0:
          return _monty.makeJaggedArray(src)
        else:
          return [ _(s,nd-1) for s in src ]

      r = numpy.zeros(d,dtype=numpy.dtype(object))
      r.__setitem__(tuple([slice(None)]*ndims[0]),_(src,ndims[0])) # basically: r[:,...,:] = convert(src)
      return r

  @staticmethod
  def copyArray(src,dst,dim):
    if dim == 1:
      src[:] = dst[:]
    else:
      for i in range(len(src)):
        _monty.copyArray(src[i],dst[i],dim-1)
  @staticmethod
  def arg_match_sloppy_array(v,elmmatch,dim,l=None):
    if dim == 0:
      elmmatch(v)
    elif dim == 1:
      if l is not None:
        if l != len(v): return False
      elif len(v) == 0: return True
      for e in v:
        if not elmmatch(e): return False
      return True
    elif isinstance(v,list) or isinstance(v,numpy.ndarray):
      if l is not None:
        if l != len(v): return False
      elif len(v) == 0: return True
      elif not (isinstance(v[0],list) or isinstance(v[0],numpy.ndarray)): return False

      top_len = len(v[0])
      for e in v:
        if not _monty.arg_match_sloppy_array(e,elmmatch,dim-1,top_len): return False
      return True
    else:
      return False

del _

mosek_fusion_RelationKey=_monty.Enum.new('RelationKey',['EqualsTo','LessThan','GreaterThan','IsFree','InRange'])
mosek_fusion_PSDKey=_monty.Enum.new('PSDKey',['IsSymPSD','IsTrilPSD'])
mosek_fusion_QConeKey=_monty.Enum.new('QConeKey',['InQCone','InRotatedQCone'])
mosek_fusion_ObjectiveSense=_monty.Enum.new('ObjectiveSense',['Undefined','Minimize','Maximize'])
mosek_fusion_SolutionStatus=_monty.Enum.new('SolutionStatus',['Undefined','Unknown','Optimal','NearOptimal','Feasible','NearFeasible','Certificate','NearCertificate','IllposedCert'])
mosek_fusion_AccSolutionStatus=_monty.Enum.new('AccSolutionStatus',['Anything','Optimal','NearOptimal','Feasible','Certificate'])
mosek_fusion_ProblemStatus=_monty.Enum.new('ProblemStatus',['Unknown','PrimalAndDualFeasible','PrimalFeasible','DualFeasible','PrimalInfeasible','DualInfeasible','PrimalAndDualInfeasible','IllPosed','PrimalInfeasibleOrUnbounded'])
mosek_fusion_SolutionType=_monty.Enum.new('SolutionType',['Default','Basic','Interior','Integer'])
mosek_fusion_StatusKey=_monty.Enum.new('StatusKey',['Unknown','Basic','SuperBasic','OnBound','Infinity'])
#BEFORE CLASS
def __mk_mosek_fusion_Variable():
 class Variable:
  def makeContinuous(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_makeContinuous_(*args): # 
      return self._makeContinuous_(*args)
    elif mosek_fusion_Variable._match_alt_makeContinuous_(*args): # 
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.makeContinuous()')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_Variable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_Variable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Variable._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.transpose()')
  def makeInteger(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_makeInteger_(*args): # 
      return self._makeInteger_(*args)
    elif mosek_fusion_Variable._match_alt_makeInteger_(*args): # 
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.makeInteger()')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_Variable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_Variable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.Variable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.Variable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def shape(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_shape_(*args): # 
      return self._shape_(*args)
    elif mosek_fusion_Variable._match_alt_shape_(*args): # 
      return self._shape_alt_(*args)
    else:
      raise ValueError('Invalid argument list shape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.shape()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Variable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Variable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.slice(int32,int32)\n\tmosek.fusion.Variable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def antidiag(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_antidiag_(*args): # 
      return self._antidiag_(*args)
    elif mosek_fusion_Variable._match_alt_antidiag_(*args): # 
      return self._antidiag_alt_(*args)
    elif mosek_fusion_Variable._match_antidiag_I(*args): # int32
      return self._antidiag_I(*args)
    elif mosek_fusion_Variable._match_alt_antidiag_I(*args): # int32
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.antidiag()\n\tmosek.fusion.Variable.antidiag(int32)')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Variable._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getShape()')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_Variable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.Variable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Variable._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getModel()')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_Variable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.dual()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Variable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Variable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Variable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_Variable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_Variable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_Variable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_Variable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.index(int32)\n\tmosek.fusion.Variable.index(array(int32,ndim=1))\n\tmosek.fusion.Variable.index(int32,int32)\n\tmosek.fusion.Variable.index(int32,int32,int32)')
  def diag(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_diag_(*args): # 
      return self._diag_(*args)
    elif mosek_fusion_Variable._match_alt_diag_(*args): # 
      return self._diag_alt_(*args)
    elif mosek_fusion_Variable._match_diag_I(*args): # int32
      return self._diag_I(*args)
    elif mosek_fusion_Variable._match_alt_diag_I(*args): # int32
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.diag()\n\tmosek.fusion.Variable.diag(int32)')
  def setLevel(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_setLevel__3D(*args): # []double
      return self._setLevel__3D(*args)
    elif mosek_fusion_Variable._match_alt_setLevel__3D(*args): # []double
      return self._setLevel_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list setLevel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.setLevel(array(double,ndim=1))')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_Variable._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.level()')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_Variable._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.asExpr()')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_Variable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.make_continuous(array(int64,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Variable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.toString()')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_Variable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Variable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Variable._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_Variable._match_pick__3I_3I(*args): # []int32,[]int32
      return self._pick__3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I_3I(*args): # []int32,[]int32
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_Variable._match_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.pick(array(int32,ndim=1))\n\tmosek.fusion.Variable.pick(array(int32,ndim=2))\n\tmosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_Variable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.make_integer(array(int64,ndim=1))')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_Variable._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.size()')
  def __repr__(self): return 'mosek.fusion.Variable'
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   pass
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   pass
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   pass
  @staticmethod
  def _match_shape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_shape_(*args):
    if len(args) != 0: return False
    return True
  def _shape_alt_(self,):
    return self._shape_()
  def _shape_(self,):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   pass
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   pass
  @staticmethod
  def _match_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setLevel_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setLevel__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setLevel__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   pass
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   pass
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   pass
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _values_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._values_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_I_3DZ(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   pass
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   pass
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  def _pick_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I_3I(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _pick_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   pass
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _antidiag_alt_I(self,_t__0):
    return self._antidiag_I(numpy.int32(__0))
  def _antidiag_I(self,_0):
   pass
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   pass
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _diag_alt_I(self,_t__0):
    return self._diag_I(numpy.int32(__0))
  def _diag_I(self,_0):
   pass
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _index_alt_III(self,_t__0,_t__1,_t__2):
    return self._index_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _index_III(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _index_alt_II(self,_t__0,_t__1):
    return self._index_II(numpy.int32(__0),numpy.int32(__1))
  def _index_II(self,_0,_1):
   pass
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   pass
 return Variable
mosek_fusion_Variable=__mk_mosek_fusion_Variable()
del __mk_mosek_fusion_Variable
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricVariable():
 class SymmetricVariable(mosek_fusion_Variable):
  def __repr__(self): return 'mosek.fusion.SymmetricVariable'
 return SymmetricVariable
mosek_fusion_SymmetricVariable=__mk_mosek_fusion_SymmetricVariable()
del __mk_mosek_fusion_SymmetricVariable
#BEFORE CLASS
def __mk_mosek_fusion_Expression():
 class Expression:
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Expression._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getShape()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Expression._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Expression._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Expression._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.slice(int32,int32)\n\tmosek.fusion.Expression.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Expression._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.toString()')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Expression._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getModel()')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Expression._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.transpose()')
  def shape(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_shape_(*args): # 
      return self._shape_(*args)
    elif mosek_fusion_Expression._match_alt_shape_(*args): # 
      return self._shape_alt_(*args)
    else:
      raise ValueError('Invalid argument list shape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.shape()')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_Expression._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Expression._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_Expression._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.pick(array(int32,ndim=1))\n\tmosek.fusion.Expression.pick(array(int32,ndim=2))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_Expression._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.eval()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Expression._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Expression._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Expression._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.index(int32)\n\tmosek.fusion.Expression.index(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.Expression'
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  @staticmethod
  def _match_eval_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_eval_(*args):
    if len(args) != 0: return False
    return True
  def _eval_alt_(self,):
    return self._eval_()
  def _eval_(self,):
   pass
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   pass
  @staticmethod
  def _match_shape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_shape_(*args):
    if len(args) != 0: return False
    return True
  def _shape_alt_(self,):
    return self._shape_()
  def _shape_(self,):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
 return Expression
mosek_fusion_Expression=__mk_mosek_fusion_Expression()
del __mk_mosek_fusion_Expression
#BEFORE CLASS
def __mk_mosek_fusion_FusionException():
 class FusionException(Exception):
  __slots__ = ['_FusionException__msg']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FusionException.ctor(string)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_FusionException._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_FusionException._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FusionException.toString()')
  def __repr__(self): return 'mosek.fusion.FusionException'
  @staticmethod
  def _ctor_S(msg_):
    o = FusionException.__new__(FusionException)
    o._ctor_init_S(msg_)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_match_S__(msg_))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_alt_match_S__(msg_))
  def _ctor_alt_init_S(self,msg_):
    self._ctor_init_S(msg_)
  def _ctor_init_S(self,msg_):
   Exception.__init__(self,msg_)
   self.__msg = msg_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (self.__msg)
 return FusionException
mosek_fusion_FusionException=__mk_mosek_fusion_FusionException()
del __mk_mosek_fusion_FusionException
#BEFORE CLASS
def __mk_mosek_fusion_SolutionError():
 class SolutionError(mosek_fusion_FusionException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SolutionError.ctor()\n\tmosek.fusion.SolutionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SolutionError'
  @staticmethod
  def _ctor_():
    o = SolutionError.__new__(SolutionError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionException._ctor_init_S(self,"Solution is invalid or undefined")
  @staticmethod
  def _ctor_S(msg):
    o = SolutionError.__new__(SolutionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionException._ctor_init_S(self,msg)
 return SolutionError
mosek_fusion_SolutionError=__mk_mosek_fusion_SolutionError()
del __mk_mosek_fusion_SolutionError
#BEFORE CLASS
def __mk_mosek_fusion_UnimplementedError():
 class UnimplementedError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UnimplementedError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UnimplementedError'
  @staticmethod
  def _ctor_S(msg):
    o = UnimplementedError.__new__(UnimplementedError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return UnimplementedError
mosek_fusion_UnimplementedError=__mk_mosek_fusion_UnimplementedError()
del __mk_mosek_fusion_UnimplementedError
#BEFORE CLASS
def __mk_mosek_fusion_FatalError():
 class FatalError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FatalError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.FatalError'
  @staticmethod
  def _ctor_S(msg):
    o = FatalError.__new__(FatalError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return FatalError
mosek_fusion_FatalError=__mk_mosek_fusion_FatalError()
del __mk_mosek_fusion_FatalError
#BEFORE CLASS
def __mk_mosek_fusion_UnexpectedError():
 class UnexpectedError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4FusionException_2(*args): # mosek.fusion.FusionException
      self._ctor_init_Lmosek_4fusion_4FusionException_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4FusionException_2(*args):# mosek.fusion.FusionException
      self._ctor_alt_init_Lmosek_4fusion_4FusionException_2(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UnexpectedError.ctor(mosek.fusion.FusionException)\n\tmosek.fusion.UnexpectedError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UnexpectedError'
  @staticmethod
  def _ctor_Lmosek_4fusion_4FusionException_2(e):
    o = UnexpectedError.__new__(UnexpectedError)
    o._ctor_init_Lmosek_4fusion_4FusionException_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4FusionException_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4FusionException_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4FusionException_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4FusionException_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4FusionException_2(self,e):
    self._ctor_init_Lmosek_4fusion_4FusionException_2(e)
  def _ctor_init_Lmosek_4fusion_4FusionException_2(self,e):
   Exception.__init__(self,e._toString_())
  @staticmethod
  def _ctor_S(msg):
    o = UnexpectedError.__new__(UnexpectedError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return UnexpectedError
mosek_fusion_UnexpectedError=__mk_mosek_fusion_UnexpectedError()
del __mk_mosek_fusion_UnexpectedError
#BEFORE CLASS
def __mk_mosek_fusion_FusionRuntimeException():
 class FusionRuntimeException(Exception):
  __slots__ = ['_FusionRuntimeException__msg']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FusionRuntimeException.ctor(string)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_FusionRuntimeException._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_FusionRuntimeException._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FusionRuntimeException.toString()')
  def __repr__(self): return 'mosek.fusion.FusionRuntimeException'
  @staticmethod
  def _ctor_S(msg_):
    o = FusionRuntimeException.__new__(FusionRuntimeException)
    o._ctor_init_S(msg_)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_match_S__(msg_))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_alt_match_S__(msg_))
  def _ctor_alt_init_S(self,msg_):
    self._ctor_init_S(msg_)
  def _ctor_init_S(self,msg_):
   Exception.__init__(self,msg_)
   self.__msg = msg_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (self.__msg)
 return FusionRuntimeException
mosek_fusion_FusionRuntimeException=__mk_mosek_fusion_FusionRuntimeException()
del __mk_mosek_fusion_FusionRuntimeException
#BEFORE CLASS
def __mk_mosek_fusion_SparseFormatError():
 class SparseFormatError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SparseFormatError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SparseFormatError'
  @staticmethod
  def _ctor_S(msg):
    o = SparseFormatError.__new__(SparseFormatError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SparseFormatError
mosek_fusion_SparseFormatError=__mk_mosek_fusion_SparseFormatError()
del __mk_mosek_fusion_SparseFormatError
#BEFORE CLASS
def __mk_mosek_fusion_SliceError():
 class SliceError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SliceError.ctor()\n\tmosek.fusion.SliceError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SliceError'
  @staticmethod
  def _ctor_():
    o = SliceError.__new__(SliceError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,"Invalid slice range")
  @staticmethod
  def _ctor_S(msg):
    o = SliceError.__new__(SliceError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SliceError
mosek_fusion_SliceError=__mk_mosek_fusion_SliceError()
del __mk_mosek_fusion_SliceError
#BEFORE CLASS
def __mk_mosek_fusion_SetDefinitionError():
 class SetDefinitionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SetDefinitionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SetDefinitionError'
  @staticmethod
  def _ctor_S(msg):
    o = SetDefinitionError.__new__(SetDefinitionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SetDefinitionError
mosek_fusion_SetDefinitionError=__mk_mosek_fusion_SetDefinitionError()
del __mk_mosek_fusion_SetDefinitionError
#BEFORE CLASS
def __mk_mosek_fusion_OptimizeError():
 class OptimizeError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.OptimizeError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.OptimizeError'
  @staticmethod
  def _ctor_S(msg):
    o = OptimizeError.__new__(OptimizeError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return OptimizeError
mosek_fusion_OptimizeError=__mk_mosek_fusion_OptimizeError()
del __mk_mosek_fusion_OptimizeError
#BEFORE CLASS
def __mk_mosek_fusion_NameError():
 class NameError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.NameError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.NameError'
  @staticmethod
  def _ctor_S(msg):
    o = NameError.__new__(NameError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return NameError
mosek_fusion_NameError=__mk_mosek_fusion_NameError()
del __mk_mosek_fusion_NameError
#BEFORE CLASS
def __mk_mosek_fusion_ModelError():
 class ModelError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ModelError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ModelError'
  @staticmethod
  def _ctor_S(msg):
    o = ModelError.__new__(ModelError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ModelError
mosek_fusion_ModelError=__mk_mosek_fusion_ModelError()
del __mk_mosek_fusion_ModelError
#BEFORE CLASS
def __mk_mosek_fusion_MatrixError():
 class MatrixError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.MatrixError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.MatrixError'
  @staticmethod
  def _ctor_S(msg):
    o = MatrixError.__new__(MatrixError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return MatrixError
mosek_fusion_MatrixError=__mk_mosek_fusion_MatrixError()
del __mk_mosek_fusion_MatrixError
#BEFORE CLASS
def __mk_mosek_fusion_DimensionError():
 class DimensionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DimensionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DimensionError'
  @staticmethod
  def _ctor_S(msg):
    o = DimensionError.__new__(DimensionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DimensionError
mosek_fusion_DimensionError=__mk_mosek_fusion_DimensionError()
del __mk_mosek_fusion_DimensionError
#BEFORE CLASS
def __mk_mosek_fusion_LengthError():
 class LengthError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LengthError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.LengthError'
  @staticmethod
  def _ctor_S(msg):
    o = LengthError.__new__(LengthError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return LengthError
mosek_fusion_LengthError=__mk_mosek_fusion_LengthError()
del __mk_mosek_fusion_LengthError
#BEFORE CLASS
def __mk_mosek_fusion_RangeError():
 class RangeError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.RangeError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.RangeError'
  @staticmethod
  def _ctor_S(msg):
    o = RangeError.__new__(RangeError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return RangeError
mosek_fusion_RangeError=__mk_mosek_fusion_RangeError()
del __mk_mosek_fusion_RangeError
#BEFORE CLASS
def __mk_mosek_fusion_IndexError():
 class IndexError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IndexError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.IndexError'
  @staticmethod
  def _ctor_S(msg):
    o = IndexError.__new__(IndexError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return IndexError
mosek_fusion_IndexError=__mk_mosek_fusion_IndexError()
del __mk_mosek_fusion_IndexError
#BEFORE CLASS
def __mk_mosek_fusion_DomainError():
 class DomainError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DomainError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DomainError'
  @staticmethod
  def _ctor_S(msg):
    o = DomainError.__new__(DomainError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DomainError
mosek_fusion_DomainError=__mk_mosek_fusion_DomainError()
del __mk_mosek_fusion_DomainError
#BEFORE CLASS
def __mk_mosek_fusion_ValueConversionError():
 class ValueConversionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ValueConversionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ValueConversionError'
  @staticmethod
  def _ctor_S(msg):
    o = ValueConversionError.__new__(ValueConversionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ValueConversionError
mosek_fusion_ValueConversionError=__mk_mosek_fusion_ValueConversionError()
del __mk_mosek_fusion_ValueConversionError
#BEFORE CLASS
def __mk_mosek_fusion_ParameterError():
 class ParameterError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ParameterError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ParameterError'
  @staticmethod
  def _ctor_S(msg):
    o = ParameterError.__new__(ParameterError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ParameterError
mosek_fusion_ParameterError=__mk_mosek_fusion_ParameterError()
del __mk_mosek_fusion_ParameterError
#BEFORE CLASS
def __mk_mosek_fusion_ExpressionError():
 class ExpressionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExpressionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ExpressionError'
  @staticmethod
  def _ctor_S(msg):
    o = ExpressionError.__new__(ExpressionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ExpressionError
mosek_fusion_ExpressionError=__mk_mosek_fusion_ExpressionError()
del __mk_mosek_fusion_ExpressionError
#BEFORE CLASS
def __mk_mosek_fusion_IOError():
 class IOError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IOError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.IOError'
  @staticmethod
  def _ctor_S(msg):
    o = IOError.__new__(IOError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return IOError
mosek_fusion_IOError=__mk_mosek_fusion_IOError()
del __mk_mosek_fusion_IOError
def __mk_mosek_fusion_BaseModel():
  import threading
  import mosek
  import mosek.fusion
  import numpy
  
  
  class BaseModel(object):
    _lock = threading.Lock()
    _global_env = None
    _global_env_counter = 0
  
    @classmethod
    def _globalEnv(self):
      self._lock.acquire()
      try:
        if BaseModel._global_env is None:
          try:
            env = mosek.Env()
            BaseModel._global_env = env
            BaseModel._global_env_counter += 1
          except mosek.Exception as e:
            raise UnexpectedError(e)
        return BaseModel._global_env
      finally:
        self._lock.release()
  
    @classmethod
    def _env_1putlicensecode(self,code):
      self._globalEnv().putlicensecode(code)
  
    @classmethod
    def _env_1putlicensepath(self,path):
      self._globalEnv().putlicensepath(path)
  
    @classmethod
    def _env_1putlicensewait(self,yn):
      if yn:
        self._globalEnv().putlicensewait(1)
      else:
        self._globalEnv().putlicensewait(0)
        
    def __callback(self,callbackkey,dinf,iinf,liinf):
      if self.__user_cb is not None:
        try:
          if self.__user_cb(callbackkey,dinf,iinf,liinf):
            self.__break = True
        except:
          self.__break = True
      if self.__user_pgs is not None:
        try:
          if self.__user_pgs(callbackkey):
            self.__break = True
        except:
          self.__break = True
      return 1 if self.__break else 0
  
    def _ctor_init_SS(self,name,licfile):
      env = self._globalEnv()
      self.__modelname = name
      self.__break = False
      task = mosek.Task(self._global_env, 0, 0);
      self.__user_cb = None
      self.__user_pgs = None
      finished = False
      try:
        task.putintparam(mosek.iparam.log_expand,0);
        self.__task = task
        if name is not None:
          task.puttaskname(name)
  
        self._synched = mosek_fusion_SolutionStatus.Optimal;
  
        self._sol_itr = None
        self._sol_bas = None
        self._sol_itg = None
  
        self.__objname = None
  
        # handler for log output.
        def loghandler(text):
          if self.__logwriter is not None:
            self.__logwriter.write(text)
            self.__logwriter.flush()
        self.__loghandler = loghandler
        self.__logwriter = None
  
        task.set_Stream(mosek.streamtype.log,loghandler)
        task.set_InfoCallback(self.__callback)
        finished = True
      finally:
        if not finished:
          self.__task.__del__()
          self.__task = None
          BaseModel._global_env_counter -= 1
  
    def _ctor_init_Lmosek_4fusion_4BaseModel_2(self,m):
      env = self._globalEnv()
      self.__modelname = m.__modelname
      self.__break = False
      self.__user_cb = None
      self.__user_pgs = None
      task = mosek.Task(m.__task)
      finished = False
      try:
        self.__task = task
        self._synched = m._synched
  
        self._sol_itr = m._sol_itr._clone_() if m._sol_itr is not None else None
        self._sol_bas = m._sol_bas._clone_() if m._sol_bas is not None else None
        self._sol_itg = m._sol_itg._clone_() if m._sol_itg is not None else None
  
        self.__objname = m.__objname
  
        # handler for log output.
        def loghandler(text):
          if self.__logwriter is not None:
            self.__logwriter.write(text)
            self.__logwriter.flush()
        self.__loghandler = loghandler
        self.__logwriter = None
  
        task.set_Stream(mosek.streamtype.log,loghandler)
        task.set_InfoCallback(self.__callback)
        finished = True
      finally:
        if not finished:
          self.__task.__del__()
          self.__task = None
          BaseModel._global_env_counter -= 1
  
    def __del__(self):
        
        if hasattr(self,'_BaseModel__task'):
          self._lock.acquire()
          try:
            task = self.__task
            BaseModel._global_env_counter -= 1
            task.__del__()
  
            for a in self.__class__.__slots__ + ['_sol_itr','_sol_bas','_sol_itg',
                                                 '_BaseModel__user_cb','_BaseModel__user_pgs','_BaseModel__loghandler','_BaseModel__logwriter','_BaseModel__task']:
              try: delattr(self,a)
              except AttributeError: pass
  
          finally:
            self._lock.release()
    def __enter__(self):
      return self
    def __exit__(self,exc_type,exc_val,exc_tb):
      self.__del__()
    def _dispose_(self):
      self.__del__()
  
    def _task_1setDataCallbackHandler_LSystem_4DataCallbackHandler_2(self,handler):
      self.__user_cb = handler
    def _task_1setCallbackHandler_LSystem_4CallbackHandler_2(self,handler):
      self.__user_pgs = handler
  
    def _task_1setLogHandler_LSystem_4StreamWriter_2(self,handler):
      """
      Set the object to handle log output from the solver.
  
      The handler object must have a write method accepting a string.
      """
      self.__logwriter = handler
  
    def _task_1put_1param_SS(self,name,value):
      self.__task.putnastrparam(name,value)
    def _task_1put_1param_SD(self,name,value):
      self.__task.putnadouparam(name,value)
    def _task_1put_1param_SI(self,name,value):
      self.__task.putnaintparam(name,value)
  
    def _task_1get_1dinf_S(self,name):
      key = mosek_fusion_SolverInfo._getdouinf(name)
      if key is None:
        raise NameError("Invalid double info name '%s'" % name)
      else:
        return self.__task.getdouinf(key)
  
    def _task_1get_1iinf_S(self,name):
      key = mosek_fusion_SolverInfo._getintinf(name)
      if key is None:
        raise NameError("Invalid integer info name '%s'" % name)
      else:
        return self.__task.getintinf(key)
  
    def _task_1get_1liinf_S(self,name):
      key = mosek_fusion_SolverInfo._getlintinf(name)
      if key is None:
        raise NameError("Invalid long integer info name '%s'" % name)
      else:
        return self.__task.getlintinf(key)
  
    def _numVariables_ (self):
      return len(self.__vars)
    def _numConstraints_ (self):
      return len(self.__cons)
    
    def _alloc_1rangedvar_SDD(self,name,lb,ub):
      n = self.__task.getnumvar()
      self.__task.appendvars(1)
      if name is not None:
          self.__task.putvarname(n,name)
      self.__task.putbound(mosek.accmode.var, n, mosek.boundkey.ra, lb, ub)
      return n
    
    def _alloc_1linearvar_SEmosek_4fusion_4RelationKey_2D(self,name,relkey,bnd):
      task = self.__task
      n = task.getnumvar();
      task.appendvars(1)
      if name is not None:
          task.putvarname(n,name)
  
      if   relkey is mosek_fusion_RelationKey.IsFree:
        task.putbound(mosek.accmode.var, n, mosek.boundkey.fr, 0.0, 0.0)
      elif relkey is mosek_fusion_RelationKey.LessThan:
        task.putbound(mosek.accmode.var, n, mosek.boundkey.up, 0.0, bnd)
      elif relkey is mosek_fusion_RelationKey.GreaterThan:
        task.putbound(mosek.accmode.var, n, mosek.boundkey.lo, bnd, 0.0)
      else:
        task.putbound(mosek.accmode.var, n, mosek.boundkey.fx, bnd, bnd)
      return n
  
    def _task_1con_1name_IS(self,idx,name):
      self.__task.putconname(idx,name)
    def _task_1var_1name_IS(self,idx, name):
      self.__task.putvarname(idx,name)
    
    def _task_1cone_1name_IS(self,idx,name):
      self.__task.putconename(idx,name)
  
    def _task_1numcon_(self):
      return self.__task.getnumcon()
    def _task_1numvar_(self):
      return self.__task.getnumvar()
    def _task_1numcone_(self):
      return self.__task.getnumcone()
    
    def __task_putboundslice(self,acc,first,last,bl,bu,bk):  
      num = last-first
      if bl is None: bl = numpy.zeros(num,numpy.float64)
      if bu is None: bu = numpy.zeros(num,numpy.float64)
      
      bka = [bk] * num
      self.__task.putboundslice(acc,first,last,bka,bl,bu)
    
  
    def __task_putboundlist(self,acc,idxs,bl,bu,bk):
      num = len(idxs)
      if bl is None: bl = numpy.zeros(num,numpy.float64)
      if bu is None: bu = numpy.zeros(num,numpy.float64)
  
      bka = [bk] * num
      self.__task.putboundlist(acc,idxs,bka,bl,bu)
    
    def _task_1con_1putboundslice_1fx_II_3D(self,first, last, rhs):
      self.__task_putboundslice(mosek.accmode.con, first, last, rhs, rhs, mosek.boundkey.fx);
    
    def _task_1con_1putboundslice_1lo_II_3D(self,first, last, rhs):
      self.__task_putboundslice(mosek.accmode.con, first, last, rhs, rhs, mosek.boundkey.lo);
    
    def _task_1con_1putboundslice_1up_II_3D(self,first, last, rhs):
      self.__task_putboundslice(mosek.accmode.con, first, last, rhs, rhs, mosek.boundkey.up);
    
    def _task_1con_1putboundslice_1ra_II_3D_3D(self,first, last, lb, ub):
      self.__task_putboundslice(mosek.accmode.con, first, last, lb, ub, mosek.boundkey.ra);
    
    def _task_1con_1putboundslice_1fr_II(self,first, last):
      self.__task_putboundslice(mosek.accmode.con, first, last, None, None, mosek.boundkey.fr);
    
    def _task_1var_1putboundslice_1fx_II_3D(self,first, last, rhs):
      self.__task_putboundslice(mosek.accmode.var, first, last, rhs, rhs, mosek.boundkey.fx);
    
    def _task_1var_1putboundslice_1lo_II_3D(self,first, last, rhs):
      self.__task_putboundslice(mosek.accmode.var, first, last, rhs, rhs, mosek.boundkey.lo);
    
    def _task_1var_1putboundslice_1up_II_3D(self,first, last, rhs):
      self.__task_putboundslice(mosek.accmode.var, first, last, rhs, rhs, mosek.boundkey.up);
    
    def _task_1var_1putboundslice_1ra_II_3D_3D(self,first, last, lb, ub):
      self.__task_putboundslice(mosek.accmode.var, first, last, lb, ub, mosek.boundkey.ra);
  
    def _task_1var_1putboundslice_1fr_II(self,first, last):
      self.__task_putboundslice(mosek.accmode.var, first, last, None, None, mosek.boundkey.fr);
                                                                    
    def _task_1con_1putboundlist_1fx__3I_3D(self,idxs, rhs):
      self.__task_putboundlist(mosek.accmode.con, idxs, rhs, rhs, mosek.boundkey.fx);
    
    def _task_1con_1putboundlist_1lo__3I_3D(self,idxs, rhs):
      self.__task_putboundlist(mosek.accmode.con, idxs, rhs, rhs, mosek.boundkey.lo);
    
    def _task_1con_1putboundlist_1up__3I_3D(self,idxs, rhs):
      self.__task_putboundlist(mosek.accmode.con, idxs, rhs, rhs, mosek.boundkey.up);
    
    def _task_1con_1putboundlist_1ra__3I_3D_3D(self,idxs, lb, ub):
      self.__task_putboundlist(mosek.accmode.con, idxs, lb, ub, mosek.boundkey.ra);
  
    def _task_1var_1putintlist__3I(self,idxs):
      self.__task.putvartypelist(idxs,[mosek.variabletype.type_int] * len(idxs))
    def _task_1var_1putcontlist__3I(self,idxs):
      self.__task.putvartypelist(idxs,[mosek.variabletype.type_cont] * len(idxs))
    
    
    def _task_1task_1optimize_ (self):
      try:
        self.__task.optimize()
        self.__task.solutionsummary(streamtype.log)
      except mosek.Error as e:
        raise OptimizeError("Error occurred while optimizeing")
      except mosek.Warning as e:
        pass
    
    def __task_appendvars(self,num):
      idx = self.__task.getnumvar()
      self.__task.appendvars(num)
      return idx
  
    def __task_appendcons(self,num):
      idx = self.__task.getnumcon()
      self.__task.appendcons(num)
      return idx
  
    def __task_appendcones(self,ct,conesize,first,num,d0,d1):
      idx = self.__task.getnumcone()
  
      for k0 in range(d0):
        subj = numpy.arange(0,conesize*d1,d1)+k0*d1*conesize+first
        for k1 in range(d1):
          self.__task.appendcone(ct, 0.0, subj)
          subj += d1
  
      return idx
    
    def _task_1append_1var_I(self,num):
      return self.__task_appendvars(num)
  
    def _task_1append_1con_I(self,num):
      return self.__task_appendcons(num)
  
    def _task_1append_1quadcone_IIIII(self,conesize,first,num,d0,d1):
      return self.__task_appendcones(mosek.conetype.quad, conesize, first,num,d0,d1);
  
    def _task_1append_1rquadcone_IIIII(self,conesize,first,num,d0,d1):
      return self.__task_appendcones(mosek.conetype.rquad, conesize, first,num,d0,d1)
    
    def _task_1putarowslice_II_3J_3I_3D(self,first, last, ptrb, subj, cof):
      num   = last-first
      sub   = range(first,last)
      self.__task.putarowlist(sub, ptrb[:-1], ptrb[1:], subj, cof);
  
    def _task_1putaijlist__3I_3I_3DJ(self,subi,subj,cof,num):
      self.__task.putaijlist(subi[:num],subj[:num],cof[:num])
    
    def _task_1putobjectivename_S(self,name):
      self.__task.putobjname("" if name is None else name)
      
    def _task_1putobjective_Z_3I_3DD(self,maximize,subj,cof,cfix):
      c = numpy.zeros(self.__task.getnumvar(),numpy.float64)
      idxs = numpy.arange(0,len(c),dtype=numpy.int32)
      for i in range(len(subj)):
        c[subj[i]] += cof[i]
      self.__task.putclist(idxs,c)
      self.__task.putcfix(cfix)
      self.__task.putobjsense(mosek.objsense.maximize if maximize else mosek.objsense.minimize)
    
    
  
  
    def _task_1putbaraij_III(self,i,j,k):
      self.__task.putbaraij(i,j,[k], [1.0])
    def _task_1putbarcj_II(self,j,k):
      self.__task.putbarcj(j,[k],[1.0])
    
    def _task_1putbaraij_II_3I(self,i,j,k):
      self.__task.putbaraij(i,j,k, [1.0]*len(k))
    def _task_1putbarcj_I_3I(self,j,k):
      self.__task.putbarcj(j,k,[1.0]*len(k))
  
    def _task_1append_1barmatrix_I_3I_3I_3D(self,dim,subi, subj, cof):
      return self.__task.appendsparsesymmat(dim,subi,subj,cof)
  
    def _task_1barvardim_I(self,index):
      return self.__task.getdimbarvarj(index)
  
    def _task_1numbarvar_(self):
      return self.__task.getnumbarvar()
  
    def _task_1barvar_1name_IS(self, idx, name):
      self.__task.putbarvarname(idx,name)
  
    def _task_1append_1barvar_II(self,size, num):
      res = self.__task.getnumbarvar()
      self.__task.appendbarvars([size] * num)
      return res
  
    def _task_1setnumvar_I(self,num):
      numvar = self.__task.getnumvar()
      if numvar > num:
        self.__task.removevars(range(num,numvar))
  
  
    def _task_1putxx_1slice_Emosek_4fusion_4SolutionType_2II_3D(self,whichsol,first,last,xx):
      if   whichsol == mosek_fusion_SolutionType.Interior:
        self.__task.putxxslice(mosek.soltype.itr, first,last,xx)
      elif whichsol == mosek_fusion_SolutionType.Integer:
        self.__task.putxxslice(mosek.soltype.itg, first,last,xx)
      elif whichsol == mosek_fusion_SolutionType.Basic:
        self.__task.putxxslice(mosek.soltype.bas, first,last,xx)
      
    def _task_1cleanup_IIII(self,inumvar,inumcon,inumcone,inumbarvar):
      numvar  = self.__task.getnumvar()
      numcon  = self.__task.getnumcon()
      numcone = self.__task.getnumcone()
      numbarvar = self.__task.getnumbarvar()
  
      if inumcone < numcone:
        self.__task.removecones(range(inumcone,numcone))
  
      if inumvar < numvar:
        n = numvar-inumvar
        vals = numpy.zeros((n,), numpy.float64)
        bk   = [ mosek.boundkey.fx for i in range(n) ]
        self.__task.putvarboundslice(inumvar,numvar,bk, vals, vals)
        #idxs = range(inumvar,numvar)
        #self.__task.removevars(idxs)
      
      if (inumcon < numcon):
        idxs = range(inumcon,numcon)
        self.__task.removecons(idxs)
  
      if (inumbarvar < numbarvar):
        self.__task.removebarvars(range(inumbarvar,numbarvar))
      
    @staticmethod
    def __convertSolutionStatus(soltype,sol,status,prosta):
      pd = { 
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.near_optimal :               mosek_fusion_SolutionStatus.NearOptimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.near_integer_optimal :       mosek_fusion_SolutionStatus.NearOptimal,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.near_prim_and_dual_feas :    mosek_fusion_SolutionStatus.NearFeasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.near_prim_feas :             mosek_fusion_SolutionStatus.NearFeasible,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.near_dual_feas :             mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.near_prim_infeas_cer :       mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.near_dual_infeas_cer :       mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.NearCertificate,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.IllposedCert, }
  
      dd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.near_optimal :               mosek_fusion_SolutionStatus.NearOptimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Unknown, 
          mosek.solsta.near_integer_optimal :       mosek_fusion_SolutionStatus.Unknown, 
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible, 
          mosek.solsta.near_prim_and_dual_feas :    mosek_fusion_SolutionStatus.NearFeasible, 
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Unknown, 
          mosek.solsta.near_prim_feas :             mosek_fusion_SolutionStatus.Unknown, 
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Feasible, 
          mosek.solsta.near_dual_feas :             mosek_fusion_SolutionStatus.NearFeasible, 
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Certificate, 
          mosek.solsta.near_prim_infeas_cer :       mosek_fusion_SolutionStatus.NearCertificate, 
          mosek.solsta.near_dual_infeas_cer :       mosek_fusion_SolutionStatus.Unknown, 
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.IllposedCert,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Unknown, }
  
      psd = {
          mosek.prosta.unknown  :                   mosek_fusion_ProblemStatus.Unknown,
          mosek.prosta.prim_and_dual_feas :         mosek_fusion_ProblemStatus.PrimalAndDualFeasible,
          mosek.prosta.prim_feas :                  mosek_fusion_ProblemStatus.PrimalFeasible,
          mosek.prosta.dual_feas :                  mosek_fusion_ProblemStatus.DualFeasible,
          mosek.prosta.prim_infeas :                mosek_fusion_ProblemStatus.PrimalInfeasible,
          mosek.prosta.dual_infeas :                mosek_fusion_ProblemStatus.DualInfeasible,
          mosek.prosta.prim_and_dual_infeas :       mosek_fusion_ProblemStatus.PrimalAndDualInfeasible,
          mosek.prosta.ill_posed :                  mosek_fusion_ProblemStatus.IllPosed,
          mosek.prosta.near_prim_and_dual_feas :    mosek_fusion_ProblemStatus.PrimalAndDualInfeasible,
          mosek.prosta.near_prim_feas :             mosek_fusion_ProblemStatus.PrimalInfeasible,
          mosek.prosta.near_dual_feas :             mosek_fusion_ProblemStatus.DualInfeasible, 
          mosek.prosta.prim_infeas_or_unbounded :   mosek_fusion_ProblemStatus.PrimalInfeasibleOrUnbounded,
        }
  
      try: sol.pstatus = pd[status]
      except KeyError: sol.pstatus = mosek_fusion_SolutionStatus.Unknown
      
      try: sol.dstatus = dd[status]
      except KeyError: sol.dstatus = mosek_fusion_SolutionStatus.Unknown
  
      try: sol.probstatus = psd[prosta]
      except KeyError: sol.probstatus = mosek_fusion_SolutionStatus.Unknown
  
  
    @staticmethod
    def _matchargs_task_1write_S(self,*args):
        return True
    def _task_1write_S(self,filename):
        self.__task.putintparam(mosek.iparam.opf_write_solutions, 1)
        self.__task.putintparam(mosek.iparam.write_ignore_incompatible_items, 1)
        self.__task.writedata(filename)
    
    def _task_1write(self,filename):
      return self._writeProblem_S(filename)
   
    def _task_1get_(self):
      return self.__task
        
    def _task_1break_1solve_(self):
      self.__break = True
  
    @staticmethod
    def _matchargs_task_1solve_(self,*args):
      return True
    def _task_1solve_(self):
      task = self.__task
      ok = False
      try:
        trmcode = mosek.rescode.ok
        try:
          self.__break = False
          trmcode = task.optimize()
        except mosek.Error as e:
          raise mosek_fusion_OptimizeError(e.msg)
        except mosek.Warning as e:
          pass
        
        numcon  = task.getnumcon()
        numvar  = task.getnumvar()
        numcone = task.getnumcone()
        numbarvar = task.getnumbarvar()
        
        sol_bas_def = 0 != task.solutiondef(mosek.soltype.bas)
        sol_itr_def = 0 != task.solutiondef(mosek.soltype.itr)
        sol_itg_def = 0 != task.solutiondef(mosek.soltype.itg)
  
        self._sol_itr = None
        self._sol_bas = None
        self._sol_itg = None 
  
  
        if sol_itr_def:
          self._sol_itr = mosek_fusion_SolutionStruct(numvar,numcon,numcone,numbarvar)
          sol_itr = self._sol_itr
          prosta,solsta = task.getsolution(
            mosek.soltype.itr,
            #sol_itr.skc,sol_itr.skx,sol_itr.skn,
            None,None,None,
            sol_itr.xc,sol_itr.xx,sol_itr.y,
            sol_itr.slc,sol_itr.suc,
            sol_itr.slx,sol_itr.sux,
            sol_itr.snx)
          for j in range(numbarvar):
            barxjdim = task.getdimbarvarj(j)
            self._sol_itr.barx[j] = numpy.zeros(barxjdim * (barxjdim + 1) // 2, numpy.float64)
            self._sol_itr.bars[j] = numpy.zeros(barxjdim * (barxjdim + 1) // 2, numpy.float64)
            task.getbarxj(mosek.soltype.itr, j, self._sol_itr.barx[j])
            task.getbarsj(mosek.soltype.itr, j, self._sol_itr.bars[j])
  
          sol_itr.pobj = task.getprimalobj(mosek.soltype.itr)
          sol_itr.dobj = task.getdualobj  (mosek.soltype.itr)
          self.__convertSolutionStatus(mosek.soltype.itr, sol_itr, solsta,prosta);
          #print "got itr sol, stat = %s/%s" % (sol_itr.pstatus,sol_itr.dstatus)
  
        if sol_bas_def:
          self._sol_bas = mosek_fusion_SolutionStruct(numvar,numcon,numcone,numbarvar);
          sol_bas = self._sol_bas
          prosta,solsta = task.getsolution(
            mosek.soltype.bas,
            #sol_bas.skc,sol_bas.skx,sol_bas.skn,
            None,None,None,
            sol_bas.xc,sol_bas.xx,sol_bas.y,
            sol_bas.slc,sol_bas.suc,
            sol_bas.slx,sol_bas.sux,
            sol_bas.snx)
          
          # NOTE: this probably never happens:
          for j in range(numbarvar):
            barxjdim = task.getdimbarvarj(j)
            self._sol_bas.barx[j] = numpy.zeros(barxjdim * (barxjdim + 1) // 2, numpy.float64)
            self._sol_bas.bars[j] = numpy.zeros(barxjdim * (barxjdim + 1) // 2, numpy.float64)
            task.getbarxj(mosek.soltype.bas, j, self._sol_bas.barx[j])
            task.getbarsj(mosek.soltype.bas, j, self._sol_bas.bars[j])
  
          sol_bas.pobj = task.getprimalobj(mosek.soltype.bas)
          sol_bas.dobj = task.getdualobj  (mosek.soltype.bas)
          self.__convertSolutionStatus(mosek.soltype.bas, sol_bas, solsta,prosta);
  
          #print "got bas sol, stat = %s/%s" % (sol_bas.pstatus,sol_bas.dstatus)
  
        if sol_itg_def:
          self._sol_itg = mosek_fusion_SolutionStruct(numvar,numcon,numcone,numbarvar);
          sol_itg = self._sol_itg
          prosta,solsta = task.getsolution(
            mosek.soltype.itg,
            #sol_itg.skc,sol_itg.skx,sol_itg.skn,
            None,None,None,
            sol_itg.xc,sol_itg.xx,sol_itg.y,
            sol_itg.slc,sol_itg.suc,
            sol_itg.slx,sol_itg.sux,
            sol_itg.snx)
  
          # NOTE: this probably wont happen for a long time:
          for j in range(numbarvar):
            barxjdim = task.getdimbarvarj(j)
            self._sol_itg.barx[j] = numpy.zeros(barxjdim * (barxjdim + 1) // 2, numpy.float64)
            self._sol_itg.bars[j] = numpy.zeros(barxjdim * (barxjdim + 1) // 2, numpy.float64)
            task.getbarxj(mosek.soltype.itg, j, self._sol_itg.barx[j])
            task.getbarsj(mosek.soltype.itg, j, self._sol_itg.bars[j])
  
          sol_itg.pobj = task.getprimalobj(mosek.soltype.itg)
          self.__convertSolutionStatus(mosek.soltype.itg, sol_itg, solsta,prosta);
        ok = True
      
      finally:
        if not ok: # means exception
          self._sol_itr = None
          self._sol_bas = None
          self._sol_itg = None
  
    @staticmethod
    def _env_1syeig_I_3D_3D(n,a,w): BaseModel._globalEnv().syeig(n,a,w)
    @staticmethod
    def _env_1syevd_I_3D_3D(n,a,w): BaseModel._globalEnv().syevd(n,a,w)
    #@staticmethod
    #def _env_1potrf_I_3D(n,a):      BaseModel._globalEnv().potrf(n,a)
  
  return BaseModel
mosek_fusion_BaseModel=__mk_mosek_fusion_BaseModel()
#BEFORE CLASS
def __mk_mosek_fusion_Model():
 class Model(mosek_fusion_BaseModel):
  __slots__ = ['_Model__task_vars_used','_Model__task_vars_allocated','_Model__con_map','_Model__cons_used','_Model__cons','_vars_used','_vars','_Model__initsol_xx_flag','_Model__initsol_xx','_natbarvarmap_num','_natbarvarmap_Var','_Model__var_map','_Model__natvarmap_num','_Model__natvarmap_idx','_Model__natvarmap_Var','_Model__solutionptr','_Model__acceptable_sol','_Model__model_name']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Model.ctor()\n\tmosek.fusion.Model.ctor(string)')
  def getSolverDoubleInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverDoubleInfo_S(*args): # string
      return self._getSolverDoubleInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverDoubleInfo_S(*args): # string
      return self._getSolverDoubleInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverDoubleInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverDoubleInfo(string)')
  def hasVariable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_hasVariable_S(*args): # string
      return self._hasVariable_S(*args)
    elif mosek_fusion_Model._match_alt_hasVariable_S(*args): # string
      return self._hasVariable_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasVariable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasVariable(string)')
  def getPrimalSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getPrimalSolutionStatus_(*args): # 
      return self._getPrimalSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getPrimalSolutionStatus_(*args): # 
      return self._getPrimalSolutionStatus_alt_(*args)
    elif mosek_fusion_Model._match_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getPrimalSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getPrimalSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getPrimalSolutionStatus()\n\tmosek.fusion.Model.getPrimalSolutionStatus(mosek.fusion.SolutionType)')
  def objective(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_objective_D(*args): # double
      return self._objective_D(*args)
    elif mosek_fusion_Model._match_alt_objective_D(*args): # double
      return self._objective_alt_D(*args)
    elif mosek_fusion_Model._match_objective_SD(*args): # string,double
      return self._objective_SD(*args)
    elif mosek_fusion_Model._match_alt_objective_SD(*args): # string,double
      return self._objective_alt_SD(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Variable
      return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Variable
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2D(*args): # mosek.fusion.ObjectiveSense,double
      return self._objective_Emosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2D(*args): # mosek.fusion.ObjectiveSense,double
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Variable
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Variable
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args): # string,mosek.fusion.ObjectiveSense,double
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args): # string,mosek.fusion.ObjectiveSense,double
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2D(*args)
    else:
      raise ValueError('Invalid argument list objective('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.objective(double)\n\tmosek.fusion.Model.objective(string,double)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,mosek.fusion.Variable)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,double)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,mosek.fusion.Expression)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,mosek.fusion.Variable)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,double)')
  def hasConstraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_hasConstraint_S(*args): # string
      return self._hasConstraint_S(*args)
    elif mosek_fusion_Model._match_alt_hasConstraint_S(*args): # string
      return self._hasConstraint_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasConstraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasConstraint(string)')
  def acceptedSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_Model._match_alt_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._acceptedSolutionStatus_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list acceptedSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.acceptedSolutionStatus(mosek.fusion.AccSolutionStatus)')
  def getAcceptedSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getAcceptedSolutionStatus_(*args): # 
      return self._getAcceptedSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getAcceptedSolutionStatus_(*args): # 
      return self._getAcceptedSolutionStatus_alt_(*args)
    else:
      raise ValueError('Invalid argument list getAcceptedSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getAcceptedSolutionStatus()')
  def breakSolver(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_breakSolver_(*args): # 
      return self._breakSolver_(*args)
    elif mosek_fusion_Model._match_alt_breakSolver_(*args): # 
      return self._breakSolver_alt_(*args)
    else:
      raise ValueError('Invalid argument list breakSolver('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.breakSolver()')
  def constraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.LinPSDDomain
      return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.LinPSDDomain
      return self._constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.PSDDomain
      return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.PSDDomain
      return self._constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.LinPSDDomain
      return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.LinPSDDomain
      return self._constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.PSDDomain
      return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.PSDDomain
      return self._constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.QConeDomain
      return self._constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain
      return self._constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.LinearDomain
      return self._constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.QConeDomain
      return self._constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list constraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Variable,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Variable,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Variable,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Variable,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Variable,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Variable,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Variable,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Variable,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Variable,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Variable,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Set,mosek.fusion.Variable,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Set,mosek.fusion.Expression,mosek.fusion.QConeDomain)')
  def getDualSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getDualSolutionStatus_(*args): # 
      return self._getDualSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getDualSolutionStatus_(*args): # 
      return self._getDualSolutionStatus_alt_(*args)
    elif mosek_fusion_Model._match_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getDualSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getDualSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getDualSolutionStatus()\n\tmosek.fusion.Model.getDualSolutionStatus(mosek.fusion.SolutionType)')
  def dualObjValue(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_dualObjValue_(*args): # 
      return self._dualObjValue_(*args)
    elif mosek_fusion_Model._match_alt_dualObjValue_(*args): # 
      return self._dualObjValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list dualObjValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.dualObjValue()')
  def getTask(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getTask_(*args): # 
      return self._getTask_(*args)
    elif mosek_fusion_Model._match_alt_getTask_(*args): # 
      return self._getTask_alt_(*args)
    else:
      raise ValueError('Invalid argument list getTask('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getTask()')
  @staticmethod
  def putlicensecode(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensecode__3I(*args): # []int32
      return mosek_fusion_Model._putlicensecode__3I(*args)
    elif mosek_fusion_Model._match_alt_putlicensecode__3I(*args): # []int32
      return mosek_fusion_Model._putlicensecode_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list putlicensecode('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensecode(array(int32,ndim=1))')
  @staticmethod
  def putlicensewait(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensewait_Z(*args): # bool
      return mosek_fusion_Model._putlicensewait_Z(*args)
    elif mosek_fusion_Model._match_alt_putlicensewait_Z(*args): # bool
      return mosek_fusion_Model._putlicensewait_alt_Z(*args)
    else:
      raise ValueError('Invalid argument list putlicensewait('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensewait(bool)')
  def getName(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getName_(*args): # 
      return self._getName_(*args)
    elif mosek_fusion_Model._match_alt_getName_(*args): # 
      return self._getName_alt_(*args)
    else:
      raise ValueError('Invalid argument list getName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getName()')
  def getProblemStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getProblemStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getProblemStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getProblemStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getProblemStatus(mosek.fusion.SolutionType)')
  def dispose(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_dispose_(*args): # 
      return self._dispose_(*args)
    elif mosek_fusion_Model._match_alt_dispose_(*args): # 
      return self._dispose_alt_(*args)
    else:
      raise ValueError('Invalid argument list dispose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.dispose()')
  def numConstraints(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_numConstraints_(*args): # 
      return self._numConstraints_(*args)
    elif mosek_fusion_Model._match_alt_numConstraints_(*args): # 
      return self._numConstraints_alt_(*args)
    else:
      raise ValueError('Invalid argument list numConstraints('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.numConstraints()')
  def getVariable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getVariable_S(*args): # string
      return self._getVariable_S(*args)
    elif mosek_fusion_Model._match_alt_getVariable_S(*args): # string
      return self._getVariable_alt_S(*args)
    elif mosek_fusion_Model._match_getVariable_I(*args): # int32
      return self._getVariable_I(*args)
    elif mosek_fusion_Model._match_alt_getVariable_I(*args): # int32
      return self._getVariable_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getVariable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariable(string)\n\tmosek.fusion.Model.getVariable(int32)')
  def flushSolutions(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_flushSolutions_(*args): # 
      return self._flushSolutions_(*args)
    elif mosek_fusion_Model._match_alt_flushSolutions_(*args): # 
      return self._flushSolutions_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushSolutions('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushSolutions()')
  def setLogHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setLogHandler_LSystem_4StreamWriter_2(*args): # System.StreamWriter
      return self._setLogHandler_LSystem_4StreamWriter_2(*args)
    elif mosek_fusion_Model._match_alt_setLogHandler_LSystem_4StreamWriter_2(*args): # System.StreamWriter
      return self._setLogHandler_alt_LSystem_4StreamWriter_2(*args)
    else:
      raise ValueError('Invalid argument list setLogHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setLogHandler(System.StreamWriter)')
  def selectedSolution(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_selectedSolution_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._selectedSolution_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_selectedSolution_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._selectedSolution_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list selectedSolution('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.selectedSolution(mosek.fusion.SolutionType)')
  def getSolverIntInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverIntInfo_S(*args): # string
      return self._getSolverIntInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverIntInfo_S(*args): # string
      return self._getSolverIntInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverIntInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverIntInfo(string)')
  def primalObjValue(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_primalObjValue_(*args): # 
      return self._primalObjValue_(*args)
    elif mosek_fusion_Model._match_alt_primalObjValue_(*args): # 
      return self._primalObjValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list primalObjValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.primalObjValue()')
  def setSolverParam(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setSolverParam_SS(*args): # string,string
      return self._setSolverParam_SS(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SS(*args): # string,string
      return self._setSolverParam_alt_SS(*args)
    elif mosek_fusion_Model._match_setSolverParam_SI(*args): # string,int32
      return self._setSolverParam_SI(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SI(*args): # string,int32
      return self._setSolverParam_alt_SI(*args)
    elif mosek_fusion_Model._match_setSolverParam_SD(*args): # string,double
      return self._setSolverParam_SD(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SD(*args): # string,double
      return self._setSolverParam_alt_SD(*args)
    else:
      raise ValueError('Invalid argument list setSolverParam('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setSolverParam(string,string)\n\tmosek.fusion.Model.setSolverParam(string,int32)\n\tmosek.fusion.Model.setSolverParam(string,double)')
  def solve(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_solve_(*args): # 
      return self._solve_(*args)
    elif mosek_fusion_Model._match_alt_solve_(*args): # 
      return self._solve_alt_(*args)
    else:
      raise ValueError('Invalid argument list solve('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.solve()')
  def variable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_variable_(*args): # 
      return self._variable_(*args)
    elif mosek_fusion_Model._match_alt_variable_(*args): # 
      return self._variable_alt_(*args)
    elif mosek_fusion_Model._match_variable_S(*args): # string
      return self._variable_S(*args)
    elif mosek_fusion_Model._match_alt_variable_S(*args): # string
      return self._variable_alt_S(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.LinPSDDomain
      return self._variable_Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.LinPSDDomain
      return self._variable_alt_Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return self._variable_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return self._variable_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_I(*args): # int32
      return self._variable_I(*args)
    elif mosek_fusion_Model._match_alt_variable_I(*args): # int32
      return self._variable_alt_I(*args)
    elif mosek_fusion_Model._match_variable__3I(*args): # []int32
      return self._variable__3I(*args)
    elif mosek_fusion_Model._match_alt_variable__3I(*args): # []int32
      return self._variable_alt__3I(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.PSDDomain
      return self._variable_Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.PSDDomain
      return self._variable_alt_Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.QConeDomain
      return self._variable_Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.QConeDomain
      return self._variable_alt_Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return self._variable_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return self._variable_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4LinearDomain_2(*args): # int32,mosek.fusion.LinearDomain
      return self._variable_ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4LinearDomain_2(*args): # int32,mosek.fusion.LinearDomain
      return self._variable_alt_ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.LinearDomain
      return self._variable_SLmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.LinearDomain
      return self._variable_alt_SLmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.QConeDomain
      return self._variable_SLmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.QConeDomain
      return self._variable_alt_SLmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4RangeDomain_2(*args): # []int32,mosek.fusion.RangeDomain
      return self._variable__3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4RangeDomain_2(*args): # []int32,mosek.fusion.RangeDomain
      return self._variable_alt__3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4SymmetricLinearDomain_2(*args): # int32,mosek.fusion.SymmetricLinearDomain
      return self._variable_ILmosek_4fusion_4SymmetricLinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4SymmetricLinearDomain_2(*args): # int32,mosek.fusion.SymmetricLinearDomain
      return self._variable_alt_ILmosek_4fusion_4SymmetricLinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SI(*args): # string,int32
      return self._variable_SI(*args)
    elif mosek_fusion_Model._match_alt_variable_SI(*args): # string,int32
      return self._variable_alt_SI(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4LinearDomain_2(*args): # []int32,mosek.fusion.LinearDomain
      return self._variable__3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4LinearDomain_2(*args): # []int32,mosek.fusion.LinearDomain
      return self._variable_alt__3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.QConeDomain
      return self._variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.QConeDomain
      return self._variable_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4LinPSDDomain_2(*args): # int32,mosek.fusion.LinPSDDomain
      return self._variable_ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4LinPSDDomain_2(*args): # int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3I(*args): # string,[]int32
      return self._variable_S_3I(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3I(*args): # string,[]int32
      return self._variable_alt_S_3I(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4RangeDomain_2(*args): # int32,mosek.fusion.RangeDomain
      return self._variable_ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4RangeDomain_2(*args): # int32,mosek.fusion.RangeDomain
      return self._variable_alt_ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Set,mosek.fusion.LinearDomain
      return self._variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Set,mosek.fusion.LinearDomain
      return self._variable_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4PSDDomain_2(*args): # int32,mosek.fusion.PSDDomain
      return self._variable_ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4PSDDomain_2(*args): # int32,mosek.fusion.PSDDomain
      return self._variable_alt_ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.RangeDomain
      return self._variable_SLmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.RangeDomain
      return self._variable_alt_SLmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.LinPSDDomain
      return self._variable_SLmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.LinPSDDomain
      return self._variable_alt_SLmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.RangeDomain
      return self._variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Set,mosek.fusion.RangeDomain
      return self._variable_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4QConeDomain_2(*args): # int32,mosek.fusion.QConeDomain
      return self._variable_ILmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4QConeDomain_2(*args): # int32,mosek.fusion.QConeDomain
      return self._variable_alt_ILmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.PSDDomain
      return self._variable_SLmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.PSDDomain
      return self._variable_alt_SLmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args): # string,[]int32,mosek.fusion.LinearDomain
      return self._variable_S_3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args): # string,[]int32,mosek.fusion.LinearDomain
      return self._variable_alt_S_3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4QConeDomain_2(*args): # string,int32,mosek.fusion.QConeDomain
      return self._variable_SILmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4QConeDomain_2(*args): # string,int32,mosek.fusion.QConeDomain
      return self._variable_alt_SILmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args): # string,[]int32,mosek.fusion.PSDDomain
      return self._variable_S_3ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args): # string,[]int32,mosek.fusion.PSDDomain
      return self._variable_alt_S_3ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.QConeDomain
      return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.QConeDomain
      return self._variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.RangeDomain
      return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.RangeDomain
      return self._variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,mosek.fusion.LinPSDDomain
      return self._variable_SILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_SILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args): # string,[]int32,mosek.fusion.RangeDomain
      return self._variable_S_3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args): # string,[]int32,mosek.fusion.RangeDomain
      return self._variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_IILmosek_4fusion_4PSDDomain_2(*args): # int32,int32,mosek.fusion.PSDDomain
      return self._variable_IILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_IILmosek_4fusion_4PSDDomain_2(*args): # int32,int32,mosek.fusion.PSDDomain
      return self._variable_alt_IILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4RangeDomain_2(*args): # string,int32,mosek.fusion.RangeDomain
      return self._variable_SILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4RangeDomain_2(*args): # string,int32,mosek.fusion.RangeDomain
      return self._variable_alt_SILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4PSDDomain_2(*args): # string,int32,mosek.fusion.PSDDomain
      return self._variable_SILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4PSDDomain_2(*args): # string,int32,mosek.fusion.PSDDomain
      return self._variable_alt_SILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.PSDDomain
      return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.PSDDomain
      return self._variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.LinearDomain
      return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.LinearDomain
      return self._variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4LinearDomain_2(*args): # string,int32,mosek.fusion.LinearDomain
      return self._variable_SILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4LinearDomain_2(*args): # string,int32,mosek.fusion.LinearDomain
      return self._variable_alt_SILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args): # string,[]int32,mosek.fusion.LinPSDDomain
      return self._variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args): # string,[]int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_S_3ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4SymmetricLinearDomain_2(*args): # string,int32,mosek.fusion.SymmetricLinearDomain
      return self._variable_SILmosek_4fusion_4SymmetricLinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4SymmetricLinearDomain_2(*args): # string,int32,mosek.fusion.SymmetricLinearDomain
      return self._variable_alt_SILmosek_4fusion_4SymmetricLinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_IILmosek_4fusion_4LinPSDDomain_2(*args): # int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_IILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_IILmosek_4fusion_4LinPSDDomain_2(*args): # int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_IILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.LinPSDDomain
      return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Set,mosek.fusion.LinPSDDomain
      return self._variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_SIILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_SIILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SIILmosek_4fusion_4PSDDomain_2(*args): # string,int32,int32,mosek.fusion.PSDDomain
      return self._variable_SIILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SIILmosek_4fusion_4PSDDomain_2(*args): # string,int32,int32,mosek.fusion.PSDDomain
      return self._variable_alt_SIILmosek_4fusion_4PSDDomain_2(*args)
    else:
      raise ValueError('Invalid argument list variable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.variable()\n\tmosek.fusion.Model.variable(string)\n\tmosek.fusion.Model.variable(mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32)\n\tmosek.fusion.Model.variable(array(int32,ndim=1))\n\tmosek.fusion.Model.variable(mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.SymmetricLinearDomain)\n\tmosek.fusion.Model.variable(string,int32)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.Set,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1))\n\tmosek.fusion.Model.variable(int32,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.Set,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.Set,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.Set,mosek.fusion.QConeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.Set,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.Set,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.Set,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.SymmetricLinearDomain)\n\tmosek.fusion.Model.variable(int32,int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.Set,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,int32,int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,int32,int32,mosek.fusion.PSDDomain)')
  def writeTask(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_writeTask_S(*args): # string
      return self._writeTask_S(*args)
    elif mosek_fusion_Model._match_alt_writeTask_S(*args): # string
      return self._writeTask_alt_S(*args)
    else:
      raise ValueError('Invalid argument list writeTask('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.writeTask(string)')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_clone_(*args): # 
      return self._clone_(*args)
    elif mosek_fusion_Model._match_alt_clone_(*args): # 
      return self._clone_alt_(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.clone()')
  def numVariables(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_numVariables_(*args): # 
      return self._numVariables_(*args)
    elif mosek_fusion_Model._match_alt_numVariables_(*args): # 
      return self._numVariables_alt_(*args)
    else:
      raise ValueError('Invalid argument list numVariables('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.numVariables()')
  def getConstraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getConstraint_S(*args): # string
      return self._getConstraint_S(*args)
    elif mosek_fusion_Model._match_alt_getConstraint_S(*args): # string
      return self._getConstraint_alt_S(*args)
    elif mosek_fusion_Model._match_getConstraint_I(*args): # int32
      return self._getConstraint_I(*args)
    elif mosek_fusion_Model._match_alt_getConstraint_I(*args): # int32
      return self._getConstraint_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getConstraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getConstraint(string)\n\tmosek.fusion.Model.getConstraint(int32)')
  def flushNames(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_flushNames_(*args): # 
      return self._flushNames_(*args)
    elif mosek_fusion_Model._match_alt_flushNames_(*args): # 
      return self._flushNames_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushNames('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushNames()')
  def setDataCallbackHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args): # System.DataCallbackHandler
      return self._setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args)
    elif mosek_fusion_Model._match_alt_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args): # System.DataCallbackHandler
      return self._setDataCallbackHandler_alt_LSystem_4DataCallbackHandler_2(*args)
    else:
      raise ValueError('Invalid argument list setDataCallbackHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setDataCallbackHandler(System.DataCallbackHandler)')
  @staticmethod
  def putlicensepath(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensepath_S(*args): # string
      return mosek_fusion_Model._putlicensepath_S(*args)
    elif mosek_fusion_Model._match_alt_putlicensepath_S(*args): # string
      return mosek_fusion_Model._putlicensepath_alt_S(*args)
    else:
      raise ValueError('Invalid argument list putlicensepath('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensepath(string)')
  def setCallbackHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setCallbackHandler_LSystem_4CallbackHandler_2(*args): # System.CallbackHandler
      return self._setCallbackHandler_LSystem_4CallbackHandler_2(*args)
    elif mosek_fusion_Model._match_alt_setCallbackHandler_LSystem_4CallbackHandler_2(*args): # System.CallbackHandler
      return self._setCallbackHandler_alt_LSystem_4CallbackHandler_2(*args)
    else:
      raise ValueError('Invalid argument list setCallbackHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setCallbackHandler(System.CallbackHandler)')
  def getSolverLIntInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverLIntInfo_S(*args): # string
      return self._getSolverLIntInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverLIntInfo_S(*args): # string
      return self._getSolverLIntInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverLIntInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverLIntInfo(string)')
  def __repr__(self): return 'mosek.fusion.Model'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2(m):
    o = Model.__new__(Model)
    o._ctor_init_Lmosek_4fusion_4Model_2(m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2(self,m):
    self._ctor_init_Lmosek_4fusion_4Model_2(m)
  def _ctor_init_Lmosek_4fusion_4Model_2(self,m):
   mosek_fusion_BaseModel._ctor_init_Lmosek_4fusion_4BaseModel_2(self,m)
   self.__model_name = mosek.fusion.Utils.StringBuffer()._a_S((m.__model_name))._a_S("(clone)")._toString_()
   self.__acceptable_sol = (m.__acceptable_sol)
   self.__solutionptr = (m.__solutionptr)
   _0=self
   self._vars = numpy.array([(m._vars)[_1]._clone_Lmosek_4fusion_4Model_2(_0) for _1 in range(0,(m._vars_used))], dtype=numpy.dtype(object))
   self._vars_used = (m._vars_used)
   self.__var_map = (m.__var_map)._clone_()
   self.__task_vars_allocated = (m.__task_vars_allocated)
   self.__task_vars_used = (m.__task_vars_used)
   self.__cons = numpy.array([(m.__cons)[_2]._clone_Lmosek_4fusion_4Model_2(_0) for _2 in range(0,(m.__cons_used))], dtype=numpy.dtype(object))
   self.__cons_used = (m.__cons_used)
   self.__con_map = (m.__con_map)._clone_()
   self.__natvarmap_Var = numpy.array([(m.__natvarmap_Var)[_3] for _3 in range(0,(m.__natvarmap_num))], dtype=numpy.dtype(numpy.int32))
   self.__natvarmap_idx = numpy.array([(m.__natvarmap_idx)[_4] for _4 in range(0,(m.__natvarmap_num))], dtype=numpy.dtype(numpy.int64))
   self.__natvarmap_num = (m.__natvarmap_num)
   self._natbarvarmap_Var = numpy.array([(m.__natvarmap_Var)[_5] for _5 in range(0,(m.__natvarmap_num))], dtype=numpy.dtype(numpy.int32))
   self._natbarvarmap_num = (m._natbarvarmap_num)
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
  @staticmethod
  def _ctor_():
    o = Model.__new__(Model)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_BaseModel._ctor_init_SS(self,"","")
   self.__model_name = ""
   self.__acceptable_sol = mosek.fusion.AccSolutionStatus.Optimal
   self.__solutionptr = mosek.fusion.SolutionType.Default
   self.__natvarmap_Var = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap_idx = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int64))
   self.__natvarmap_num = 0
   self._natbarvarmap_Var = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self._natbarvarmap_num = 0
   self.__task_vars_allocated = 0
   self.__task_vars_used = 0
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
   self._vars = numpy.zeros((1024,), dtype=numpy.dtype(object))
   self._vars_used = 0
   self.__var_map = mosek.fusion.Utils.StringIntMap()
   self.__cons = numpy.zeros((1024,), dtype=numpy.dtype(object))
   self.__cons_used = 0
   self.__con_map = mosek.fusion.Utils.StringIntMap()
  @staticmethod
  def _ctor_S(name):
    o = Model.__new__(Model)
    o._ctor_init_S(name)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    name, = args
    return (__arg_match_S__(name))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    name, = args
    return (__arg_alt_match_S__(name))
  def _ctor_alt_init_S(self,name):
    self._ctor_init_S(name)
  def _ctor_init_S(self,name):
   mosek_fusion_BaseModel._ctor_init_SS(self,name,"")
   self.__model_name = name
   self.__acceptable_sol = mosek.fusion.AccSolutionStatus.NearOptimal
   self.__solutionptr = mosek.fusion.SolutionType.Default
   self.__natvarmap_Var = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap_idx = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int64))
   self.__natvarmap_num = 0
   self._natbarvarmap_Var = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self._natbarvarmap_num = 0
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
   self._vars = numpy.zeros((1024,), dtype=numpy.dtype(object))
   self._vars_used = 0
   self.__var_map = mosek.fusion.Utils.StringIntMap()
   self.__task_vars_allocated = 0
   self.__task_vars_used = 0
   self.__cons = numpy.zeros((1024,), dtype=numpy.dtype(object))
   self.__cons_used = 0
   self.__con_map = mosek.fusion.Utils.StringIntMap()
  @staticmethod
  def _match_putlicensewait_Z(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Z__(_0))
  @staticmethod
  def _match_alt_putlicensewait_Z(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Z__(_0))
  @staticmethod
  def _putlicensewait_alt_Z(_t__0):
    return mosek_fusion_Model._putlicensewait_Z(_0)
  @staticmethod
  def _putlicensewait_Z(_0):
   mosek.fusion.BaseModel._env_1putlicensewait_Z(_0)
  @staticmethod
  def _match_putlicensepath_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_putlicensepath_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  @staticmethod
  def _putlicensepath_alt_S(_t__0):
    return mosek_fusion_Model._putlicensepath_S(_0)
  @staticmethod
  def _putlicensepath_S(_0):
   mosek.fusion.BaseModel._env_1putlicensepath_S(_0)
  @staticmethod
  def _match_putlicensecode__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_putlicensecode__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _putlicensecode_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Model._putlicensecode__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _putlicensecode__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   mosek.fusion.BaseModel._env_1putlicensecode__3I(_0)
  @staticmethod
  def __inst_alt__3Lmosek_4fusion_4Variable_2II_3JI_3I_3I_3I(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _4=numpy.int32(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Model.__inst__3Lmosek_4fusion_4Variable_2II_3JI_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __inst__3Lmosek_4fusion_4Variable_2II_3JI_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   _8=numpy.zeros(((int((_0).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
   for _9 in range(0,int((_0).shape[0])):
    _8[(_9 + 1)] = (_8[_9] + _0[_9]._size_())
   if (int((_0).shape[0])==1):
    _0[0]._inst__3JIIJJ_3I_3I_3I(_3,_1,_2,0,_4,_5,_6,_7)
   elif (int((_0).shape[0])==2):
    for _10 in range(_1,_2):
     if (_3[_10] < _8[1]):
      _0[0]._inst_JJ_3I_3I_3I(_3[_10],((_4 + _10) - _1),_5,_6,_7)
     else:
      _0[1]._inst_JJ_3I_3I_3I((_3[_10] - _8[1]),((_4 + _10) - _1),_5,_6,_7)
   elif (int((_0).shape[0])==3):
    for _11 in range(_1,_2):
     if (_3[_11] < _8[1]):
      _0[0]._inst_JJ_3I_3I_3I(_3[_11],((_4 + _11) - _1),_5,_6,_7)
     elif (_3[_11] < _8[2]):
      _0[1]._inst_JJ_3I_3I_3I((_3[_11] - _8[1]),((_4 + _11) - _1),_5,_6,_7)
     else:
      _0[2]._inst_JJ_3I_3I_3I((_3[_11] - _8[2]),((_4 + _11) - _1),_5,_6,_7)
   else:
    _12=4
    _13=_8[int((_0).shape[0])]
    _14=0
    _15=int((_0).shape[0])
    _14,_15 = fragments._c_closure_0(_14,_15) # src/fusion/Model.mbi:3300:45-79
    _14 = numpy.int32(_14) # postprocess
    _15 = numpy.int32(_15) # postprocess
    if (False and (((_2 - _1) + _13) < ((_12 * (_2 - _1)) * _14))):
     _16=numpy.zeros(((_13 + 1),), dtype=numpy.dtype(numpy.int32))
     for _17 in range(_1,_2):
      _16[_3[_17]] += 1
     fragments._c_closure_1(_16,_13) # src/fusion/Model.mbi:3305:13-61
     _18=numpy.zeros(((_2 - _1),), dtype=numpy.dtype(numpy.int64))
     for _19 in range(_1,_2):
      _18[(_16[_3[_19]] - _1)] = _19
      _16[_3[_19]] += 1
     _20=0
     _21=0
     while ((_21 < int((_18).shape[0])) and (_20 < int((_0).shape[0]))):
      if (_8[(_20 + 1)] < _3[_18[_21]]):
       _20 += 1
      else:
       _0[_20]._inst_JJ_3I_3I_3I((_3[_18[_21]] - _8[_20]),((_4 + _18[_21]) - _1),_5,_6,_7)
       _21 += 1
    else:
     for _22 in range(_1,_2):
      _23=(int((_8).shape[0]) // 2)
      _23 = fragments._c_closure_2(_22,_23,_3,_8) # src/fusion/Model.mbi:3328:15-3341:16
      _23 = numpy.int32(_23) # postprocess
      _0[_23]._inst_JJ_3I_3I_3I((_3[_22] - _8[_23]),((_4 + _22) - _1),_5,_6,_7)
  @staticmethod
  def __inst_alt__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Model.__inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   mosek.fusion.Model.__inst__3Lmosek_4fusion_4Variable_2II_3JI_3I_3I_3I(_0,0,int((_1).shape[0]),_1,0,_2,_3,_4)
  @staticmethod
  def _match_dispose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dispose_(*args):
    if len(args) != 0: return False
    return True
  def _dispose_alt_(self,):
    return self._dispose_()
  def _dispose_(self,):
   for _0 in range(0,self._vars_used):
    self._vars[_0] = None
   self._vars_used = 0
   for _1 in range(0,self.__cons_used):
    self.__cons[_1] = None
   self.__cons_used = 0
   mosek_fusion_BaseModel._dispose_(self)
  def _varname_alt_IS(self,_t__0,_t__1):
    return self._varname_IS(numpy.int32(__0),_1)
  def _varname_IS(self,_0,_1):
   self._task_1var_1name_IS(_0,_1)
  def _nativeVarToStr_alt_ILmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2(numpy.int32(__0),_1)
  def _nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if ((_0 < 0) or (_0 >= self.__natvarmap_num)):
    raise mosek_fusion_IndexError._ctor_S("Native variable index out of bounds")
   self._vars[self.__natvarmap_Var[_0]]._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self.__natvarmap_idx[_0],_1)
  def _append_1linearvar_alt_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(self,_t__0,_t__1,_t__2,_t__3):
    return self._append_1linearvar_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(_0,numpy.int64(__1),__2,numpy.float64(__3))
  def _append_1linearvar_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(self,_0,_1,_2,_3):
   _4=self._alloc_1linearvar_SEmosek_4fusion_4RelationKey_2D("",_2,_3)
   self.__natvarmap_1ensure_I(1)
   self.__natvarmap_idx[_4] = _1
   self.__natvarmap_Var[_4] = self._vars_used
   self.__natvarmap_num = (self.__natvarmap_num + 1)
   return numpy.int32(_4)
  def _append_1rangedvar_alt_Lmosek_4fusion_4ModelVariable_2JDD(self,_t__0,_t__1,_t__2,_t__3):
    return self._append_1rangedvar_Lmosek_4fusion_4ModelVariable_2JDD(_0,numpy.int64(__1),numpy.float64(__2),numpy.float64(__3))
  def _append_1rangedvar_Lmosek_4fusion_4ModelVariable_2JDD(self,_0,_1,_2,_3):
   _4=self._alloc_1rangedvar_SDD("",_2,_3)
   self.__natvarmap_1ensure_I(1)
   self.__natvarmap_idx[_4] = _1
   self.__natvarmap_Var[_4] = self._vars_used
   self.__natvarmap_num = (self.__natvarmap_num + 1)
   return numpy.int32(_4)
  @staticmethod
  def _match_getTask_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getTask_(*args):
    if len(args) != 0: return False
    return True
  def _getTask_alt_(self,):
    return self._getTask_()
  def _getTask_(self,):
   return (self._task_1get_())
  @staticmethod
  def _match_flushNames_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushNames_(*args):
    if len(args) != 0: return False
    return True
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   for _0 in range(0,self._vars_used):
    self._vars[_0]._flushNames_()
   for _1 in range(0,self.__cons_used):
    self.__cons[_1]._flushNames_()
  @staticmethod
  def _match_writeTask_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_writeTask_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _writeTask_alt_S(self,_t__0):
    return self._writeTask_S(_0)
  def _writeTask_S(self,_0):
   self._flushNames_()
   self._task_1setnumvar_I(self.__task_vars_used)
   self.__task_vars_allocated = self.__task_vars_used
   self._task_1write_S(_0)
  @staticmethod
  def _match_getSolverLIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverLIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverLIntInfo_alt_S(self,_t__0):
    return self._getSolverLIntInfo_S(_0)
  def _getSolverLIntInfo_S(self,_0):
   return numpy.int64(self._task_1get_1liinf_S(_0))
  @staticmethod
  def _match_getSolverIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverIntInfo_alt_S(self,_t__0):
    return self._getSolverIntInfo_S(_0)
  def _getSolverIntInfo_S(self,_0):
   return numpy.int32(self._task_1get_1iinf_S(_0))
  @staticmethod
  def _match_getSolverDoubleInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverDoubleInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverDoubleInfo_alt_S(self,_t__0):
    return self._getSolverDoubleInfo_S(_0)
  def _getSolverDoubleInfo_S(self,_0):
   return numpy.float64(self._task_1get_1dinf_S(_0))
  @staticmethod
  def _match_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4CallbackHandler_2__(_0))
  @staticmethod
  def _match_alt_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4CallbackHandler_2__(_0))
  def _setCallbackHandler_alt_LSystem_4CallbackHandler_2(self,_t__0):
    return self._setCallbackHandler_LSystem_4CallbackHandler_2(_0)
  def _setCallbackHandler_LSystem_4CallbackHandler_2(self,_0):
   self._task_1setCallbackHandler_LSystem_4CallbackHandler_2(_0)
  @staticmethod
  def _match_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4DataCallbackHandler_2__(_0))
  @staticmethod
  def _match_alt_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4DataCallbackHandler_2__(_0))
  def _setDataCallbackHandler_alt_LSystem_4DataCallbackHandler_2(self,_t__0):
    return self._setDataCallbackHandler_LSystem_4DataCallbackHandler_2(_0)
  def _setDataCallbackHandler_LSystem_4DataCallbackHandler_2(self,_0):
   self._task_1setDataCallbackHandler_LSystem_4DataCallbackHandler_2(_0)
  @staticmethod
  def _match_setLogHandler_LSystem_4StreamWriter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4StreamWriter_2__(_0))
  @staticmethod
  def _match_alt_setLogHandler_LSystem_4StreamWriter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4StreamWriter_2__(_0))
  def _setLogHandler_alt_LSystem_4StreamWriter_2(self,_t__0):
    return self._setLogHandler_LSystem_4StreamWriter_2(_0)
  def _setLogHandler_LSystem_4StreamWriter_2(self,_0):
   self._task_1setLogHandler_LSystem_4StreamWriter_2(_0)
  @staticmethod
  def _match_setSolverParam_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_D__(_1))
  def _setSolverParam_alt_SD(self,_t__0,_t__1):
    return self._setSolverParam_SD(_0,numpy.float64(__1))
  def _setSolverParam_SD(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SD(self,_0,_1)
  @staticmethod
  def _match_setSolverParam_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1))
  def _setSolverParam_alt_SI(self,_t__0,_t__1):
    return self._setSolverParam_SI(_0,numpy.int32(__1))
  def _setSolverParam_SI(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SI(self,_0,_1)
  @staticmethod
  def _match_setSolverParam_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_S__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_S__(_1))
  def _setSolverParam_alt_SS(self,_t__0,_t__1):
    return self._setSolverParam_SS(_0,_1)
  def _setSolverParam_SS(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SS(self,_0,_1)
  @staticmethod
  def _match_breakSolver_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_breakSolver_(*args):
    if len(args) != 0: return False
    return True
  def _breakSolver_alt_(self,):
    return self._breakSolver_()
  def _breakSolver_(self,):
   self._task_1break_1solve_()
  @staticmethod
  def _match_solve_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_solve_(*args):
    if len(args) != 0: return False
    return True
  def _solve_alt_(self,):
    return self._solve_()
  def _solve_(self,):
   self._task_1setnumvar_I(self.__task_vars_used)
   self.__task_vars_allocated = self.__task_vars_used
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Interior)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Integer)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Basic)
   self._task_1solve_()
  @staticmethod
  def _match_flushSolutions_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushSolutions_(*args):
    if len(args) != 0: return False
    return True
  def _flushSolutions_alt_(self,):
    return self._flushSolutions_()
  def _flushSolutions_(self,):
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Interior)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Integer)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Basic)
  def __flush_1initsol_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(__0)
  def __flush_1initsol_Emosek_4fusion_4SolutionType_2(self,_0):
   if (self.__initsol_xx is not None):
    try:
     _1=self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True)
     if ((_1.xx) is not None):
      for _2 in range(0,int((self.__initsol_xx).shape[0])):
       if (not self.__initsol_xx_flag[_2]):
        self.__initsol_xx[_2] = (_1.xx)[_2]
     else:
      fragments._c_closure_3(self.__initsol_xx,self.__initsol_xx_flag) # src/fusion/Model.mbi:2900:13-2904:14
    except mosek_fusion_SolutionError as _3:
     fragments._c_closure_4(self.__initsol_xx,self.__initsol_xx_flag) # src/fusion/Model.mbi:2907:11-2911:12
    self._task_1putxx_1slice_Emosek_4fusion_4SolutionType_2II_3D(_0,0,int((self.__initsol_xx).shape[0]),self.__initsol_xx)
  @staticmethod
  def _match_getDualSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDualSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getDualSolutionStatus_alt_(self,):
    return self._getDualSolutionStatus_()
  def _getDualSolutionStatus_(self,):
   _0=None
   if (self.__solutionptr==mosek.fusion.SolutionType.Default):
    if (self._sol_itg is not None):
     _0 = self._sol_itg
    elif (self._sol_bas is not None):
     _0 = self._sol_bas
    else:
     _0 = self._sol_itr
   elif (self.__solutionptr==mosek.fusion.SolutionType.Interior):
    _0 = self._sol_itr
   elif (self.__solutionptr==mosek.fusion.SolutionType.Basic):
    _0 = self._sol_bas
   elif (self.__solutionptr==mosek.fusion.SolutionType.Integer):
    _0 = self._sol_itg
   if (_0 is None):
    return (mosek.fusion.SolutionStatus.Undefined)
   elif (not self._synched):
    return (mosek.fusion.SolutionStatus.Unknown)
   else:
    return ((_0.dstatus))
  @staticmethod
  def _match_getPrimalSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getPrimalSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getPrimalSolutionStatus_alt_(self,):
    return self._getPrimalSolutionStatus_()
  def _getPrimalSolutionStatus_(self,):
   _0=None
   if (self.__solutionptr==mosek.fusion.SolutionType.Default):
    if (self._sol_itg is not None):
     _0 = self._sol_itg
    elif (self._sol_bas is not None):
     _0 = self._sol_bas
    else:
     _0 = self._sol_itr
   elif (self.__solutionptr==mosek.fusion.SolutionType.Basic):
    _0 = self._sol_bas
   elif (self.__solutionptr==mosek.fusion.SolutionType.Integer):
    _0 = self._sol_itg
   else:
    _0 = self._sol_itr
   if (_0 is None):
    return (mosek.fusion.SolutionStatus.Undefined)
   elif (not self._synched):
    return (mosek.fusion.SolutionStatus.Unknown)
   else:
    return ((_0.pstatus))
  @staticmethod
  def _match_dualObjValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dualObjValue_(*args):
    if len(args) != 0: return False
    return True
  def _dualObjValue_alt_(self,):
    return self._dualObjValue_()
  def _dualObjValue_(self,):
   return numpy.float64((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(mosek.fusion.SolutionType.Default,False).dobj))
  @staticmethod
  def _match_primalObjValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_primalObjValue_(*args):
    if len(args) != 0: return False
    return True
  def _primalObjValue_alt_(self,):
    return self._primalObjValue_()
  def _primalObjValue_(self,):
   return numpy.float64((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(mosek.fusion.SolutionType.Default,True).pobj))
  def _get_1sol_1cache_alt_Emosek_4fusion_4SolutionType_2ZZ(self,_t__0,_t__1,_t__2):
    return self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(__0,_1,_2)
  def _get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(self,_0,_1,_2):
   _3=None
   _4=_0
   if (_4==mosek.fusion.SolutionType.Default):
    _4 = self.__solutionptr
   if (_4==mosek.fusion.SolutionType.Default):
    if (self._sol_itg is not None):
     _3 = self._sol_itg
    elif (self._sol_bas is not None):
     _3 = self._sol_bas
    else:
     _3 = self._sol_itr
   elif (_4==mosek.fusion.SolutionType.Interior):
    _3 = self._sol_itr
   elif (_4==mosek.fusion.SolutionType.Basic):
    _3 = self._sol_bas
   elif (_4==mosek.fusion.SolutionType.Integer):
    _3 = self._sol_itg
   if (_3 is None):
    raise mosek_fusion_SolutionError._ctor_S("Solution not available")
   else:
    if (_2 or ((_1 and _3._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self.__acceptable_sol)) or ((not _1) and _3._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self.__acceptable_sol)))):
     return (_3)
    else:
     _5=mosek.fusion.Utils.StringBuffer()
     _6=(_3.pstatus)
     if (not _1):
      _6 = (_3.dstatus)
     _5._a_S("Solution status is ")
     if (_6==mosek.fusion.SolutionStatus.Undefined):
      _5._a_S("Undefined")
     elif (_6==mosek.fusion.SolutionStatus.Unknown):
      _5._a_S("Unknown")
     elif (_6==mosek.fusion.SolutionStatus.Optimal):
      _5._a_S("Optimal")
     elif (_6==mosek.fusion.SolutionStatus.NearOptimal):
      _5._a_S("NearOptimal")
     elif (_6==mosek.fusion.SolutionStatus.Feasible):
      _5._a_S("Feasible")
     elif (_6==mosek.fusion.SolutionStatus.NearFeasible):
      _5._a_S("NearFeasible")
     elif (_6==mosek.fusion.SolutionStatus.Certificate):
      _5._a_S("Certificate")
     elif (_6==mosek.fusion.SolutionStatus.NearCertificate):
      _5._a_S("NearCertificate")
     elif (_6==mosek.fusion.SolutionStatus.IllposedCert):
      _5._a_S("IllposedCert")
     _5._a_S(" but at least ")
     if (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Anything):
      _5._a_S("Anything")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Optimal):
      _5._a_S("Optimal")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.NearOptimal):
      _5._a_S("NearOptimal")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Feasible):
      _5._a_S("Feasible")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Certificate):
      _5._a_S("Certificate")
     _5._a_S(" is expected")
     raise mosek_fusion_SolutionError._ctor_S(_5._toString_())
  def _get_1sol_1cache_alt_Emosek_4fusion_4SolutionType_2Z(self,_t__0,_t__1):
    return self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(__0,_1)
  def _get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(self,_0,_1):
   return (self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_0,_1,False))
  def _setSolution_1xx_alt__3I_3D(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._setSolution_1xx__3I_3D(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setSolution_1xx__3I_3D(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self._ensure_1initsol_1xx_()
   fragments._c_closure_5(self.__initsol_xx,self.__initsol_xx_flag,_0,_1) # src/fusion/Model.mbi:2744:9-2748:10
  def _ensure_1initsol_1xx_alt_(self,):
    return self._ensure_1initsol_1xx_()
  def _ensure_1initsol_1xx_(self,):
   if (self.__initsol_xx is None):
    self.__initsol_xx = numpy.zeros((self.__natvarmap_num,), dtype=numpy.dtype(numpy.float64))
    self.__initsol_xx_flag = numpy.array([False for _0 in range(0,self.__natvarmap_num)], dtype=numpy.dtype(numpy.bool))
   elif (int((self.__initsol_xx).shape[0]) < self.__natvarmap_num):
    _1=self.__initsol_xx
    _2=self.__initsol_xx_flag
    self.__initsol_xx = numpy.zeros((self.__natvarmap_num,), dtype=numpy.dtype(numpy.float64))
    self.__initsol_xx_flag = numpy.zeros((self.__natvarmap_num,), dtype=numpy.dtype(numpy.bool))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_1,0,self.__initsol_xx,0,int((_1).shape[0]))
    fragments._c_closure_6(self.__initsol_xx_flag,_1,_2) # src/fusion/Model.mbi:2737:11-70
  def _getSolution_1bars_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1bars_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1bars_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).bars))
  def _getSolution_1barx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1barx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1barx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).barx))
  def _getSolution_1y_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1y_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1y_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).y))
  def _getSolution_1xc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1xc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1xc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).xc))
  def _getSolution_1snx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1snx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1snx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).snx))
  def _getSolution_1suc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1suc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1suc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).suc))
  def _getSolution_1slc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1slc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1slc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).slc))
  def _getSolution_1sux_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1sux_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1sux_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).sux))
  def _getSolution_1slx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1slx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1slx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).slx))
  def _getSolution_1xx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1xx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1xx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).xx))
  @staticmethod
  def _match_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _selectedSolution_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._selectedSolution_Emosek_4fusion_4SolutionType_2(__0)
  def _selectedSolution_Emosek_4fusion_4SolutionType_2(self,_0):
   self.__solutionptr = _0
  @staticmethod
  def _match_getAcceptedSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getAcceptedSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getAcceptedSolutionStatus_alt_(self,):
    return self._getAcceptedSolutionStatus_()
  def _getAcceptedSolutionStatus_(self,):
   return (self.__acceptable_sol)
  @staticmethod
  def _match_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _acceptedSolutionStatus_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   self.__acceptable_sol = _0
  @staticmethod
  def _match_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getProblemStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getProblemStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getProblemStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   _1=None
   if (_0==mosek.fusion.SolutionType.Default):
    if (self._sol_itg is not None):
     _1 = self._sol_itg
    elif (self._sol_bas is not None):
     _1 = self._sol_bas
    else:
     _1 = self._sol_itr
   elif (_0==mosek.fusion.SolutionType.Interior):
    _1 = self._sol_itr
   elif (_0==mosek.fusion.SolutionType.Basic):
    _1 = self._sol_bas
   elif (_0==mosek.fusion.SolutionType.Integer):
    _1 = self._sol_itg
   if (_1 is None):
    return (mosek.fusion.ProblemStatus.Unknown)
   else:
    return ((_1.probstatus))
  @staticmethod
  def _match_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getDualSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   return (self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(_0,False))
  @staticmethod
  def _match_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getPrimalSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   return (self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(_0,True))
  def _getSolutionStatus_alt_Emosek_4fusion_4SolutionType_2Z(self,_t__0,_t__1):
    return self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(__0,_1)
  def _getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(self,_0,_1):
   try:
    _2=self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_0,_1,True)
    if _1:
     return ((_2.pstatus))
    else:
     return ((_2.dstatus))
   except mosek_fusion_SolutionError as _3:
    return (mosek.fusion.SolutionStatus.Undefined)
  def __objective_1_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1,_t__2):
    return self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,__1,_2)
  def __objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1,_2):
   self._task_1putobjectivename_S(_0)
   if ((_2._getShape_()._size)!=1):
    raise mosek_fusion_LengthError._ctor_S("Objective expression must be of size 1.")
   if ((_1!=mosek.fusion.ObjectiveSense.Minimize) and (_1!=mosek.fusion.ObjectiveSense.Maximize)):
    raise mosek_fusion_LengthError._ctor_S("Objective sense required.")
   _3=_2._eval_()
   for _4 in range(0,int(((_3.x)).shape[0])):
    if (((_3.x)[_4]._getModel_() is not None) and ((_3.x)[_4]._getModel_() is not self)):
     raise mosek_fusion_ModelError._ctor_S("Expression belong to different models")
   _5=None
   _6=None
   _7=0
   _8=0
   _9=None
   _10=None
   _11=None
   _12=int(((_3.subj)).shape[0])
   _9 = numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
   _10 = numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
   _11 = numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Model.__inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I((_3.x),(_3.subj),_9,_10,_11)
   _8 = 0
   _8 = fragments._c_closure_7(_12,_8,_9) # src/fusion/Model.mbi:2439:11-2440:56
   _8 = numpy.int32(_8) # postprocess
   _7 = (_12 - _8)
   if (_8 > 0):
    _5 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
   if (_7==0):
    _5 = _9
    _6 = (_3.cof)
   else:
    _13=0
    _6 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
    _5 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
    _14=(_3.ptrb)[0]
    while (_14 < (_3.ptrb)[1]):
     if (_9[_14] >= 0):
      _5[_13] = _9[_14]
      _6[_13] = (_3.cof)[_14]
      _13 += 1
     _14 += 1
   _15=0.0
   if ((_3.bfix) is not None):
    _15 = (_3.bfix)[0]
   self._task_1putobjective_Z_3I_3DD((_1==mosek.fusion.ObjectiveSense.Maximize),_5,_6,_15)
   if (_7 > 0):
    _16=0
    _17=(_3.ptrb)[0]
    while (_17 < (_3.ptrb)[1]):
     if (_9[_17] < 0):
      _16 += 1
     _17 += 1
    if (_16 > 0):
     _18=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int64))
     _19=(_3.ptrb)
     fragments._c_closure_8(_18,_19,_9) # src/fusion/Model.mbi:2491:13-2501:14
     mosek.fusion.Sort._argsort__3J_3IJJ(_18,_9,0,_16)
     _20=0
     while (_20 < _16):
      _21=_20
      _20 += 1
      _20 = fragments._c_closure_9(_18,_20,_16,_9) # src/fusion/Model.mbi:2511:17-124
      _20 = numpy.int32(_20) # postprocess
      _22=(_20 - _21)
      mosek.fusion.Sort._argsort__3J_3I_3IJJ(_18,_10,_11,numpy.int64(_21),numpy.int64(_20))
      _23=1
      _23 = fragments._c_closure_10(_18,_21,_20,_23,_10,_11) # src/fusion/Model.mbi:2524:17-2531:18
      _23 = numpy.int32(_23) # postprocess
      _24=0
      _25=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int32))
      _26=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int32))
      _27=numpy.zeros((_23,), dtype=numpy.dtype(numpy.float64))
      _25[0] = _10[_18[_21]]
      _26[0] = _11[_18[_21]]
      if (_25[0]==_26[0]):
       _27[0] = (_3.cof)[_18[_21]]
      else:
       _27[0] = (0.5 * (_3.cof)[_18[_21]])
      for _28 in range((_21 + 1),_20):
       _29=_18[_28]
       _30=_18[(_28 - 1)]
       if ((_10[_29]!=_10[_30]) or (_11[_29]!=_11[_30])):
        _24 += 1
        _25[_24] = _10[_29]
        _26[_24] = _11[_29]
       if (_25[_24]==_26[_24]):
        _27[_24] = (_27[_24] + (_3.cof)[_29])
       else:
        _27[_24] = (_27[_24] + (0.5 * (_3.cof)[_29]))
      _31=(- (_9[_18[_21]] + 1))
      _32=self._task_1barvardim_I(_31)
      _33=self._task_1append_1barmatrix_I_3I_3I_3D(_32,_25,_26,_27)
      self._task_1putbarcj_II(_31,_33)
  @staticmethod
  def _match_objective_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_objective_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _objective_alt_D(self,_t__0):
    return self._objective_D(numpy.float64(__0))
  def _objective_D(self,_0):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",mosek.fusion.ObjectiveSense.Minimize,mosek.fusion.Expr._constTerm_D(_0))
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_alt_match_D__(_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2D(self,_t__0,_t__1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2D(__0,numpy.float64(__1))
  def _objective_Emosek_4fusion_4ObjectiveSense_2D(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_0,mosek.fusion.Expr._constTerm_D(_1))
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(self,_t__0,_t__1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(__0,_1)
  def _objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_0,_1._asExpr_())
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(__0,_1)
  def _objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_0,_1)
  @staticmethod
  def _match_objective_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_objective_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_D__(_1))
  def _objective_alt_SD(self,_t__0,_t__1):
    return self._objective_SD(_0,numpy.float64(__1))
  def _objective_SD(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,mosek.fusion.ObjectiveSense.Minimize,mosek.fusion.Expr._constTerm_D(_1))
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_alt_match_D__(_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2D(self,_t__0,_t__1,_t__2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2D(_0,__1,numpy.float64(__2))
  def _objective_SEmosek_4fusion_4ObjectiveSense_2D(self,_0,_1,_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,_1,mosek.fusion.Expr._constTerm_D(_2))
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(self,_t__0,_t__1,_t__2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(_0,__1,_2)
  def _objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Variable_2(self,_0,_1,_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,_1,_2._asExpr_())
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1,_t__2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,__1,_2)
  def _objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1,_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2("",None,_0._asExpr_(),_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,None,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  def _constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2)
  def _constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2("",_0,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_3))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_3))
  def _constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2,_3)
  def _constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2,_3):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2._asExpr_(),_3))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2("",None,_0._asExpr_(),_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,None,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def _constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2("",_0,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_3))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_3))
  def _constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2,_3)
  def _constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2,_3):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2._asExpr_(),_3))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2("",None,_0._asExpr_(),_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,None,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def _constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2("",_0,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_3))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_3))
  def _constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2,_3)
  def _constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2,_3):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2._asExpr_(),_3))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2("",_0._asExpr_(),_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2("",_0._asExpr_(),_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Variable_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1._asExpr_(),_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2("",None,_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,None,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  def _constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2)
  def _constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2("",_0,_1,_2))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_3))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_3))
  def _constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2,_3)
  def _constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2,_3):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2,_3))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2("",None,_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,None,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def _constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2("",_0,_1,_2))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_3))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_3))
  def _constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2,_3)
  def _constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2,_3):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2,_3))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2("",None,_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,None,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _constraint_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def _constraint_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2("",_0,_1,_2))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_3))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_3))
  def _constraint_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2,_3)
  def _constraint_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2,_3):
   return (self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2,_3))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4LinPSDDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4LinPSDDomain_2(_0)
  def _variable_Lmosek_4fusion_4LinPSDDomain_2(self,_0):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2("",None,_0))
  @staticmethod
  def _match_variable_IILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_IILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_IILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_IILmosek_4fusion_4LinPSDDomain_2(numpy.int32(__0),numpy.int32(__1),_2)
  def _variable_IILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2("",mosek.fusion.Set._make_III(_0,_0,_1),_2))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4LinPSDDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2("",mosek.fusion.Set._make_II(_0,_0),_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4LinPSDDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_3))
  @staticmethod
  def _match_alt_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_3))
  def _variable_alt_SIILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._variable_SIILmosek_4fusion_4LinPSDDomain_2(_0,numpy.int32(__1),numpy.int32(__2),_3)
  def _variable_SIILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2,_3):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,mosek.fusion.Set._make_III(_1,_1,_2),_3))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4LinPSDDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,mosek.fusion.Set._make_II(_1,_1),_2))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def _variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,mosek.fusion.Set._make__3I(_1),_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4PSDDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4PSDDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4PSDDomain_2(_0)
  def _variable_Lmosek_4fusion_4PSDDomain_2(self,_0):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2("",None,_0))
  @staticmethod
  def _match_variable_IILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_IILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_IILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_IILmosek_4fusion_4PSDDomain_2(numpy.int32(__0),numpy.int32(__1),_2)
  def _variable_IILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2("",mosek.fusion.Set._make_III(_0,_0,_1),_2))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4PSDDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2("",mosek.fusion.Set._make_II(_0,_0),_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4PSDDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_3))
  @staticmethod
  def _match_alt_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_3))
  def _variable_alt_SIILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._variable_SIILmosek_4fusion_4PSDDomain_2(_0,numpy.int32(__1),numpy.int32(__2),_3)
  def _variable_SIILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2,_3):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,mosek.fusion.Set._make_III(_1,_1,_2),_3))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4PSDDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,mosek.fusion.Set._make_II(_1,_1),_2))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def _variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4PSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,mosek.fusion.Set._make__3I(_1),_2))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4SymmetricLinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4SymmetricLinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4SymmetricLinearDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4SymmetricLinearDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4SymmetricLinearDomain_2(self,_0,_1):
   return (self.__variable_1_SILmosek_4fusion_4SymmetricLinearDomain_2("",_0,_1))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4SymmetricLinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4SymmetricLinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4SymmetricLinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4SymmetricLinearDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4SymmetricLinearDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SILmosek_4fusion_4SymmetricLinearDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4QConeDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4QConeDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4QConeDomain_2(_0)
  def _variable_Lmosek_4fusion_4QConeDomain_2(self,_0):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2("",None,_0))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4RangeDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4RangeDomain_2(_0)
  def _variable_Lmosek_4fusion_4RangeDomain_2(self,_0):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2("",None,_0))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4LinearDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4LinearDomain_2(_0)
  def _variable_Lmosek_4fusion_4LinearDomain_2(self,_0):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",None,_0))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt__3ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._variable__3ILmosek_4fusion_4RangeDomain_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3ILmosek_4fusion_4RangeDomain_2(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2("",mosek.fusion.Set._make__3I(_0),_1))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt__3ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._variable__3ILmosek_4fusion_4LinearDomain_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3ILmosek_4fusion_4LinearDomain_2(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",mosek.fusion.Set._make__3I(_0),_1))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  def _variable_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1):
    return self._variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(_0,_1)
  def _variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2("",_0,_1))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,_1)
  def _variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2("",_0,_1))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,_1)
  def _variable_Lmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",_0,_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4QConeDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4QConeDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2("",mosek.fusion.Set._make_I(_0),_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4RangeDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2("",mosek.fusion.Set._make_I(_0),_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4LinearDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",mosek.fusion.Set._make_I(_0),_1))
  @staticmethod
  def _match_variable__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_variable__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _variable_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._variable__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",mosek.fusion.Set._make__3I(_0),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_variable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _variable_alt_I(self,_t__0):
    return self._variable_I(numpy.int32(__0))
  def _variable_I(self,_0):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",mosek.fusion.Set._make_I(_0),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_variable_(*args):
    if len(args) != 0: return False
    return True
  def _variable_alt_(self,):
    return self._variable_()
  def _variable_(self,):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2("",mosek.fusion.Set._make_I(1),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4QConeDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4QConeDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4RangeDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4LinearDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,mosek.fusion.Set._make__3I(_1),_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,mosek.fusion.Set._make__3I(_1),_2))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  def _variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2)
  def _variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def _variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def _variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4QConeDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(_0,mosek.fusion.Set._make_I(_1),_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4RangeDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,mosek.fusion.Set._make_I(_1),_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4LinearDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,mosek.fusion.Set._make_I(_1),_2))
  @staticmethod
  def _match_variable_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_variable_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1))
  def _variable_alt_S_3I(self,_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._variable_S_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3I(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,mosek.fusion.Set._make__3I(_1),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_variable_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1))
  def _variable_alt_SI(self,_t__0,_t__1):
    return self._variable_SI(_0,numpy.int32(__1))
  def _variable_SI(self,_0,_1):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,mosek.fusion.Set._make_I(_1),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_variable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _variable_alt_S(self,_t__0):
    return self._variable_S(_0)
  def _variable_S(self,_0):
   return (self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,mosek.fusion.Set._make_I(1),mosek.fusion.Domain._unbounded_()))
  def __ranged_1variable_alt_SILmosek_4fusion_4SymmetricRangeDomain_2(self,_t__0,_t__1,_t__2):
    return self.__ranged_1variable_SILmosek_4fusion_4SymmetricRangeDomain_2(_0,numpy.int32(__1),_2)
  def __ranged_1variable_SILmosek_4fusion_4SymmetricRangeDomain_2(self,_0,_1,_2):
   _3=None
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _4=_1
   if (_4 > 0):
    if (((_2._dim) > 0) and ((_2._dim)!=_4)):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   else:
    _4 = ((_2._dim) if (((_2._dim) > 0) ) else 1)
   _5=self.__task_vars_used
   _6=self._task_1numcon_()
   _7=self._task_1numcone_()
   _8=self._task_1numbarvar_()
   try:
    _9=None
    _10=((_4 * (_4 + 1)) // 2)
    _11=0
    if (_2._sparse_flag):
     _11 = self.__task_1alloc_1vars_I(_10)
     self.__natvarmap_1ensure_I(_10)
     self.__natvarmap_num = (self.__natvarmap_num + _10)
     _12=numpy.array([_2._get_1lb_1item_J((((_13 * (_13 + 1)) // 2) + _14)) for _13 in range(0,_4) for _14 in range(0,_13)], dtype=numpy.dtype(numpy.float64))
     _15=numpy.array([_2._get_1ub_1item_J((((_16 * (_16 + 1)) // 2) + _17)) for _16 in range(0,_4) for _17 in range(0,_16)], dtype=numpy.dtype(numpy.float64))
     self._task_1var_1putboundslice_1ra_II_3D_3D(_11,(_11 + _10),_12,_15)
     _9 = numpy.zeros((_10,), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_11(_11,_9,_10) # src/fusion/Model.mbi:2271:13-64
     fragments._c_closure_12(_11,self.__natvarmap_idx,_10) # src/fusion/Model.mbi:2272:13-71
     fragments._c_closure_13(_11,self.__natvarmap_Var,_10,self._vars_used) # src/fusion/Model.mbi:2273:13-72
    _3 = mosek_fusion_SymRangedVariable._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(self,_0,_2,_4,_9,self._numVariables_())
    if (_2._cardinal_flag):
     _3._makeInteger_()
   finally:
    if (_3 is None):
     self._task_1cleanup_IIII(_5,_6,_7,_8)
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_3)
   return (_3)
  def __ranged_1variable_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self.__ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def __ranged_1variable_SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   _3=None
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   if (_1 is not None):
    if (not _2._match_1shape_Lmosek_4fusion_4Set_2(_1)):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
    _4 = _1
   else:
    _4 = (_2._shape)
    if (_4 is None):
     _4 = mosek_fusion_IntSet._ctor_I(1)
   _5=self.__task_vars_used
   _6=self._task_1numcon_()
   _7=self._task_1numcone_()
   _8=self._task_1numbarvar_()
   try:
    _9=None
    _10=numpy.int32((_4._size))
    _11=0
    if (not (_2._sparse_flag)):
     _11 = self.__task_1alloc_1vars_I(_10)
     self.__natvarmap_1ensure_I(_10)
     self.__natvarmap_num = (self.__natvarmap_num + _10)
     _12=numpy.array([_2._get_1lb_1item_J(_13) for _13 in range(0,_10)], dtype=numpy.dtype(numpy.float64))
     _14=numpy.array([_2._get_1ub_1item_J(_15) for _15 in range(0,_10)], dtype=numpy.dtype(numpy.float64))
     self._task_1var_1putboundslice_1ra_II_3D_3D(_11,(_11 + _10),_12,_14)
     _9 = numpy.zeros((_10,), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_14(_11,_9,_10) # src/fusion/Model.mbi:2198:13-64
     fragments._c_closure_15(_11,self.__natvarmap_idx,_10) # src/fusion/Model.mbi:2199:13-71
     fragments._c_closure_16(_11,self.__natvarmap_Var,_10,self._vars_used) # src/fusion/Model.mbi:2200:13-72
    _3 = mosek_fusion_RangedVariable._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(self,_0,_4,_2,_9,self._numVariables_())
    if (_2._cardinal_flag):
     _3._makeInteger_()
   finally:
    if (_3 is None):
     self._task_1cleanup_IIII(_5,_6,_7,_8)
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_3)
   return (_3)
  def __variable_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2):
    return self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2)
  def __variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2):
   _3=None
   _4=None
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _5=(_1 if ((_1 is not None) ) else ((_2._shape) if (((_2._shape) is not None) ) else mosek_fusion_IntSet._ctor_I(1)))
   if ((not _2._match_1shape_Lmosek_4fusion_4Set_2(_5)) or (_2._getAxis_() >= (_5.nd))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   _6=(_2._getAxis_() if (((_2._shape) is not None) ) else ((_5.nd) - 1))
   _7=_5._dim_I(_6)
   _8=1
   for _9 in range(0,(_5.nd)):
    if (_6!=_9):
     _8 *= _5._dim_I(_9)
   _10=1
   for _11 in range(0,_6):
    _10 *= _5._dim_I(_11)
   _12=1
   for _13 in range((_6 + 1),(_5.nd)):
    _12 *= _5._dim_I(_13)
   if ((((_2._key)==mosek.fusion.QConeKey.InQCone) and (_7 < 2)) or (((_2._key)==mosek.fusion.QConeKey.InRotatedQCone) and (_7 < 3))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for cone")
   _14=self.__task_vars_used
   _15=self._task_1numcon_()
   _16=self._task_1numcone_()
   _17=self._task_1numbarvar_()
   try:
    _18=numpy.int32((_5._size))
    _19=self.__task_1alloc_1vars_I(_18)
    self.__natvarmap_1ensure_I(_18)
    self.__natvarmap_num = (self.__natvarmap_num + _18)
    _20=(_19 + _18)
    fragments._c_closure_17(_19,_20,self.__natvarmap_idx) # src/fusion/Model.mbi:2099:11-73
    self._task_1var_1putboundslice_1fr_II(_19,_20)
    if (_2._int_flag):
     self._task_1var_1putintlist__3I(mosek.fusion.Utils.Tools._range_II(_19,_20))
    _22=numpy.array([(_23 + _19) for _23 in range(0,(_8 * _7))], dtype=numpy.dtype(numpy.int32))
    if ((_2._key)==mosek.fusion.QConeKey.InQCone):
     _21 = self._task_1append_1quadcone_IIIII(_7,_19,_8,_10,_12)
    else:
     _21 = self._task_1append_1rquadcone_IIIII(_7,_19,_8,_10,_12)
    _4 = mosek_fusion_ConicVariable._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(self,_0,_2,_5,_22,_7,_21,_8,self._numVariables_())
    if (_2._int_flag):
     pass
    fragments._c_closure_18(_19,self.__natvarmap_Var,_18,self._vars_used) # src/fusion/Model.mbi:2131:11-68
    _3 = _4
   finally:
    if (_3 is None):
     self.__natvarmap_num = _14
     self._natbarvarmap_num = _17
     self._task_1cleanup_IIII(_14,_15,_16,_17)
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_3)
   return (_3)
  def __variable_1_alt_SILmosek_4fusion_4SymmetricLinearDomain_2(self,_t__0,_t__1,_t__2):
    return self.__variable_1_SILmosek_4fusion_4SymmetricLinearDomain_2(_0,numpy.int32(__1),_2)
  def __variable_1_SILmosek_4fusion_4SymmetricLinearDomain_2(self,_0,_1,_2):
   _3=None
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _4=_1
   if (_4 > 0):
    if (((_2._dim) > 0) and ((_2._dim)!=_4)):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   else:
    _4 = ((_2._dim) if (((_2._dim) > 0) ) else 1)
   _5=self.__task_vars_used
   _6=self._task_1numcon_()
   _7=self._task_1numcone_()
   _8=self._task_1numbarvar_()
   try:
    _9=None
    _10=(_2._key)
    _11=((_4 * (_4 + 1)) // 2)
    _12=0
    if (not (_2._sparse_flag)):
     _12 = self.__task_1alloc_1vars_I(_11)
     self.__natvarmap_1ensure_I(_11)
     self.__natvarmap_num = (self.__natvarmap_num + _11)
     if (_10==mosek.fusion.RelationKey.IsFree):
      self._task_1var_1putboundslice_1fr_II(_12,(_12 + _11))
     else:
      _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
      _14=0
      for _15 in range(0,_4):
       for _16 in range(0,_15):
        _13[_14] = _2._get_1rhs_1item_J(((_15 * _4) + _16))
        _14 += 1
      if (_10==mosek.fusion.RelationKey.LessThan):
       self._task_1var_1putboundslice_1up_II_3D(_12,(_12 + _11),_13)
      elif (_10==mosek.fusion.RelationKey.GreaterThan):
       self._task_1var_1putboundslice_1lo_II_3D(_12,(_12 + _11),_13)
      elif (_10==mosek.fusion.RelationKey.EqualsTo):
       self._task_1var_1putboundslice_1fx_II_3D(_12,(_12 + _11),_13)
     _9 = numpy.array([(_12 + _17) for _17 in range(0,_11)], dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_19(_12,self.__natvarmap_idx,_11) # src/fusion/Model.mbi:2026:13-71
    _3 = mosek_fusion_SymLinearVariable._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(self,_0,_2,_4,_9,self._numVariables_())
    if (_2._cardinal_flag):
     _3._makeInteger_()
    if (not (_2._sparse_flag)):
     fragments._c_closure_20(_12,self.__natvarmap_Var,_11,self._vars_used) # src/fusion/Model.mbi:2035:13-72
   finally:
    if (_3 is None):
     self._task_1cleanup_IIII(_5,_6,_7,_8)
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_3)
   return (_3)
  def __variable_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def __variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   _3=None
   _4=None
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   if (_1 is not None):
    if (not _2._match_1shape_Lmosek_4fusion_4Set_2(_1)):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
    _5 = _1
   else:
    _5 = (_2._shape)
    if (_5 is None):
     _5 = mosek_fusion_IntSet._ctor_I(1)
   _6=self.__task_vars_used
   _7=self._task_1numcon_()
   _8=self._task_1numcone_()
   _9=self._task_1numbarvar_()
   try:
    _10=None
    _11=(_2._key)
    _12=numpy.int32((_5._size))
    _13=0
    if (not (_2._sparse_flag)):
     _13 = self.__task_1alloc_1vars_I(_12)
     self.__natvarmap_1ensure_I(_12)
     self.__natvarmap_num = (self.__natvarmap_num + _12)
     if (_11==mosek.fusion.RelationKey.IsFree):
      self._task_1var_1putboundslice_1fr_II(_13,(_13 + _12))
     else:
      _14=numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64))
      for _15 in range(0,_12):
       _14[_15] = _2._get_1rhs_1item_J(numpy.int64(_15))
      if (_11==mosek.fusion.RelationKey.LessThan):
       self._task_1var_1putboundslice_1up_II_3D(_13,(_13 + _12),_14)
      elif (_11==mosek.fusion.RelationKey.GreaterThan):
       self._task_1var_1putboundslice_1lo_II_3D(_13,(_13 + _12),_14)
      elif (_11==mosek.fusion.RelationKey.EqualsTo):
       self._task_1var_1putboundslice_1fx_II_3D(_13,(_13 + _12),_14)
     _10 = numpy.array([(_13 + _16) for _16 in range(0,_12)], dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_21(_13,self.__natvarmap_idx,_12) # src/fusion/Model.mbi:1940:13-71
    _4 = mosek_fusion_LinearVariable._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(self,_0,_2,_5,_10,self._numVariables_())
    if (_2._cardinal_flag):
     pass
    _3 = _4
    if (_2._cardinal_flag):
     _4._makeInteger_()
    if (not (_2._sparse_flag)):
     fragments._c_closure_22(_13,self.__natvarmap_Var,_12,self._vars_used) # src/fusion/Model.mbi:1952:13-72
   finally:
    if (_3 is None):
     self._task_1cleanup_IIII(_6,_7,_8,_9)
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_3)
   return (_3)
  def __variable_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def __variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   _3=None
   if (_1 is None):
    if ((_2._shape) is None):
     raise mosek_fusion_DimensionError._ctor_S("Missing shape for variable")
    else:
     _3 = (_2._shape)
   elif ((_2._shape) is None):
    _3 = _1
   else:
    if (((_1.nd)!=((_2._shape).nd)) or ((_1._dim_I(0)!=(_2._shape)._dim_I(0)) or (_1._dim_I(1)!=(_2._shape)._dim_I(1)))):
     raise mosek_fusion_DimensionError._ctor_S("Ambiguous dimensions for variable")
    else:
     _3 = _1
   _4=_3._dim_I(0)
   _5=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _4))) - 1) / 2))
   if (((_5 * (_5 + 1)) // 2)!=_4):
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for semidefinite variable")
   _6=1
   for _7 in range(1,(_3.nd)):
    _6 *= _3._dim_I(_7)
   _8=self._task_1append_1barvar_II(_5,_6)
   _9=mosek_fusion_LinearPSDVariable._ctor_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(self,_0,_5,_3,_8,self._numVariables_())
   self.__natbarvarmap_1ensure_I(1)
   self._natbarvarmap_Var[self._natbarvarmap_num] = self._vars_used
   self._natbarvarmap_num += 1
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_9)
   return (_9)
  def __variable_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def __variable_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   if (_1 is not None):
    if (((_1.nd)!=2) and ((_1.nd)!=3)):
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape for semidefinite variables")
    elif (((_1.nd)==2) and (_1._dim_I(0)!=_1._dim_I(1))):
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape for semidefinite variables")
    elif (((_1.nd)==3) and (_1._dim_I(1)!=_1._dim_I(2))):
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape for semidefinite variables")
    _3 = _1._dim_I(1)
    _4 = (1 if (((_1.nd)==2) ) else _1._dim_I(0))
    if ((_2._shape) is not None):
     if ((((_2._shape).nd)!=(_1.nd)) or ((((_1.nd)==2) and (((_2._shape)._dim_I(0)!=_3) or ((_2._shape)._dim_I(1)!=_3))) or (((_1.nd)==3) and (((_2._shape)._dim_I(0)!=_4) or (((_2._shape)._dim_I(1)!=_3) or ((_2._shape)._dim_I(2)!=_3)))))):
      raise mosek_fusion_DomainError._ctor_S("Domain and shape do not match")
   else:
    if ((_2._shape) is None):
     raise mosek_fusion_DomainError._ctor_S("Either domain size of shape must be defined")
    elif ((((_2._shape).nd)!=2) and (((_2._shape).nd)!=3)):
     raise mosek_fusion_DomainError._ctor_S("Invalid domain shape")
    else:
     _3 = (_2._shape)._dim_I(1)
     _4 = (1 if ((((_2._shape).nd)==2) ) else (_2._shape)._dim_I(0))
   _5=self._task_1append_1barvar_II(_3,_4)
   _6=mosek_fusion_PSDVariable._ctor_Lmosek_4fusion_4Model_2SIIIJ(self,_0,_3,_5,_4,self._numVariables_())
   self.__natbarvarmap_1ensure_I(1)
   self._natbarvarmap_Var[self._natbarvarmap_num] = self._vars_used
   self._natbarvarmap_num += 1
   self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_6)
   return (_6)
  def __constraint_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2,_3)
  def __constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2,_3):
   _4=None
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   _5 = (_1 if ((_1 is not None) ) else _2._getShape_())
   if (not _3._match_1shape_Lmosek_4fusion_4Set_2(_5)):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   _6=_2._eval_()
   for _7 in range(0,int(((_6.x)).shape[0])):
    if (((_6.x)[_7]._getModel_() is not None) and ((_6.x)[_7]._getModel_() is not self)):
     raise mosek_fusion_ModelError._ctor_S("Expression belong to different models")
   _8=self.__build_1conA__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2((_6.ptrb),(_5._size),(_6.inst),(_6.subj),(_6.cof),(_6.bfix),(_6.x))
   _9=(int(((_8.ptrb)).shape[0]) - 1)
   _10=self.__task_vars_used
   _11=self._task_1numcone_()
   _12=self._task_1numcon_()
   _13=self._task_1numbarvar_()
   try:
    _14=_9
    _15=self._task_1append_1con_I(_14)
    _16=(_15 + _14)
    if (int(len(_0)) > 0):
     _17=mosek.fusion.Utils.StringBuffer()
     _18=0
     while (_18 < _14):
      _17._clear_()._a_S(_0)._a_S("[")._a_I(_18)._a_S("]")
      self._task_1con_1name_IS((_18 + _15),_17._toString_())
      _18 += 1
    if (((_8.subj) is not None) and (int(((_8.subj)).shape[0]) > 0)):
     self._task_1putarowslice_II_3J_3I_3D(_15,_16,(_8.ptrb),(_8.subj),(_8.cof))
    if ((_8.barsubi) is not None):
     for _19 in range(0,int(((_8.barsubi)).shape[0])):
      self._task_1putbaraij_III(((_8.barsubi)[_19] + _15),(_8.barsubj)[_19],(_8.barmidx)[_19])
    _20=numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64))
    _21=numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64))
    if ((_8.bfix) is not None):
     for _22 in range(0,_9):
      _20[_22] = (_3._get_1lb_1item_J(numpy.int64(_22)) - (_8.bfix)[_22])
      _21[_22] = (_3._get_1ub_1item_J(numpy.int64(_22)) - (_8.bfix)[_22])
    else:
     _23=(int(((_8.ptrb)).shape[0]) - 1)
     for _24 in range(0,_9):
      _20[_24] = _3._get_1lb_1item_J(numpy.int64(_24))
      _21[_24] = _3._get_1ub_1item_J(numpy.int64(_24))
    _25=mosek.fusion.Utils.Tools._range_II(_15,_16)
    self._task_1con_1putboundslice_1ra_II_3D_3D(_15,_16,_20,_21)
    _4 = mosek_fusion_RangedConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(self,_0,_5,_3,_25,(_8.ptrb),(_8.subj),(_8.cof),(_8.bfix),(_8.barsubi),(_8.barsubj),(_8.barmidx))
    self.__addConstraint_SLmosek_4fusion_4ModelConstraint_2(_0,_4)
   finally:
    if (_4 is None):
     self.__natvarmap_num = _10
     self._natbarvarmap_num = _13
     self._task_1cleanup_IIII(_10,_12,_11,_13)
   return (_4)
  def __constraint_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(_0,_1,_2,_3)
  def __constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4QConeDomain_2(self,_0,_1,_2,_3):
   _4=None
   _5=numpy.int32((_2._getShape_()._size))
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   _6=(_1 if ((_1 is not None) ) else ((_3._shape) if (((_3._shape) is not None) ) else _2._getShape_()))
   if ((((_3._shape) is not None) and (not _3._match_1shape_Lmosek_4fusion_4Set_2(_6))) or ((_2._getShape_() is not None) and (not _6._compare_Lmosek_4fusion_4Set_2(_2._getShape_())))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   _7=(_3._getAxis_() if (((_3._shape) is not None) ) else ((_6.nd) - 1))
   _8=_6._dim_I(_7)
   _9=1
   for _10 in range(0,(_6.nd)):
    if (_7!=_10):
     _9 *= _6._dim_I(_10)
   _11=1
   for _12 in range(0,_7):
    _11 *= _6._dim_I(_12)
   _13=1
   for _14 in range((_7 + 1),(_6.nd)):
    _13 *= _6._dim_I(_14)
   _15=_2._eval_()
   for _16 in range(0,int(((_15.x)).shape[0])):
    if (((_15.x)[_16]._getModel_() is not None) and ((_15.x)[_16]._getModel_() is not self)):
     raise mosek_fusion_ModelError._ctor_S("Expression belong to different models")
   _17=self.__build_1conA__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2((_15.ptrb),(_6._size),(_15.inst),(_15.subj),(_15.cof),(_15.bfix),(_15.x))
   _18=(int(((_17.ptrb)).shape[0]) - 1)
   _19=self.__task_vars_used
   _20=self._task_1numcon_()
   _21=self._task_1numcone_()
   _22=self._task_1numbarvar_()
   try:
    _23=self._task_1append_1con_I(_18)
    _24=(_23 + _18)
    if (((_17.subj) is not None) and (int(((_17.subj)).shape[0]) > 0)):
     self._task_1putarowslice_II_3J_3I_3D(_23,_24,(_17.ptrb),(_17.subj),(_17.cof))
    if ((_17.barsubi) is not None):
     for _25 in range(0,int(((_17.barsubi)).shape[0])):
      self._task_1putbaraij_III(((_17.barsubi)[_25] + _23),(_17.barsubj)[_25],(_17.barmidx)[_25])
    _26=mosek.fusion.Utils.Tools._range_II(_23,_24)
    _27=numpy.zeros(((_24 - _23),), dtype=numpy.dtype(numpy.float64))
    _28=(_8 * _9)
    _29=numpy.zeros((_28,), dtype=numpy.dtype(numpy.float64))
    _30=(_17.bfix)
    _31=(_15.bfix)
    if ((_17.bfix) is None):
     for _32 in range(0,(_24 - _23)):
      _27[_32] = (- (_17.bfix)[_32])
    if ((_15.bfix) is not None):
     for _33 in range(0,_28):
      _29[_33] = (- (_17.bfix)[_33])
    self._task_1con_1putboundslice_1fx_II_3D(_23,_24,_29)
    _34=self.__task_1alloc_1vars_I(_28)
    self.__natvarmap_1ensure_I(_28)
    self.__natvarmap_num = (self.__natvarmap_num + _28)
    _35=(_34 + _28)
    self._task_1putaijlist__3I_3I_3DJ(mosek.fusion.Utils.Tools._range_II(_23,_24),mosek.fusion.Utils.Tools._range_II(_34,_35),numpy.array([(- 1.0) for _36 in range(0,_28)], dtype=numpy.dtype(numpy.float64)),_28)
    self._task_1var_1putboundslice_1fr_II(_34,_35)
    if ((_3._key)==mosek.fusion.QConeKey.InQCone):
     _37 = self._task_1append_1quadcone_IIIII(_8,_34,_9,_11,_13)
    else:
     _37 = self._task_1append_1rquadcone_IIIII(_8,_34,_9,_11,_13)
    _4 = mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(self,_0,_3,_6,mosek.fusion.Utils.Tools._range_II(_23,_24),_34,_35,_8,_37,_9,(_17.ptrb),(_17.subj),(_17.cof),(_17.bfix),(_17.barsubi),(_17.barsubj),(_17.barmidx))
    self.__addConstraint_SLmosek_4fusion_4ModelConstraint_2(_0,_4)
    return (_4)
   finally:
    if (_4 is None):
     self.__natvarmap_num = _19
     self._natbarvarmap_num = _22
     self._task_1cleanup_IIII(_19,_20,_21,_22)
  def __constraint_1_alt_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self.__constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2,_3)
  def __constraint_1_SLmosek_4fusion_4Set_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2,_3):
   _4=None
   _5=numpy.int32((_2._getShape_()._size))
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   _6 = (_1 if ((_1 is not None) ) else ((_3._shape) if (((_3._shape) is not None) ) else _2._getShape_()))
   if ((((_3._shape) is not None) and (not _3._match_1shape_Lmosek_4fusion_4Set_2(_6))) or ((_2._getShape_() is not None) and (not _6._compare_Lmosek_4fusion_4Set_2(_2._getShape_())))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   _7=_2._eval_()
   for _8 in range(0,int(((_7.x)).shape[0])):
    if (((_7.x)[_8]._getModel_() is not None) and ((_7.x)[_8]._getModel_() is not self)):
     raise mosek_fusion_ModelError._ctor_S("Expression belong to different models")
   _9=self.__build_1conA__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2((_7.ptrb),(_6._size),(_7.inst),(_7.subj),(_7.cof),(_7.bfix),(_7.x))
   _10=(int(((_9.ptrb)).shape[0]) - 1)
   _11=self.__task_vars_used
   _12=self._task_1numcon_()
   _13=self._task_1numcone_()
   _14=self._task_1numbarvar_()
   try:
    _15=_10
    _16=self._task_1append_1con_I(_15)
    _17=(_16 + _15)
    if (((_9.subj) is not None) and (int(((_9.subj)).shape[0]) > 0)):
     self._task_1putarowslice_II_3J_3I_3D(_16,_17,(_9.ptrb),(_9.subj),(_9.cof))
    if ((_9.barsubi) is not None):
     for _18 in range(0,int(((_9.barsubi)).shape[0])):
      self._task_1putbaraij_III(((_9.barsubi)[_18] + _16),(_9.barsubj)[_18],(_9.barmidx)[_18])
    _19=mosek.fusion.Utils.Tools._range_II(_16,_17)
    _20=(numpy.array([_3._get_1rhs_1item_J(_21) for _21 in range(0,(_17 - _16))], dtype=numpy.dtype(numpy.float64)) if (((_9.bfix) is None) ) else numpy.array([(_3._get_1rhs_1item_J(_22) - (_9.bfix)[_22]) for _22 in range(0,(_17 - _16))], dtype=numpy.dtype(numpy.float64)))
    _23=(_3._key)
    if (_23==mosek.fusion.RelationKey.IsFree):
     self._task_1con_1putboundslice_1fr_II(_16,_17)
    elif (_23==mosek.fusion.RelationKey.LessThan):
     self._task_1con_1putboundslice_1up_II_3D(_16,_17,_20)
    elif (_23==mosek.fusion.RelationKey.GreaterThan):
     self._task_1con_1putboundslice_1lo_II_3D(_16,_17,_20)
    else:
     self._task_1con_1putboundslice_1fx_II_3D(_16,_17,_20)
    _4 = mosek_fusion_LinearConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,_0,_3,_6,_19,(_9.ptrb),(_9.subj),(_9.cof),(_9.bfix),(_9.barsubi),(_9.barsubj),(_9.barmidx))
    self.__addConstraint_SLmosek_4fusion_4ModelConstraint_2(_0,_4)
    return (_4)
   finally:
    if (_4 is None):
     self.__natvarmap_num = _11
     self._natbarvarmap_num = _14
     self._task_1cleanup_IIII(_11,_12,_13,_14)
  def __build_1conA_alt__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(object))
   _1 = self.__build_1conA__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __build_1conA__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(self,_0,_1,_2,_3,_4,_5,_6):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   _7=None
   _8=numpy.zeros(((_1 + 1),), dtype=numpy.dtype(numpy.int64))
   _9=None
   _10=(_2 if ((_2 is not None) ) else numpy.array([_11 for _11 in range(0,(int((_0).shape[0]) - 1))], dtype=numpy.dtype(numpy.int64)))
   _12=_5
   _13=0
   _14=0
   _19=int((_3).shape[0])
   _15 = numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _16 = numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _17 = numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _20=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Model.__inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_6,_3,_15,_16,_17)
   _18 = mosek.fusion.Utils.Tools._range_J(int((_3).shape[0]))
   if (_19 > (3 * int((_0).shape[0]))):
    for _21 in range(0,(int((_0).shape[0]) - 1)):
     mosek.fusion.Sort._argsort__3J_3IJJZ(_18,_15,_0[_21],_0[(_21 + 1)],True)
     fragments._c_closure_23(_0,_21,_20) # src/fusion/Model.mbi:1172:15-1173:32
   else:
    fragments._c_closure_24(_0,_20) # src/fusion/Model.mbi:1177:13-1179:32
    mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_18,_20,_15,0,int((_18).shape[0]),True)
   _14 = 0
   _13 = 0
   _13,_14 = fragments._c_closure_25(_19,_13,_14,_18,_20,_15) # src/fusion/Model.mbi:1191:11-1202:12
   _13 = numpy.int32(_13) # postprocess
   _14 = numpy.int32(_14) # postprocess
   if (_14==_19):
    _7 = _15
    _9 = _4
    if (int((_10).shape[0])==_1):
     _8 = _0
    else:
     fragments._c_closure_26(_10,_0,_8) # src/fusion/Model.mbi:1214:13-1223:14
   else:
    _22=0
    _23=0
    _7 = numpy.zeros((_14,), dtype=numpy.dtype(numpy.int32))
    _9 = numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
    _24=0
    _24 = fragments._c_closure_27(_9,_4,_24,_10,_0,_18,_8,_7,_15) # src/fusion/Model.mbi:1234:13-1263:16
    _24 = numpy.int32(_24) # postprocess
   _25=_8
   _26=None
   _27=None
   _28=None
   _29=0
   if (_13 > 0):
    _29 = fragments._c_closure_28(_0,_29,_18,_15) # src/fusion/Model.mbi:1281:11-1292:12
    _29 = numpy.int32(_29) # postprocess
    if (_29 > 0):
     _30=0
     _26 = numpy.zeros((_29,), dtype=numpy.dtype(numpy.int32))
     _27 = numpy.zeros((_29,), dtype=numpy.dtype(numpy.int32))
     _28 = numpy.zeros((_29,), dtype=numpy.dtype(numpy.int32))
     for _31 in range(0,(int((_0).shape[0]) - 1)):
      _32=_0[_31]
      while ((_32 < _0[(_31 + 1)]) and (_15[_18[_32]] < 0)):
       _33=_32
       _34=_15[_18[_32]]
       _32 += 1
       _32 = fragments._c_closure_29(_34,_0,_31,_32,_18,_15) # src/fusion/Model.mbi:1309:17-79
       _32 = numpy.int64(_32) # postprocess
       _35=(- (_34 + 1))
       _36=self._task_1barvardim_I(_35)
       fragments._c_closure_30(_33,_4,_32,_18,_16,_17) # src/fusion/Model.mbi:1315:17-1327:18
       if ((_32 - _33) > 1):
        if ((_32 - _33) < (2 * _36)):
         mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_18,_16,_17,_33,_32,True)
        else:
         mosek.fusion.Sort._argbucketsort__3J_3IJJII(_18,_17,_33,_32,0,_36)
         mosek.fusion.Sort._argbucketsort__3J_3IJJII(_18,_16,_33,_32,0,_36)
       _37=1
       _37 = fragments._c_closure_31(_33,_32,_18,_16,_17,_37) # src/fusion/Model.mbi:1342:17-1345:23
       _37 = numpy.int32(_37) # postprocess
       _38=numpy.zeros((_37,), dtype=numpy.dtype(numpy.int32))
       _39=numpy.zeros((_37,), dtype=numpy.dtype(numpy.int32))
       _40=numpy.zeros((_37,), dtype=numpy.dtype(numpy.float64))
       fragments._c_closure_32(_33,_40,_38,_39,_4,_32,_18,_16,_17) # src/fusion/Model.mbi:1351:17-1367:18
       _26[_30] = numpy.int32(_10[_31])
       _27[_30] = _35
       _28[_30] = self._task_1append_1barmatrix_I_3I_3I_3D(_36,_38,_39,_40)
       _30 += 1
   _41=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_33(_41,_5,_10) # src/fusion/Model.mbi:1380:9-1382:39
   return (mosek_fusion_ConNZStruct._ctor__3J_3I_3D_3D_3I_3I_3I(_8,_7,_9,_41,_26,_27,_28))
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   _3=None
   _4=numpy.int32((_1._getShape_()._size))
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)):
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   _5=((_2._shape) if (((_2._shape) is not None) ) else _1._getShape_())
   if ((((_2._shape) is not None) and (not (_2._shape)._compare_Lmosek_4fusion_4Set_2(_5))) or ((_1._getShape_() is not None) and (not _5._compare_Lmosek_4fusion_4Set_2(_1._getShape_())))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   _6=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _5._dim_I(0)))) - 1) / 2))
   if (((_6 * (_6 + 1)) // 2)!=_5._dim_I(0)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for semidefinite variable")
   _7=0
   _8=_5._dim_I(0)
   _9=1
   for _10 in range(1,(_5.nd)):
    _9 *= _5._dim_I(_10)
   _11=_1._eval_()
   for _12 in range(0,int(((_11.x)).shape[0])):
    if (((_11.x)[_12]._getModel_() is not None) and ((_11.x)[_12]._getModel_() is not self)):
     raise mosek_fusion_ModelError._ctor_S("Expression belong to different models")
   _13=self.__build_1conA__3JJ_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2((_11.ptrb),(_5._size),(_11.inst),(_11.subj),(_11.cof),(_11.bfix),(_11.x))
   _14=(int(((_13.ptrb)).shape[0]) - 1)
   _15=self.__task_vars_used
   _16=self._task_1numcon_()
   _17=self._task_1numcone_()
   _18=self._task_1numbarvar_()
   try:
    _19=self._task_1append_1con_I(_14)
    _20=(_19 + _14)
    if (((_13.subj) is not None) and (int(((_13.subj)).shape[0]) > 0)):
     self._task_1putarowslice_II_3J_3I_3D(_19,_20,(_13.ptrb),(_13.subj),(_13.cof))
    if ((_13.barsubi) is not None):
     for _21 in range(0,int(((_13.barsubi)).shape[0])):
      self._task_1putbaraij_III(((_13.barsubi)[_21] + _19),(_13.barsubj)[_21],(_13.barmidx)[_21])
    _22=mosek.fusion.Utils.Tools._range_II(_19,_20)
    _23=(numpy.zeros(((_20 - _19),), dtype=numpy.dtype(numpy.float64)) if (((_13.bfix) is None) ) else numpy.array([(- (_13.bfix)[_24]) for _24 in range(0,(_20 - _19))], dtype=numpy.dtype(numpy.float64)))
    _25=(_8 * _9)
    _26=(numpy.array([(- (_13.bfix)[_27]) for _27 in range(0,_25)], dtype=numpy.dtype(numpy.float64)) if (((_11.bfix) is not None) ) else numpy.zeros((_25,), dtype=numpy.dtype(numpy.float64)))
    self._task_1con_1putboundslice_1fx_II_3D(_19,_20,_26)
    _28=self._task_1append_1barvar_II(_6,_9)
    _29=numpy.zeros((1,), dtype=numpy.dtype(numpy.int32))
    _30=numpy.zeros((1,), dtype=numpy.dtype(numpy.int32))
    _31=numpy.zeros((1,), dtype=numpy.dtype(numpy.float64))
    _32=0
    for _33 in range(0,_6):
     _30[0] = _33
     for _34 in range(_33,_6):
      _29[0] = _34
      _31[0] = (- (1.0 if ((_34==_33) ) else 0.5))
      _35=self._task_1append_1barmatrix_I_3I_3I_3D(_6,_29,_30,_31)
      for _36 in range(0,_9):
       self._task_1putbaraij_III(((_19 + _32) + (_36 * _8)),(_28 + _36),_35)
      _32 += 1
    _3 = mosek_fusion_LinearPSDConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(self,_0,_5,mosek.fusion.Utils.Tools._range_II(_19,_20),_8,_28,_9,(_13.ptrb),(_13.subj),(_13.cof),(_13.bfix),(_13.barsubi),(_13.barsubj),(_13.barmidx))
    self.__addConstraint_SLmosek_4fusion_4ModelConstraint_2(_0,_3)
   finally:
    if (_3 is None):
     self.__natvarmap_num = _15
     self._natbarvarmap_num = _18
     self._task_1cleanup_IIII(_15,_16,_17,_18)
   return (_3)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   if ((_2._key)==mosek.fusion.PSDKey.IsSymPSD):
    return (self.__nonsym_1psdconstraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2))
   elif ((_2._key)==mosek.fusion.PSDKey.IsTrilPSD):
    _4=_1._eval_()
    for _5 in range(0,int(((_4.x)).shape[0])):
     if (((_4.x)[_5]._getModel_() is not None) and ((_4.x)[_5]._getModel_() is not self)):
      raise mosek_fusion_ModelError._ctor_S("Expression belong to different models")
    if (not (((((_4.shape).nd)==2) and ((_4.shape)._dim_I(0)==(_4.shape)._dim_I(1))) or ((((_4.shape).nd)==3) and ((_4.shape)._dim_I(1)==(_4.shape)._dim_I(2))))):
     raise mosek_fusion_DomainError._ctor_S("Invalid expression shape for semidefinite constraint")
    _6=(1 if ((((_4.shape).nd)==2) ) else (_4.shape)._dim_I(0))
    _7=((_4.shape)._dim_I(0) if ((((_4.shape).nd)==2) ) else (_4.shape)._dim_I(1))
    _8=(((_6 * _7) * (_7 + 1)) // 2)
    if (((_2._shape) is not None) and ((((_2._shape).nd)!=((_4.shape).nd)) or (((((_2._shape).nd)==2) and (((_2._shape)._dim_I(0)!=_7) or ((_2._shape)._dim_I(1)!=_7))) or ((((_2._shape).nd)==3) and (((_2._shape)._dim_I(0)!=_6) or (((_2._shape)._dim_I(1)!=_7) or ((_2._shape)._dim_I(2)!=_7))))))):
     raise mosek_fusion_DomainError._ctor_S("Expression shape does not match domain")
    _9=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_34(_6,_7,_9) # src/fusion/Model.mbi:972:11-981:12
    _10=(_4.bfix)
    if (_10 is None):
     _10 = numpy.zeros(((int(((_4.ptrb)).shape[0]) - 1),), dtype=numpy.dtype(numpy.float64))
    return (self.__sdptrilcon_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(_0,_7,_6,(_4.ptrb),(_4.inst),_9,(_4.subj),(_4.cof),_10,(_4.x)))
   else:
    raise mosek_fusion_UnexpectedError._ctor_S("Invalid domain")
  def __nonsym_1psdconstraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__nonsym_1psdconstraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def __nonsym_1psdconstraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   _3=_1._eval_()
   if ((((_3.shape).nd)==2) and ((_3.shape)._dim_I(0)!=(_3.shape)._dim_I(1))):
    raise mosek_fusion_DomainError._ctor_S("Invalid expression shape for semidefinite constraint")
   elif ((((_3.shape).nd)==3) and ((_3.shape)._dim_I(1)!=(_3.shape)._dim_I(2))):
    raise mosek_fusion_DomainError._ctor_S("Invalid expression shape for semidefinite constraint")
   _4=(_3.shape)._dim_I(1)
   _5=(1 if ((((_3.shape).nd)==2) ) else (_3.shape)._dim_I(0))
   _6=(((_5 * _4) * (_4 + 1)) // 2)
   if ((_2._shape) is not None):
    if (((_2._shape).nd)!=((_3.shape).nd)):
     raise mosek_fusion_DomainError._ctor_S("Expression shape does not match domain")
    elif ((((_2._shape).nd)==2) and (((_2._shape)._dim_I(0)!=_4) or ((_2._shape)._dim_I(1)!=_4))):
     raise mosek_fusion_DomainError._ctor_S("Expression shape does not match domain")
    elif ((((_2._shape).nd)==3) and (((_2._shape)._dim_I(1)!=_4) or (((_2._shape)._dim_I(2)!=_4) or ((_2._shape)._dim_I(0)!=_5)))):
     raise mosek_fusion_DomainError._ctor_S("Expression shape does not match domain")
   if (((_3.inst) is None) or (int(((_3.inst)).shape[0])==_6)):
    _7=_6
    _8=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _9=numpy.zeros(((_7 + 1),), dtype=numpy.dtype(numpy.int64))
    _10=numpy.zeros((int(((_3.subj)).shape[0]),), dtype=numpy.dtype(numpy.float64))
    _11=numpy.zeros((int(((_3.subj)).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _12=numpy.array([_13 for _13 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    _14=None
    _15=0
    for _16 in range(0,_5):
     for _17 in range(0,_4):
      for _18 in range(0,(_17 + 1)):
       _19=numpy.int64(((((_16 * _4) * _4) + (_17 * _4)) + _18))
       _20=numpy.int64(((((_16 * _4) * _4) + (_18 * _4)) + _17))
       if (_17==_18):
        _9[(_15 + 1)] = ((_3.ptrb)[(_19 + 1)] - (_3.ptrb)[_19])
       else:
        _9[(_15 + 1)] = ((((_3.ptrb)[(_19 + 1)] - (_3.ptrb)[_19]) + (_3.ptrb)[(_20 + 1)]) - (_3.ptrb)[_20])
       _8[_15] = _19
       _15 += 1
    fragments._c_closure_35(_6,_9) # src/fusion/Model.mbi:796:13-69
    if ((_3.bfix) is not None):
     _14 = numpy.zeros((int((_8).shape[0]),), dtype=numpy.dtype(numpy.float64))
     _21=0
     for _22 in range(0,_5):
      for _23 in range(0,_4):
       for _24 in range(0,(_23 + 1)):
        _25=numpy.int64(((((_22 * _4) * _4) + (_23 * _4)) + _24))
        _26=numpy.int64(((((_22 * _4) * _4) + (_24 * _4)) + _23))
        if (_23==_24):
         _14[_21] = (_3.bfix)[_25]
        else:
         _14[_21] = (0.5 * ((_3.bfix)[_25] + (_3.bfix)[_26]))
        _21 += 1
    _27=0
    for _28 in range(0,_5):
     for _29 in range(0,_4):
      for _30 in range(0,(_29 + 1)):
       _31=((((_28 * _4) * _4) + (_29 * _4)) + _30)
       _32=((((_28 * _4) * _4) + (_30 * _4)) + _29)
       if (_29==_30):
        mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_3.subj),(_3.ptrb)[_31],_11,_9[_27],((_3.ptrb)[(_31 + 1)] - (_3.ptrb)[_31]))
        mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_3.cof),(_3.ptrb)[_31],_10,_9[_27],((_3.ptrb)[(_31 + 1)] - (_3.ptrb)[_31]))
       else:
        _33=((_3.ptrb)[(_31 + 1)] - (_3.ptrb)[_31])
        _34=((_3.ptrb)[(_32 + 1)] - (_3.ptrb)[_32])
        mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_3.subj),(_3.ptrb)[_31],_11,_9[_27],_33)
        mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_3.subj),(_3.ptrb)[_32],_11,(_9[_27] + _33),_34)
        for _35 in range(0,_33):
         _10[(_9[_27] + _35)] = (0.5 * (_3.cof)[((_3.ptrb)[_31] + _35)])
        for _36 in range(0,_34):
         _10[((_9[_27] + _33) + _36)] = (0.5 * (_3.cof)[((_3.ptrb)[_32] + _36)])
       _27 += 1
    return (self.__sdptrilcon_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(_0,_4,_5,_9,_8,_12,_11,_10,_14,(_3.x)))
   else:
    _37=(_4 * _4)
    _38=mosek.fusion.Utils.Tools._arraycopy__3J((_3.inst))
    for _39 in range(0,int((_38).shape[0])):
     _40=((_3.inst)[_39] // _37)
     _41=(((_3.inst)[_39] // _4) % _4)
     _42=((_3.inst)[_39] % _4)
     if (_42 > _41):
      _38[_39] = (((_40 * _37) + (_42 * _4)) + _41)
     else:
      _38[_39] = (_3.inst)[_39]
     if (_41!=_42):
      for _43 in range((_3.ptrb)[_39],(_3.ptrb)[(_39 + 1)]):
       (_3.cof)[_43] /= 2
      if ((_3.bfix) is not None):
       (_3.bfix)[_39] /= 2
    _44=numpy.array([_45 for _45 in range(0,int((_38).shape[0]))], dtype=numpy.dtype(numpy.int64))
    _46=numpy.zeros((((_5 * _4) + 1),), dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Sort._argTransposeSort__3J_3JIII_3J(_44,_46,_5,_4,_4,_38)
    mosek.fusion.Sort._argTransposeSort__3J_3JIII_3J(_44,_46,(_5 * _4),_4,1,_38)
    _47=0
    _47 = fragments._c_closure_36(_47,_38,_44) # src/fusion/Model.mbi:882:11-888:12
    _47 = numpy.int32(_47) # postprocess
    if (int((_38).shape[0])==_47):
     return (self.__sdptrilcon_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(_0,_4,_5,(_3.ptrb),_38,_44,(_3.subj),(_3.cof),(_3.bfix),(_3.x)))
    else:
     _48=numpy.zeros(((_47 + 1),), dtype=numpy.dtype(numpy.int64))
     _49=numpy.zeros((_47,), dtype=numpy.dtype(numpy.int64))
     _50=numpy.zeros((int(((_3.subj)).shape[0]),), dtype=numpy.dtype(numpy.int64))
     _51=numpy.zeros((int(((_3.subj)).shape[0]),), dtype=numpy.dtype(numpy.float64))
     _52=numpy.zeros((_47,), dtype=numpy.dtype(numpy.float64))
     _53=0
     _54=0
     for _55 in range(0,int((_44).shape[0])):
      if ((_55 > 0) and (_38[_44[_55]]!=_38[_44[(_55 - 1)]])):
       _53 += 1
      _56=((_3.ptrb)[(_44[_55] + 1)] - (_3.ptrb)[_44[_55]])
      mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_3.subj),(_3.ptrb)[_44[_55]],_50,_54,_56)
      mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_3.cof),(_3.ptrb)[_44[_55]],_51,_54,_56)
      _54 += _56
      _48[(_53 + 1)] = _54
      _49[_53] = _38[_44[_55]]
     if ((_3.bfix) is not None):
      _57=0
      for _58 in range(0,int((_44).shape[0])):
       if ((_58 > 0) and (_38[_44[_58]]!=_38[_44[(_58 - 1)]])):
        _57 += 1
       _59=(((_3.inst)[_44[_58]] // _4) % _4)
       _60=((_3.inst)[_44[_58]] % _4)
       _52[_57] += (_3.bfix)[_44[_58]]
     return (self.__sdptrilcon_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(_0,_4,_5,_48,_49,mosek.fusion.Utils.Tools._range_J(int((_49).shape[0])),_50,_51,_52,(_3.x)))
  def __sdptrilcon_alt_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int64))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.float64))
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.float64))
   _9=numpy.array(_t__9,dtype=numpy.dtype(object))
   _1 = self.__sdptrilcon_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__9[:] = _9
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __sdptrilcon_SII_3J_3J_3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   assert _8 is None or isinstance(_8,numpy.ndarray)
   assert _9 is None or isinstance(_9,numpy.ndarray)
   _10=None
   _11=0
   _11 = fragments._c_closure_37(_11,_5,_3) # src/fusion/Model.mbi:511:31-110
   _11 = numpy.int64(_11) # postprocess
   _12=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
   _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
   _14=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
   _15=numpy.zeros(((int((_5).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
   _16=0
   for _17 in range(0,int((_5).shape[0])):
    mosek.fusion.Model.__inst__3Lmosek_4fusion_4Variable_2II_3JI_3I_3I_3I(_9,numpy.int32(_3[_5[_17]]),numpy.int32(_3[(_5[_17] + 1)]),_6,_16,_12,_13,_14)
    _16 = (_16 + numpy.int32((_3[(_5[_17] + 1)] - _3[_5[_17]])))
    _15[(_17 + 1)] = _16
   _18=(_2 * ((_1 * (_1 + 1)) // 2))
   _19=0
   _19 = fragments._c_closure_38(_11,_19,_12) # src/fusion/Model.mbi:536:9-64
   _19 = numpy.int64(_19) # postprocess
   _20=(_11 - _19)
   _21=mosek.fusion.Utils.Tools._range_J(_11)
   for _22 in range(0,int((_5).shape[0])):
    mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_21,_12,None,_15[_22],_15[(_22 + 1)])
   _23=0
   _23 = fragments._c_closure_39(_23,_5,_21,_15,_12) # src/fusion/Model.mbi:546:9-555:10
   _23 = numpy.int64(_23) # postprocess
   _24=numpy.zeros((int((_5).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_40(_4,_1,_5,_24) # src/fusion/Model.mbi:560:9-577:10
   _25=self.__task_vars_used
   _26=self._task_1numcon_()
   _27=self._task_1numcone_()
   _28=self._task_1numbarvar_()
   try:
    _29=self._task_1append_1con_I(_18)
    _30=(_29 + _18)
    _31=numpy.zeros(((_18 + 1),), dtype=numpy.dtype(numpy.int64))
    _32=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int32))
    _33=numpy.zeros((_23,), dtype=numpy.dtype(numpy.float64))
    if (_20 > 0):
     _34=0
     _34 = fragments._c_closure_41(_33,_18,_5,_21,_24,_31,_34,_32,_15,_12,_7) # src/fusion/Model.mbi:598:13-628:14
     _34 = numpy.int64(_34) # postprocess
     self._task_1putarowslice_II_3J_3I_3D(_29,_30,_31,_32,_33)
    _35=numpy.zeros((_18,), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_42(_35,_8,_5,_24) # src/fusion/Model.mbi:635:11-636:69
    self._task_1con_1putboundslice_1fx_II_3D(_29,_30,_35)
    if (_19 > 0):
     for _36 in range(0,int((_5).shape[0])):
      _37=_3[_5[_36]]
      _38=_3[(_5[_36] + 1)]
      _39=_37
      _39 = fragments._c_closure_43(_38,_39,_21,_12) # src/fusion/Model.mbi:646:28-76
      _39 = numpy.int64(_39) # postprocess
      if (_37 < _39):
       _40=_12[_21[_37]]
       while (_37 < _39):
        _41=_37
        _37 = fragments._c_closure_44(_40,_37,_39,_21,_12) # src/fusion/Model.mbi:654:19-77
        _37 = numpy.int64(_37) # postprocess
        _42=(- (_40 + 1))
        mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_21,_13,_14,_41,_37)
        _43=1
        _43 = fragments._c_closure_45(_43,_37,_41,_21,_13,_14) # src/fusion/Model.mbi:660:19-663:36
        _43 = numpy.int32(_43) # postprocess
        _44=numpy.zeros((_43,), dtype=numpy.dtype(numpy.int32))
        _45=numpy.zeros((_43,), dtype=numpy.dtype(numpy.int32))
        _46=numpy.zeros((_43,), dtype=numpy.dtype(numpy.float64))
        fragments._c_closure_46(_44,_45,_46,_37,_41,_21,_13,_14,_7) # src/fusion/Model.mbi:667:19-682:20
        _47=self._task_1barvardim_I(_42)
        _48=self._task_1append_1barmatrix_I_3I_3I_3D(_47,_44,_45,_46)
        self._task_1putbaraij_III(numpy.int32((_24[_36] + _29)),_42,_48)
    _49=self._task_1append_1barvar_II(_1,_2)
    _50=numpy.zeros((1,), dtype=numpy.dtype(numpy.int32))
    _51=numpy.zeros((1,), dtype=numpy.dtype(numpy.int32))
    _52=numpy.zeros((1,), dtype=numpy.dtype(numpy.float64))
    for _53 in range(0,_1):
     for _54 in range(0,(_53 + 1)):
      _50[0] = _53
      _51[0] = _54
      _52[0] = (- (1.0 if ((_53==_54) ) else 0.5))
      _55=self._task_1append_1barmatrix_I_3I_3I_3D(_1,_50,_51,_52)
      for _56 in range(0,_2):
       _57=(((((_56 * _1) * (_1 + 1)) // 2) + ((_53 * (_53 + 1)) // 2)) + _54)
       self._task_1putbaraij_III((_29 + _57),(_49 + _56),_55)
    _58=None
    if (_2==1):
     _58 = mosek_fusion_NDSet._ctor_II(_1,_1)
    else:
     _58 = mosek_fusion_NDSet._ctor_III(_1,_1,_2)
    _10 = mosek_fusion_PSDConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(self,_0,_58,mosek.fusion.Utils.Tools._range_II(_29,_30),_1,_49,_2,_31,_32,_33,_35,None,None,None)
    self.__natbarvarmap_1ensure_I(_2)
    self._natbarvarmap_num += _2
    self.__addConstraint_SLmosek_4fusion_4ModelConstraint_2(_0,_10)
    return (_10)
   finally:
    if (_10 is None):
     self._natbarvarmap_num = _28
     self.__natvarmap_num = _25
     self._task_1cleanup_IIII(_25,_26,_27,_28)
  def __addConstraint_alt_SLmosek_4fusion_4ModelConstraint_2(self,_t__0,_t__1):
    return self.__addConstraint_SLmosek_4fusion_4ModelConstraint_2(_0,_1)
  def __addConstraint_SLmosek_4fusion_4ModelConstraint_2(self,_0,_1):
   if (self.__cons_used >= int((self.__cons).shape[0])):
    _2=((int((self.__cons).shape[0]) * 2) if ((int((self.__cons).shape[0]) > 100) ) else 100)
    _3=self.__cons
    self.__cons = numpy.zeros((_2,), dtype=numpy.dtype(object))
    for _4 in range(0,self.__cons_used):
     self.__cons[_4] = _3[_4]
   self.__cons[self.__cons_used] = _1
   if (int(len(_0)) > 0):
    self.__con_map._setItem_SI(_0,self.__cons_used)
   self.__cons_used += 1
  def __addVariable_alt_SLmosek_4fusion_4ModelVariable_2(self,_t__0,_t__1):
    return self.__addVariable_SLmosek_4fusion_4ModelVariable_2(_0,_1)
  def __addVariable_SLmosek_4fusion_4ModelVariable_2(self,_0,_1):
   if (self._vars_used >= int((self._vars).shape[0])):
    _2=((int((self._vars).shape[0]) * 2) if ((int((self._vars).shape[0]) > 100) ) else 100)
    _3=self._vars
    self._vars = numpy.zeros((_2,), dtype=numpy.dtype(object))
    for _4 in range(0,self._vars_used):
     self._vars[_4] = _3[_4]
   self._vars[self._vars_used] = _1
   if (int(len(_0)) > 0):
    self.__var_map._setItem_SI(_0,self._vars_used)
   self._vars_used += 1
  @staticmethod
  def _match_numConstraints_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numConstraints_(*args):
    if len(args) != 0: return False
    return True
  def _numConstraints_alt_(self,):
    return self._numConstraints_()
  def _numConstraints_(self,):
   return numpy.int32(self.__cons_used)
  @staticmethod
  def _match_numVariables_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numVariables_(*args):
    if len(args) != 0: return False
    return True
  def _numVariables_alt_(self,):
    return self._numVariables_()
  def _numVariables_(self,):
   return numpy.int32(self._vars_used)
  @staticmethod
  def _match_hasConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_hasConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _hasConstraint_alt_S(self,_t__0):
    return self._hasConstraint_S(_0)
  def _hasConstraint_S(self,_0):
   return (self.__con_map._hasItem_S(_0))
  @staticmethod
  def _match_hasVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_hasVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _hasVariable_alt_S(self,_t__0):
    return self._hasVariable_S(_0)
  def _hasVariable_S(self,_0):
   return (self.__var_map._hasItem_S(_0))
  @staticmethod
  def _match_getConstraint_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getConstraint_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getConstraint_alt_I(self,_t__0):
    return self._getConstraint_I(numpy.int32(__0))
  def _getConstraint_I(self,_0):
   return ((self.__cons[_0] if (((_0 >= 0) and (_0 < self.__cons_used)) ) else None))
  @staticmethod
  def _match_getConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getConstraint_alt_S(self,_t__0):
    return self._getConstraint_S(_0)
  def _getConstraint_S(self,_0):
   return ((self.__cons[self.__con_map._getItem_S(_0)] if (self.__con_map._hasItem_S(_0) ) else None))
  @staticmethod
  def _match_getVariable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getVariable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getVariable_alt_I(self,_t__0):
    return self._getVariable_I(numpy.int32(__0))
  def _getVariable_I(self,_0):
   return ((self._vars[_0] if (((_0 >= 0) and (_0 < self._vars_used)) ) else None))
  @staticmethod
  def _match_getVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getVariable_alt_S(self,_t__0):
    return self._getVariable_S(_0)
  def _getVariable_S(self,_0):
   return ((self._vars[self.__var_map._getItem_S(_0)] if (self.__var_map._hasItem_S(_0) ) else None))
  @staticmethod
  def _match_getName_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getName_(*args):
    if len(args) != 0: return False
    return True
  def _getName_alt_(self,):
    return self._getName_()
  def _getName_(self,):
   return (self.__model_name)
  @staticmethod
  def _match_clone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clone_(*args):
    if len(args) != 0: return False
    return True
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_Model._ctor_Lmosek_4fusion_4Model_2(self))
  def __natbarvarmap_1ensure_alt_I(self,_t__0):
    return self.__natbarvarmap_1ensure_I(numpy.int32(__0))
  def __natbarvarmap_1ensure_I(self,_0):
   if ((self._natbarvarmap_num + _0) > int((self._natbarvarmap_Var).shape[0])):
    _1=(2 * int((self._natbarvarmap_Var).shape[0]))
    if (_1 < (self._natbarvarmap_num + _0)):
     _1 = (self._natbarvarmap_num + _0)
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_47(self._natbarvarmap_Var,self._natbarvarmap_num,_2) # src/fusion/Model.mbi:312:11-82
    self._natbarvarmap_Var = _2
  def __natvarmap_1ensure_alt_I(self,_t__0):
    return self.__natvarmap_1ensure_I(numpy.int32(__0))
  def __natvarmap_1ensure_I(self,_0):
   if ((self.__natvarmap_num + _0) > int((self.__natvarmap_idx).shape[0])):
    _1=(2 * int((self.__natvarmap_idx).shape[0]))
    if (_1 < (self.__natvarmap_num + _0)):
     _1 = (self.__natvarmap_num + _0)
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.__natvarmap_idx,0,_2,0,self.__natvarmap_num)
    _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_48(self.__natvarmap_Var,self.__natvarmap_num,_3) # src/fusion/Model.mbi:294:11-295:47
    self.__natvarmap_idx = _2
    self.__natvarmap_Var = _3
  def __task_1alloc_1vars_alt_I(self,_t__0):
    return self.__task_1alloc_1vars_I(numpy.int32(__0))
  def __task_1alloc_1vars_I(self,_0):
   if ((self.__task_vars_allocated - self.__task_vars_used) < _0):
    _1=(1000 if ((((_0 + self.__task_vars_used) - self.__task_vars_allocated) < 1000) ) else _0)
    self._task_1append_1var_I(_1)
    self.__task_vars_allocated += _1
   _2=self.__task_vars_used
   self.__task_vars_used += _0
   return numpy.int32(_2)
 return Model
mosek_fusion_Model=__mk_mosek_fusion_Model()
del __mk_mosek_fusion_Model
def __mk_mosek_fusion_Debug():
  class Debug:
    @staticmethod 
    def _o_(): return Debug()
    def p(self,v): 
      sys.stdout.write(str(v))
      return self
    _p_S = p
    _p_I = p
    _p_J = p
    _p_D = p
    _p_Z = p
  
    def p_array (self,v):
      if v is None:
          sys.stdout.write('None')
      else:
          sys.stdout.write('[ %s ]' % ','.join([str(i) for i in v]))
      return self
  
    _p__3I = p_array
    _p__3J = p_array
    _p__3D = p_array
  
    def _lf_(self): 
      sys.stdout.write("\n")
      return self
  
  return Debug
mosek_fusion_Debug=__mk_mosek_fusion_Debug()
#BEFORE CLASS
def __mk_mosek_fusion_Sort():
 class Sort(object):
  @staticmethod
  def argTransposeSort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argTransposeSort__3J_3JIII_3J(*args): # []int64,[]int64,int32,int32,int32,[]int64
      return mosek_fusion_Sort._argTransposeSort__3J_3JIII_3J(*args)
    elif mosek_fusion_Sort._match_alt_argTransposeSort__3J_3JIII_3J(*args): # []int64,[]int64,int32,int32,int32,[]int64
      return mosek_fusion_Sort._argTransposeSort_alt__3J_3JIII_3J(*args)
    else:
      raise ValueError('Invalid argument list argTransposeSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argTransposeSort(array(int64,ndim=1),array(int64,ndim=1),int32,int32,int32,array(int64,ndim=1))')
  @staticmethod
  def getminmax(*args):
    if False: pass
    elif mosek_fusion_Sort._match_getminmax__3J_3I_3IJJ_3I(*args): # []int64,[]int32,[]int32,int64,int64,[]int32
      return mosek_fusion_Sort._getminmax__3J_3I_3IJJ_3I(*args)
    elif mosek_fusion_Sort._match_alt_getminmax__3J_3I_3IJJ_3I(*args): # []int64,[]int32,[]int32,int64,int64,[]int32
      return mosek_fusion_Sort._getminmax_alt__3J_3I_3IJJ_3I(*args)
    elif mosek_fusion_Sort._match_getminmax__3J_3J_3JJJ_3J(*args): # []int64,[]int64,[]int64,int64,int64,[]int64
      return mosek_fusion_Sort._getminmax__3J_3J_3JJJ_3J(*args)
    elif mosek_fusion_Sort._match_alt_getminmax__3J_3J_3JJJ_3J(*args): # []int64,[]int64,[]int64,int64,int64,[]int64
      return mosek_fusion_Sort._getminmax_alt__3J_3J_3JJJ_3J(*args)
    else:
      raise ValueError('Invalid argument list getminmax('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,array(int32,ndim=1))\n\tmosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,array(int64,ndim=1))')
  @staticmethod
  def argsort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argsort__3J_3J(*args): # []int64,[]int64
      return mosek_fusion_Sort._argsort__3J_3J(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J(*args): # []int64,[]int64
      return mosek_fusion_Sort._argsort_alt__3J_3J(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I(*args): # []int64,[]int32
      return mosek_fusion_Sort._argsort__3J_3I(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I(*args): # []int64,[]int32
      return mosek_fusion_Sort._argsort_alt__3J_3I(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3I(*args): # []int64,[]int32,[]int32
      return mosek_fusion_Sort._argsort__3J_3I_3I(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3I(*args): # []int64,[]int32,[]int32
      return mosek_fusion_Sort._argsort_alt__3J_3I_3I(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3J(*args): # []int64,[]int64,[]int64
      return mosek_fusion_Sort._argsort__3J_3J_3J(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3J(*args): # []int64,[]int64,[]int64
      return mosek_fusion_Sort._argsort_alt__3J_3J_3J(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3JJJ(*args): # []int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort__3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3JJJ(*args): # []int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3IJJ(*args): # []int64,[]int32,int64,int64
      return mosek_fusion_Sort._argsort__3J_3IJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3IJJ(*args): # []int64,[]int32,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3IJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_Sort._argsort__3J_3I_3IJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3I_3IJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort__3J_3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3J_3JJJZ(*args)
    else:
      raise ValueError('Invalid argument list argsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)')
  @staticmethod
  def issorted(*args):
    if False: pass
    elif mosek_fusion_Sort._match_issorted__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3J_3JJJZ(*args)
    else:
      raise ValueError('Invalid argument list issorted('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)')
  @staticmethod
  def argbucketsort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argbucketsort__3J_3IJJII(*args): # []int64,[]int32,int64,int64,int32,int32
      return mosek_fusion_Sort._argbucketsort__3J_3IJJII(*args)
    elif mosek_fusion_Sort._match_alt_argbucketsort__3J_3IJJII(*args): # []int64,[]int32,int64,int64,int32,int32
      return mosek_fusion_Sort._argbucketsort_alt__3J_3IJJII(*args)
    elif mosek_fusion_Sort._match_argbucketsort__3J_3JJJJJ(*args): # []int64,[]int64,int64,int64,int64,int64
      return mosek_fusion_Sort._argbucketsort__3J_3JJJJJ(*args)
    elif mosek_fusion_Sort._match_alt_argbucketsort__3J_3JJJJJ(*args): # []int64,[]int64,int64,int64,int64,int64
      return mosek_fusion_Sort._argbucketsort_alt__3J_3JJJJJ(*args)
    else:
      raise ValueError('Invalid argument list argbucketsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,int32,int32)\n\tmosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,int64,int64)')
  def __repr__(self): return 'mosek.fusion.Sort'
  @staticmethod
  def _match_argTransposeSort__3J_3JIII_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3) and __arg_match_I__(_4) and __arg_match__3J__(_5))
  @staticmethod
  def _match_alt_argTransposeSort__3J_3JIII_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match__3J__(_5))
  @staticmethod
  def _argTransposeSort_alt__3J_3JIII_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argTransposeSort__3J_3JIII_3J(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argTransposeSort__3J_3JIII_3J(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   fragments._c_closure_49(_2,_4,_1) # src/fusion/Sort.mbi:251:9-44
   for _6 in range(0,int((_5).shape[0])):
    _1[((((_5[_0[_6]] // (_3 * _4)) * _4) + (_5[_0[_6]] % _4)) + 1)] += 1
   fragments._c_closure_50(_2,_4,_1) # src/fusion/Sort.mbi:253:9-62
   _7=numpy.array([_0[_8] for _8 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))
   for _9 in range(0,int((_5).shape[0])):
    _10=(((_5[_7[_9]] // (_3 * _4)) * _4) + (_5[_7[_9]] % _4))
    _0[_1[_10]] = _7[_9]
    _1[_10] += 1
  @staticmethod
  def _match_argsort__3J_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_argsort__3J_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1))
  @staticmethod
  def _argsort_alt__3J_3J(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argsort__3J_3J(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3JJJZ(_0,_1,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_argsort__3J_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _argsort_alt__3J_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._argsort__3J_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3IJJZ(_0,_1,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2))
  @staticmethod
  def _match_alt_argsort__3J_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2))
  @staticmethod
  def _argsort_alt__3J_3J_3J(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argsort__3J_3J_3J(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3J(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_argsort__3J_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _argsort_alt__3J_3I_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._argsort__3J_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3JJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3))
  @staticmethod
  def _match_alt_argsort__3J_3JJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3))
  @staticmethod
  def _argsort_alt__3J_3JJJ(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _1 = mosek_fusion_Sort._argsort__3J_3JJJ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3JJJ(_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3JJJZ(_0,_1,_2,_3,False)
  @staticmethod
  def _match_argsort__3J_3IJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3))
  @staticmethod
  def _match_alt_argsort__3J_3IJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3))
  @staticmethod
  def _argsort_alt__3J_3IJJ(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _1 = mosek_fusion_Sort._argsort__3J_3IJJ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3IJJ(_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3IJJZ(_0,_1,_2,_3,False)
  @staticmethod
  def _match_argsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argsort_alt__3J_3J_3JJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_Sort._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,False)
  @staticmethod
  def _match_argsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argsort_alt__3J_3I_3IJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_Sort._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,False)
  @staticmethod
  def _match_argsort__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _argsort_alt__3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._argsort__3J_3JJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3JJJZ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((not _4) or ((_3 - _2) < 16)):
    mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_2,_3)
   elif (not mosek.fusion.Sort._issorted__3J_3JJJZ(_0,_1,_2,_3,_4)):
    _5=numpy.zeros((4,), dtype=numpy.dtype(numpy.int64))
    _6=2
    mosek.fusion.Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,None,_2,_3,_5)
    if ((_5[1] - _5[0]) < (_6 * (_3 - _2))):
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_5[0],_5[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_2,_3)
  @staticmethod
  def _match_argsort__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _argsort_alt__3J_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._argsort__3J_3IJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3IJJZ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((not _4) or ((_3 - _2) < 16)):
    mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_2,_3)
   elif (not mosek.fusion.Sort._issorted__3J_3IJJZ(_0,_1,_2,_3,_4)):
    _5=numpy.zeros((4,), dtype=numpy.dtype(numpy.int32))
    _6=2
    mosek.fusion.Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,None,_2,_3,_5)
    if ((_5[1] - _5[0]) < (_6 * (_3 - _2))):
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_1,_2,_3,_5[0],_5[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_2,_3)
  @staticmethod
  def _match_argsort__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_argsort__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _argsort_alt__3J_3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((not _5) or ((_4 - _3) < 16)):
    mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   elif (not mosek.fusion.Sort._issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)):
    _6=numpy.zeros((4,), dtype=numpy.dtype(numpy.int64))
    _7=2
    mosek.fusion.Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_6)
    if (((_6[1] - _6[0]) < (_7 * (_4 - _3))) and ((_6[3] - _6[2]) < (_7 * (_4 - _3)))):
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_2,_3,_4,_6[2],_6[3])
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_1,_3,_4,_6[0],_6[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argsort__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_argsort__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _argsort_alt__3J_3I_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((not _5) or ((_4 - _3) < 16)):
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   elif (not mosek.fusion.Sort._issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)):
    _6=numpy.zeros((4,), dtype=numpy.dtype(numpy.int32))
    _7=2
    mosek.fusion.Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_6)
    if (((_6[1] - _6[0]) < (_7 * (_4 - _3))) and ((_6[3] - _6[2]) < (_7 * (_4 - _3)))):
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_2,_3,_4,_6[2],_6[3])
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_1,_3,_4,_6[0],_6[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argbucketsort__3J_3JJJJJ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_J__(_5))
  @staticmethod
  def _match_alt_argbucketsort__3J_3JJJJJ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_J__(_5))
  @staticmethod
  def _argbucketsort_alt__3J_3JJJJJ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.int64(_t__5)
   _1 = mosek_fusion_Sort._argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Utils.Tools._bucketsort__3JJJ_3JJJ(_0,_2,_3,_1,_4,_5)
  @staticmethod
  def _match_argbucketsort__3J_3IJJII(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_I__(_4) and __arg_match_I__(_5))
  @staticmethod
  def _match_alt_argbucketsort__3J_3IJJII(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match_I__(_5))
  @staticmethod
  def _argbucketsort_alt__3J_3IJJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _1 = mosek_fusion_Sort._argbucketsort__3J_3IJJII(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argbucketsort__3J_3IJJII(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Utils.Tools._bucketsort__3JJJ_3III(_0,_2,_3,_1,_4,_5)
  @staticmethod
  def _match_getminmax__3J_3J_3JJJ_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3J__(_5))
  @staticmethod
  def _match_alt_getminmax__3J_3J_3JJJ_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3J__(_5))
  @staticmethod
  def _getminmax_alt__3J_3J_3JJJ_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   fragments._c_closure_51(_3,_0,_4,_5,_1,_2) # src/fusion/Sort.mbi:62:7-80:8
  @staticmethod
  def _match_getminmax__3J_3I_3IJJ_3I(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5))
  @staticmethod
  def _match_alt_getminmax__3J_3I_3IJJ_3I(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5))
  @staticmethod
  def _getminmax_alt__3J_3I_3IJJ_3I(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   fragments._c_closure_52(_3,_0,_4,_5,_1,_2) # src/fusion/Sort.mbi:41:7-59:8
  @staticmethod
  def _match_issorted__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_issorted__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _issorted_alt__3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._issorted__3J_3JJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3JJJZ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   for _5 in range(_2,(_3 - 1)):
    if (_1[_0[_5]] > _1[_0[(_5 + 1)]]):
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_issorted__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _issorted_alt__3J_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._issorted__3J_3IJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3IJJZ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   for _5 in range(_2,(_3 - 1)):
    if (_1[_0[_5]] > _1[_0[(_5 + 1)]]):
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_issorted__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _issorted_alt__3J_3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   for _6 in range(_3,(_4 - 1)):
    if ((_1[_0[_6]] > _1[_0[(_6 + 1)]]) or ((_1[_0[(_6 + 1)]]==_1[_0[_6]]) and (_2[_0[_6]] > _2[_0[(_6 + 1)]]))):
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_issorted__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _issorted_alt__3J_3I_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   for _6 in range(_3,(_4 - 1)):
    if ((_1[_0[_6]] > _1[_0[(_6 + 1)]]) or ((_1[_0[_6]]==_1[_0[(_6 + 1)]]) and (_2[_0[_6]] > _2[_0[(_6 + 1)]]))):
     return (False)
   return (True)
 return Sort
mosek_fusion_Sort=__mk_mosek_fusion_Sort()
del __mk_mosek_fusion_Sort
#BEFORE CLASS
def __mk_mosek_fusion_IndexCounter():
 class IndexCounter(object):
  __slots__ = ['_IndexCounter__start','_IndexCounter__dims','_IndexCounter__strides','_IndexCounter__st','_IndexCounter__ii','_IndexCounter__n']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Set
      self._ctor_init_Lmosek_4fusion_4Set_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Set_2(*args):# mosek.fusion.Set
      self._ctor_alt_init_Lmosek_4fusion_4Set_2(*args)
    elif self.__match_ctor_J_3ILmosek_4fusion_4Set_2(*args): # int64,[]int32,mosek.fusion.Set
      self._ctor_init_J_3ILmosek_4fusion_4Set_2(*args)
    elif self.__match_alt_ctor_J_3ILmosek_4fusion_4Set_2(*args):# int64,[]int32,mosek.fusion.Set
      self._ctor_alt_init_J_3ILmosek_4fusion_4Set_2(*args)
    elif self.__match_ctor_J_3I_3J(*args): # int64,[]int32,[]int64
      self._ctor_init_J_3I_3J(*args)
    elif self.__match_alt_ctor_J_3I_3J(*args):# int64,[]int32,[]int64
      self._ctor_alt_init_J_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IndexCounter.ctor(mosek.fusion.Set)\n\tmosek.fusion.IndexCounter.ctor(int64,array(int32,ndim=1),mosek.fusion.Set)\n\tmosek.fusion.IndexCounter.ctor(int64,array(int32,ndim=1),array(int64,ndim=1))')
  def getIndex(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_getIndex_(*args): # 
      return self._getIndex_(*args)
    elif mosek_fusion_IndexCounter._match_alt_getIndex_(*args): # 
      return self._getIndex_alt_(*args)
    else:
      raise ValueError('Invalid argument list getIndex('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.getIndex()')
  def inc(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_inc_(*args): # 
      return self._inc_(*args)
    elif mosek_fusion_IndexCounter._match_alt_inc_(*args): # 
      return self._inc_alt_(*args)
    else:
      raise ValueError('Invalid argument list inc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.inc()')
  def atEnd(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_atEnd_(*args): # 
      return self._atEnd_(*args)
    elif mosek_fusion_IndexCounter._match_alt_atEnd_(*args): # 
      return self._atEnd_alt_(*args)
    else:
      raise ValueError('Invalid argument list atEnd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.atEnd()')
  def reset(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_reset_(*args): # 
      return self._reset_(*args)
    elif mosek_fusion_IndexCounter._match_alt_reset_(*args): # 
      return self._reset_alt_(*args)
    else:
      raise ValueError('Invalid argument list reset('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.reset()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_get_(*args): # 
      return self._get_(*args)
    elif mosek_fusion_IndexCounter._match_alt_get_(*args): # 
      return self._get_alt_(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.get()')
  def next(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_next_(*args): # 
      return self._next_(*args)
    elif mosek_fusion_IndexCounter._match_alt_next_(*args): # 
      return self._next_alt_(*args)
    else:
      raise ValueError('Invalid argument list next('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.next()')
  def __repr__(self): return 'mosek.fusion.IndexCounter'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Set_2(shape):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_Lmosek_4fusion_4Set_2(shape)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(shape))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(shape))
  def _ctor_alt_init_Lmosek_4fusion_4Set_2(self,shape):
    self._ctor_init_Lmosek_4fusion_4Set_2(shape)
  def _ctor_init_Lmosek_4fusion_4Set_2(self,shape):
   object.__init__(self)
   self.__n = (shape.nd)
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   self.__start = 0
   self.__strides = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   for _0 in range(0,self.__n):
    self.__strides[_0] = shape._stride_I(_0)
   self.__dims = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   for _1 in range(0,self.__n):
    self.__dims[_1] = shape._dim_I(_1)
  @staticmethod
  def _ctor_J_3ILmosek_4fusion_4Set_2(start_,dims_,shape):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_J_3ILmosek_4fusion_4Set_2(start_,dims_,shape)
    return o
  @staticmethod
  def __match_ctor_J_3ILmosek_4fusion_4Set_2(*args):
    if len(args) != 3: return False
    start_,dims_,shape, = args
    return (__arg_match_J__(start_) and __arg_match__3I__(dims_) and __arg_match_Lmosek_4fusion_4Set_2__(shape))
  @staticmethod
  def __match_alt_ctor_J_3ILmosek_4fusion_4Set_2(*args):
    if len(args) != 3: return False
    start_,dims_,shape, = args
    return (__arg_alt_match_J__(start_) and __arg_alt_match__3I__(dims_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape))
  def _ctor_alt_init_J_3ILmosek_4fusion_4Set_2(self,start_,dims_,shape):
    self._ctor_init_J_3ILmosek_4fusion_4Set_2(numpy.int64(start_),numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),shape)
  def _ctor_init_J_3ILmosek_4fusion_4Set_2(self,start_,dims_,shape):
   assert dims_ is None or isinstance(dims_,numpy.ndarray)
   object.__init__(self)
   self.__n = int((dims_).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_53(self.__n,self.__st,start_) # src/fusion/CommonUtil.mbi:382:22-57
   self.__strides = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   for _0 in range(0,self.__n):
    self.__strides[_0] = shape._stride_I(_0)
   self.__dims = dims_
   self.__start = start_
  @staticmethod
  def _ctor_J_3I_3J(start_,dims_,strides_):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_J_3I_3J(start_,dims_,strides_)
    return o
  @staticmethod
  def __match_ctor_J_3I_3J(*args):
    if len(args) != 3: return False
    start_,dims_,strides_, = args
    return (__arg_match_J__(start_) and __arg_match__3I__(dims_) and __arg_match__3J__(strides_))
  @staticmethod
  def __match_alt_ctor_J_3I_3J(*args):
    if len(args) != 3: return False
    start_,dims_,strides_, = args
    return (__arg_alt_match_J__(start_) and __arg_alt_match__3I__(dims_) and __arg_alt_match__3J__(strides_))
  def _ctor_alt_init_J_3I_3J(self,start_,dims_,strides_):
    self._ctor_init_J_3I_3J(numpy.int64(start_),numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(strides_,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_J_3I_3J(self,start_,dims_,strides_):
   assert dims_ is None or isinstance(dims_,numpy.ndarray)
   assert strides_ is None or isinstance(strides_,numpy.ndarray)
   object.__init__(self)
   self.__n = int((dims_).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_54(self.__n,self.__st,start_) # src/fusion/CommonUtil.mbi:368:22-57
   self.__strides = strides_
   self.__dims = dims_
   self.__start = start_
  @staticmethod
  def _match_atEnd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_atEnd_(*args):
    if len(args) != 0: return False
    return True
  def _atEnd_alt_(self,):
    return self._atEnd_()
  def _atEnd_(self,):
   return ((self.__ii[(self.__n - 1)] >= self.__dims[(self.__n - 1)]))
  @staticmethod
  def _match_getIndex_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getIndex_(*args):
    if len(args) != 0: return False
    return True
  def _getIndex_alt_(self,):
    return self._getIndex_()
  def _getIndex_(self,):
   return (self.__ii)
  @staticmethod
  def _match_next_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_next_(*args):
    if len(args) != 0: return False
    return True
  def _next_alt_(self,):
    return self._next_()
  def _next_(self,):
   _0=self._get_()
   self._inc_()
   return numpy.int64(_0)
  @staticmethod
  def _match_get_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_(*args):
    if len(args) != 0: return False
    return True
  def _get_alt_(self,):
    return self._get_()
  def _get_(self,):
   return numpy.int64(self.__st[0])
  @staticmethod
  def _match_inc_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inc_(*args):
    if len(args) != 0: return False
    return True
  def _inc_alt_(self,):
    return self._inc_()
  def _inc_(self,):
   self.__ii[0] += 1
   self.__st[0] = (self.__st[0] + self.__strides[(self.__n - 1)])
   _0 = 0
   while ((_0 < (self.__n - 1)) and (self.__ii[_0]==self.__dims[((self.__n - _0) - 1)])):
    self.__ii[_0] = 0
    self.__ii[(_0 + 1)] += 1
    self.__st[(_0 + 1)] = (self.__st[(_0 + 1)] + self.__strides[((self.__n - _0) - 2)])
    _0 += 1
   fragments._c_closure_55(_0,self.__st) # src/fusion/CommonUtil.mbi:417:9-42
  @staticmethod
  def _match_reset_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_reset_(*args):
    if len(args) != 0: return False
    return True
  def _reset_alt_(self,):
    return self._reset_()
  def _reset_(self,):
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_56(self.__n,self.__st,self.__start) # src/fusion/CommonUtil.mbi:403:22-56
 return IndexCounter
mosek_fusion_IndexCounter=__mk_mosek_fusion_IndexCounter()
del __mk_mosek_fusion_IndexCounter
#BEFORE CLASS
def __mk_mosek_fusion_CommonTools():
 class CommonTools(object):
  @staticmethod
  def ndIncr(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_ndIncr__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return mosek_fusion_CommonTools._ndIncr__3I_3I_3I(*args)
    elif mosek_fusion_CommonTools._match_alt_ndIncr__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return mosek_fusion_CommonTools._ndIncr_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list ndIncr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.ndIncr(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def argQsort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_argQsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_CommonTools._argQsort__3J_3I_3IJJ(*args)
    elif mosek_fusion_CommonTools._match_alt_argQsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_CommonTools._argQsort_alt__3J_3I_3IJJ(*args)
    elif mosek_fusion_CommonTools._match_argQsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_CommonTools._argQsort__3J_3J_3JJJ(*args)
    elif mosek_fusion_CommonTools._match_alt_argQsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_CommonTools._argQsort_alt__3J_3J_3JJJ(*args)
    else:
      raise ValueError('Invalid argument list argQsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)')
  @staticmethod
  def argMSort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_argMSort__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_CommonTools._argMSort__3I_3I(*args)
    elif mosek_fusion_CommonTools._match_alt_argMSort__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_CommonTools._argMSort_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list argMSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.argMSort(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def tripletSort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._tripletSort_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    else:
      raise ValueError('Invalid argument list tripletSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.tripletSort(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)')
  @staticmethod
  def transposeTriplets(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args): # []int32,[]int32,[]double,[][]int64,[][]int64,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args): # []int32,[]int32,[]double,[][]int64,[][]int64,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets_alt__3I_3I_3D_3_3J_3_3J_3_3DJII(*args)
    else:
      raise ValueError('Invalid argument list transposeTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)\n\tmosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int64,ndim=1),ndim=1),array(array(int64,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)')
  def __repr__(self): return 'mosek.fusion.CommonTools'
  @staticmethod
  def _match_ndIncr__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_ndIncr__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _ndIncr_alt__3I_3I_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_CommonTools._ndIncr__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _ndIncr__3I_3I_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=(int((_0).shape[0]) - 1)
   _0[_3] += 1
   while ((_3 > 0) and (_0[_3] >= _2[_3])):
    _0[_3] = _1[_3]
    _0[(_3 - 1)] += 1
  @staticmethod
  def _match_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3J__(_3) and __arg_match__3_3J__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3J__(_3) and __arg_alt_match__3_3J__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _transposeTriplets_alt__3I_3I_3D_3_3J_3_3J_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int64))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int64))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   _9=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_57(_10,_6,_9,_0,_1) # src/fusion/CommonUtil.mbi:305:9-309:10
   fragments._c_closure_58(_7,_9) # src/fusion/CommonUtil.mbi:311:9-79
   fragments._c_closure_59(_10,_8) # src/fusion/CommonUtil.mbi:312:9-79
   _11=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _13=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_60(_10,_7,_9,_1,_11,_12,_13,_2) # src/fusion/CommonUtil.mbi:318:9-330:10
   _3[0] = _12
   _4[0] = _11
   _5[0] = _13
  @staticmethod
  def _match_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3I__(_3) and __arg_match__3_3I__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3I__(_3) and __arg_alt_match__3_3I__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _transposeTriplets_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int32))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int32))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   _9=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_61(_10,_6,_9,_0,_1) # src/fusion/CommonUtil.mbi:257:9-261:10
   fragments._c_closure_62(_7,_9) # src/fusion/CommonUtil.mbi:263:9-79
   fragments._c_closure_63(_10,_8) # src/fusion/CommonUtil.mbi:264:9-79
   _11=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _13=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_64(_10,_7,_9,_1,_11,_12,_13,_2) # src/fusion/CommonUtil.mbi:270:9-282:10
   _3[0] = _12
   _4[0] = _11
   _5[0] = _13
  @staticmethod
  def _match_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3I__(_3) and __arg_match__3_3I__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3I__(_3) and __arg_alt_match__3_3I__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _tripletSort_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int32))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int32))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   _9=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_65(_10,_6,_1) # src/fusion/CommonUtil.mbi:132:9-76
   fragments._c_closure_66(_10,_8) # src/fusion/CommonUtil.mbi:133:9-70
   fragments._c_closure_67(_9,_10,_6,_1) # src/fusion/CommonUtil.mbi:134:9-139:10
   _11=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_68(_6,_11,_0) # src/fusion/CommonUtil.mbi:145:9-83
   fragments._c_closure_69(_7,_11) # src/fusion/CommonUtil.mbi:146:9-79
   fragments._c_closure_70(_9,_10,_8,_12,_11,_0) # src/fusion/CommonUtil.mbi:147:9-155:10
   _13=1
   _13 = fragments._c_closure_71(_6,_13,_12,_0,_1) # src/fusion/CommonUtil.mbi:161:9-177:10
   _13 = numpy.int32(_13) # postprocess
   _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
   _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
   _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
   _17=_12[0]
   _14[0] = _0[_17]
   _15[0] = _1[_17]
   _16[0] = _2[_17]
   _18=1
   _18 = fragments._c_closure_72(_18,_6,_12,_0,_1,_14,_15,_16,_2) # src/fusion/CommonUtil.mbi:192:9-209:10
   _18 = numpy.int32(_18) # postprocess
   _3[0] = _14
   _4[0] = _15
   _5[0] = _16
  @staticmethod
  def _match_argMSort__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_argMSort__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _argMSort_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_CommonTools._argMSort__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argMSort__3I_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _3=False
   _4=1
   while (_4 < int((_0).shape[0])):
    _3 = (not _3)
    for _5 in range(0,int((_0).shape[0]),(_4 * 2)):
     if _3:
      mosek.fusion.CommonTools.__mergeInto__3I_3I_3IIII(_0,_2,_1,_5,(_5 + _4),(_5 + (2 * _4)))
     else:
      mosek.fusion.CommonTools.__mergeInto__3I_3I_3IIII(_2,_0,_1,_5,(_5 + _4),(_5 + (2 * _4)))
    _4 *= 2
   if _3:
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(_2,0,_0,0,int((_0).shape[0]))
  @staticmethod
  def __mergeInto_alt__3I_3I_3IIII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _1 = mosek_fusion_CommonTools.__mergeInto__3I_3I_3IIII(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mergeInto__3I_3I_3IIII(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _6=(int((_0).shape[0]) if ((_5 > int((_0).shape[0])) ) else _5)
   _7=(_6 if ((_4 > _6) ) else _4)
   if (_7==_6):
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(_0,_3,_1,_3,(_7 - _3))
   else:
    fragments._c_closure_73(_3,_7,_6,_0,_1,_2) # src/fusion/CommonUtil.mbi:42:9-53:10
  @staticmethod
  def _match_argQsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argQsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argQsort_alt__3J_3J_3JJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_CommonTools._argQsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argQsort__3J_3J_3JJJ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (_2 is None):
    mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_3,_4)
   else:
    mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argQsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argQsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argQsort_alt__3J_3I_3IJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_CommonTools._argQsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argQsort__3J_3I_3IJJ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (_2 is None):
    mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_3,_4)
   else:
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
 return CommonTools
mosek_fusion_CommonTools=__mk_mosek_fusion_CommonTools()
del __mk_mosek_fusion_CommonTools
#BEFORE CLASS
def __mk_mosek_fusion_SolutionStruct():
 class SolutionStruct(object):
  __slots__ = ['snx','sux','slx','bars','barx','y','suc','slc','xx','xc','dobj','pobj','probstatus','dstatus','pstatus','sol_numbarvar','sol_numcone','sol_numvar','sol_numcon']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4SolutionStruct_2(*args): # mosek.fusion.SolutionStruct
      self._ctor_init_Lmosek_4fusion_4SolutionStruct_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):# mosek.fusion.SolutionStruct
      self._ctor_alt_init_Lmosek_4fusion_4SolutionStruct_2(*args)
    elif self.__match_ctor_IIII(*args): # int32,int32,int32,int32
      self._ctor_init_IIII(*args)
    elif self.__match_alt_ctor_IIII(*args):# int32,int32,int32,int32
      self._ctor_alt_init_IIII(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SolutionStruct.ctor(mosek.fusion.SolutionStruct)\n\tmosek.fusion.SolutionStruct.ctor(int32,int32,int32,int32)')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_clone_(*args): # 
      return self._clone_(*args)
    elif mosek_fusion_SolutionStruct._match_alt_clone_(*args): # 
      return self._clone_alt_(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.clone()')
  def isDualAcceptable(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_SolutionStruct._match_alt_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isDualAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list isDualAcceptable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.isDualAcceptable(mosek.fusion.AccSolutionStatus)')
  def isPrimalAcceptable(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_SolutionStruct._match_alt_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isPrimalAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list isPrimalAcceptable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.isPrimalAcceptable(mosek.fusion.AccSolutionStatus)')
  def resize(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_resize_IIII(*args): # int32,int32,int32,int32
      return self._resize_IIII(*args)
    elif mosek_fusion_SolutionStruct._match_alt_resize_IIII(*args): # int32,int32,int32,int32
      return self._resize_alt_IIII(*args)
    else:
      raise ValueError('Invalid argument list resize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.resize(int32,int32,int32,int32)')
  def __repr__(self): return 'mosek.fusion.SolutionStruct'
  @staticmethod
  def _ctor_IIII(numvar,numcon,numcone,numbarvar):
    o = SolutionStruct.__new__(SolutionStruct)
    o._ctor_init_IIII(numvar,numcon,numcone,numbarvar)
    return o
  @staticmethod
  def __match_ctor_IIII(*args):
    if len(args) != 4: return False
    numvar,numcon,numcone,numbarvar, = args
    return (__arg_match_I__(numvar) and __arg_match_I__(numcon) and __arg_match_I__(numcone) and __arg_match_I__(numbarvar))
  @staticmethod
  def __match_alt_ctor_IIII(*args):
    if len(args) != 4: return False
    numvar,numcon,numcone,numbarvar, = args
    return (__arg_alt_match_I__(numvar) and __arg_alt_match_I__(numcon) and __arg_alt_match_I__(numcone) and __arg_alt_match_I__(numbarvar))
  def _ctor_alt_init_IIII(self,numvar,numcon,numcone,numbarvar):
    self._ctor_init_IIII(numpy.int32(numvar),numpy.int32(numcon),numpy.int32(numcone),numpy.int32(numbarvar))
  def _ctor_init_IIII(self,numvar,numcon,numcone,numbarvar):
   object.__init__(self)
   self.pobj = 0.0
   self.dobj = 0.0
   self.pstatus = mosek.fusion.SolutionStatus.Unknown
   self.dstatus = mosek.fusion.SolutionStatus.Unknown
   self.probstatus = mosek.fusion.ProblemStatus.Unknown
   self.sol_numvar = numvar
   self.sol_numcon = numcon
   self.sol_numcone = numcone
   self.sol_numbarvar = numbarvar
   self.slx = None
   self.sux = None
   self.xx = None
   self.slc = None
   self.suc = None
   self.y = None
   self.xc = None
   self.snx = None
   self.barx = None
   self.bars = None
   if (numvar > 0):
    self.slx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.sux = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.xx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
   if (numbarvar > 0):
    self.barx = numpy.zeros((numbarvar,), dtype=numpy.dtype(object))
    self.bars = numpy.zeros((numbarvar,), dtype=numpy.dtype(object))
   if (numcon > 0):
    self.slc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.suc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.y = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.xc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
   if (numcone > 0):
    self.snx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
  @staticmethod
  def _ctor_Lmosek_4fusion_4SolutionStruct_2(that):
    o = SolutionStruct.__new__(SolutionStruct)
    o._ctor_init_Lmosek_4fusion_4SolutionStruct_2(that)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_match_Lmosek_4fusion_4SolutionStruct_2__(that))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_alt_match_Lmosek_4fusion_4SolutionStruct_2__(that))
  def _ctor_alt_init_Lmosek_4fusion_4SolutionStruct_2(self,that):
    self._ctor_init_Lmosek_4fusion_4SolutionStruct_2(that)
  def _ctor_init_Lmosek_4fusion_4SolutionStruct_2(self,that):
   object.__init__(self)
   self.sol_numcon = (that.sol_numcon)
   self.sol_numvar = (that.sol_numvar)
   self.sol_numcone = (that.sol_numcone)
   self.sol_numbarvar = (that.sol_numbarvar)
   self.pstatus = (that.pstatus)
   self.dstatus = (that.dstatus)
   self.probstatus = (that.probstatus)
   self.pobj = (that.pobj)
   self.dobj = (that.dobj)
   self.xc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.xc)) if (((that.xc) is not None) ) else None)
   self.xx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.xx)) if (((that.xx) is not None) ) else None)
   self.slc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.slx)) if (((that.slc) is not None) ) else None)
   self.suc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.sux)) if (((that.suc) is not None) ) else None)
   self.y = (mosek.fusion.Utils.Tools._arraycopy__3D((that.y)) if (((that.y) is not None) ) else None)
   if ((that.barx) is not None):
    self.barx = _monty.initJaggedArray([mosek.fusion.Utils.Tools._arraycopy__3D((that.barx)[_0]) for _0 in range(0,int(((that.barx)).shape[0]))], 1)
   else:
    self.barx = None
   if ((that.bars) is not None):
    self.bars = _monty.initJaggedArray([mosek.fusion.Utils.Tools._arraycopy__3D((that.bars)[_1]) for _1 in range(0,int(((that.bars)).shape[0]))], 1)
   else:
    self.bars = None
   self.slx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.slx)) if (((that.slx) is not None) ) else None)
   self.sux = (mosek.fusion.Utils.Tools._arraycopy__3D((that.sux)) if (((that.sux) is not None) ) else None)
   self.snx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.snx)) if (((that.snx) is not None) ) else None)
  @staticmethod
  def _match_clone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clone_(*args):
    if len(args) != 0: return False
    return True
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_SolutionStruct._ctor_Lmosek_4fusion_4SolutionStruct_2(self))
  @staticmethod
  def _match_resize_IIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_resize_IIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3))
  def _resize_alt_IIII(self,_t__0,_t__1,_t__2,_t__3):
    return self._resize_IIII(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2),numpy.int32(__3))
  def _resize_IIII(self,_0,_1,_2,_3):
   if (_3 < 0):
    pass
   elif (_3 <= self.sol_numbarvar):
    self.sol_numbarvar = _3
   elif (_0 <= int((self.barx).shape[0])):
    for _4 in range(self.sol_numvar,_0):
     self.barx[_4] = None
     self.bars[_4] = None
   else:
    if ((self.sol_numbarvar * 2) > (_3 + 100)):
     _5 = (self.sol_numbarvar * 2)
    else:
     _5 = (_3 + 100)
    _6=numpy.zeros((_5,), dtype=numpy.dtype(object))
    for _7 in range(0,int((self.barx).shape[0])):
     _6[_7] = self.barx[_7]
    self.barx = _6
    _8=numpy.zeros((_5,), dtype=numpy.dtype(object))
    for _9 in range(0,int((self.bars).shape[0])):
     _8[_9] = self.bars[_9]
    self.bars = _8
    self.sol_numbarvar = _3
   if (_0 < 0):
    pass
   elif (_0 <= self.sol_numvar):
    self.sol_numvar = _0
   elif (_0 <= int((self.xx).shape[0])):
    self.sol_numvar = fragments._c_closure_74(_0,self.slx,self.sol_numvar,self.sux,self.xx) # src/fusion/Model.mbi:3519:11-3528:12
    self.sol_numvar = numpy.int32(self.sol_numvar) # postprocess
   else:
    if ((self.sol_numvar * 2) > (_0 + 100)):
     _10 = (self.sol_numvar * 2)
    else:
     _10 = (_0 + 100)
    _11=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.slx,0,_11,0,int((self.slx).shape[0]))
    self.slx = _11
    _12=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.sux,0,_12,0,int((self.sux).shape[0]))
    self.sux = _12
    _13=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.xx,0,_13,0,int((self.xx).shape[0]))
    self.xx = _13
    fragments._c_closure_75(_0,self.slx,self.sol_numvar,self.sux,self.xx) # src/fusion/Model.mbi:3548:15-3554:16
    self.sol_numvar = _0
   if (_1 < 0):
    pass
   elif (_1 <= self.sol_numcon):
    self.sol_numcon = _1
   elif (_1 <= int((self.xx).shape[0])):
    self.sol_numcon = fragments._c_closure_76(_1,self.slc,self.sol_numcon,self.suc,self.xc,self.y) # src/fusion/Model.mbi:3569:11-3580:12
    self.sol_numcon = numpy.int32(self.sol_numcon) # postprocess
   else:
    if ((self.sol_numcon * 2) > (_1 + 100)):
     _14 = (self.sol_numcon * 2)
    else:
     _14 = (_1 + 100)
    _15=numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.slc,0,_15,0,int((self.slc).shape[0]))
    self.slc = _15
    _16=numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.suc,0,_16,0,int((self.suc).shape[0]))
    self.suc = _16
    _17=numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.xc,0,_17,0,int((self.xc).shape[0]))
    self.xc = _17
    _18=numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.y,0,_18,0,int((self.y).shape[0]))
    self.y = _18
    fragments._c_closure_77(_1,self.slc,self.sol_numcon,self.suc,self.xc,self.y) # src/fusion/Model.mbi:3607:15-3613:16
    self.sol_numcon = _1
   if (_2 < 0):
    pass
   elif (_2 <= self.sol_numcone):
    self.sol_numcone = _2
   elif (_2 <= int((self.xx).shape[0])):
    self.sol_numcone = fragments._c_closure_78(_2,self.snx,self.sol_numcone) # src/fusion/Model.mbi:3629:11-3637:12
    self.sol_numcone = numpy.int32(self.sol_numcone) # postprocess
   else:
    if ((self.sol_numcone * 2) > (_2 + 100)):
     _19 = (self.sol_numcone * 2)
    else:
     _19 = (_2 + 100)
    _20=numpy.zeros((_19,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.snx,0,_20,0,int((self.snx).shape[0]))
    self.snx = _20
    fragments._c_closure_79(_2,self.snx,self.sol_numcone) # src/fusion/Model.mbi:3653:15-3657:16
    self.sol_numcone = _2
  @staticmethod
  def _match_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _isDualAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   return (self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self.dstatus,_0))
  @staticmethod
  def _match_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _isPrimalAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   return (self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self.pstatus,_0))
  def __isAcceptable_alt_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self,_t__0,_t__1):
    return self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(__0,__1)
  def __isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self,_0,_1):
   if (_1==mosek.fusion.AccSolutionStatus.Anything):
    return (True)
   elif (_1==mosek.fusion.AccSolutionStatus.Optimal):
    return ((_0==mosek.fusion.SolutionStatus.Optimal))
   elif (_1==mosek.fusion.AccSolutionStatus.NearOptimal):
    return (((_0==mosek.fusion.SolutionStatus.Optimal) or (_0==mosek.fusion.SolutionStatus.NearOptimal)))
   elif (_1==mosek.fusion.AccSolutionStatus.Feasible):
    return (((_0==mosek.fusion.SolutionStatus.Optimal) or ((_0==mosek.fusion.SolutionStatus.NearOptimal) or (_0==mosek.fusion.SolutionStatus.Feasible))))
   elif (_1==mosek.fusion.AccSolutionStatus.Certificate):
    return ((_0==mosek.fusion.SolutionStatus.Certificate))
   return (False)
 return SolutionStruct
mosek_fusion_SolutionStruct=__mk_mosek_fusion_SolutionStruct()
del __mk_mosek_fusion_SolutionStruct
#BEFORE CLASS
def __mk_mosek_fusion_ConNZStruct():
 class ConNZStruct(object):
  __slots__ = ['barmidx','barsubj','barsubi','bfix','cof','subj','ptrb']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3I_3D_3D_3I_3I_3I(*args): # []int64,[]int32,[]double,[]double,[]int32,[]int32,[]int32
      self._ctor_init__3J_3I_3D_3D_3I_3I_3I(*args)
    elif self.__match_alt_ctor__3J_3I_3D_3D_3I_3I_3I(*args):# []int64,[]int32,[]double,[]double,[]int32,[]int32,[]int32
      self._ctor_alt_init__3J_3I_3D_3D_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ConNZStruct.ctor(array(int64,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.ConNZStruct'
  @staticmethod
  def _ctor__3J_3I_3D_3D_3I_3I_3I(ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_):
    o = ConNZStruct.__new__(ConNZStruct)
    o._ctor_init__3J_3I_3D_3D_3I_3I_3I(ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_)
    return o
  @staticmethod
  def __match_ctor__3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_, = args
    return (__arg_match__3J__(ptrb_) and __arg_match__3I__(subj_) and __arg_match__3D__(cof_) and __arg_match__3D__(bfix_) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barmidx_))
  @staticmethod
  def __match_alt_ctor__3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_, = args
    return (__arg_alt_match__3J__(ptrb_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(cof_) and __arg_alt_match__3D__(bfix_) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barmidx_))
  def _ctor_alt_init__3J_3I_3D_3D_3I_3I_3I(self,ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_):
    self._ctor_init__3J_3I_3D_3D_3I_3I_3I(numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barmidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3J_3I_3D_3D_3I_3I_3I(self,ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_):
   assert ptrb_ is None or isinstance(ptrb_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   assert bfix_ is None or isinstance(bfix_,numpy.ndarray)
   assert barsubi_ is None or isinstance(barsubi_,numpy.ndarray)
   assert barsubj_ is None or isinstance(barsubj_,numpy.ndarray)
   assert barmidx_ is None or isinstance(barmidx_,numpy.ndarray)
   object.__init__(self)
   self.ptrb = ptrb_
   self.subj = subj_
   self.cof = cof_
   self.bfix = bfix_
   self.barsubi = barsubi_
   self.barsubj = barsubj_
   self.barmidx = barmidx_
 return ConNZStruct
mosek_fusion_ConNZStruct=__mk_mosek_fusion_ConNZStruct()
del __mk_mosek_fusion_ConNZStruct
#BEFORE CLASS
def __mk_mosek_fusion_BaseVariable():
 class BaseVariable(mosek_fusion_Variable,object):
  __slots__ = ['_model','_shape_p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Model,mosek.fusion.Set
      self._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args):# mosek.fusion.Model,mosek.fusion.Set
      self._ctor_alt_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.BaseVariable.ctor(mosek.fusion.Model,mosek.fusion.Set)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_BaseVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.make_continuous(array(int64,ndim=1))')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_BaseVariable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.dual()')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_BaseVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def antidiag(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_antidiag_(*args): # 
      return self._antidiag_(*args)
    elif mosek_fusion_BaseVariable._match_alt_antidiag_(*args): # 
      return self._antidiag_alt_(*args)
    elif mosek_fusion_BaseVariable._match_antidiag_I(*args): # int32
      return self._antidiag_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_antidiag_I(*args): # int32
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.antidiag()\n\tmosek.fusion.BaseVariable.antidiag(int32)')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_BaseVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_BaseVariable._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.size()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_BaseVariable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.index(int32)\n\tmosek.fusion.BaseVariable.index(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.index(int32,int32)\n\tmosek.fusion.BaseVariable.index(int32,int32,int32)')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_BaseVariable._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.level()')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_BaseVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.make_integer(array(int64,ndim=1))')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_BaseVariable._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.transpose()')
  def shape(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_shape_(*args): # 
      return self._shape_(*args)
    elif mosek_fusion_BaseVariable._match_alt_shape_(*args): # 
      return self._shape_alt_(*args)
    else:
      raise ValueError('Invalid argument list shape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.shape()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_BaseVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.toString()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.slice(int32,int32)\n\tmosek.fusion.BaseVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3I_3I(*args): # []int32,[]int32
      return self._pick__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I_3I(*args): # []int32,[]int32
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=2))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getModel()')
  def makeContinuous(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_makeContinuous_(*args): # 
      return self._makeContinuous_(*args)
    elif mosek_fusion_BaseVariable._match_alt_makeContinuous_(*args): # 
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.makeContinuous()')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_BaseVariable._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.asExpr()')
  def makeInteger(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_makeInteger_(*args): # 
      return self._makeInteger_(*args)
    elif mosek_fusion_BaseVariable._match_alt_makeInteger_(*args): # 
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.makeInteger()')
  def setLevel(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_setLevel__3D(*args): # []double
      return self._setLevel__3D(*args)
    elif mosek_fusion_BaseVariable._match_alt_setLevel__3D(*args): # []double
      return self._setLevel_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list setLevel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.setLevel(array(double,ndim=1))')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.BaseVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getShape()')
  def diag(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_diag_(*args): # 
      return self._diag_(*args)
    elif mosek_fusion_BaseVariable._match_alt_diag_(*args): # 
      return self._diag_alt_(*args)
    elif mosek_fusion_BaseVariable._match_diag_I(*args): # int32
      return self._diag_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_diag_I(*args): # int32
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.diag()\n\tmosek.fusion.BaseVariable.diag(int32)')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.BaseVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.BaseVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def __repr__(self): return 'mosek.fusion.BaseVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = BaseVariable.__new__(BaseVariable)
    o._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4BaseVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4BaseVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   object.__init__(self)
   self._model = m
   self._shape_p = (v._shape_p)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(m,shape):
    o = BaseVariable.__new__(BaseVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(m,shape)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    m,shape, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match_Lmosek_4fusion_4Set_2__(shape))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    m,shape, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,m,shape):
    self._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(m,shape)
  def _ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,m,shape):
   object.__init__(self)
   self._model = m
   self._shape_p = shape
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("Variable( (")._a_I(self._shape_p._dim_I(0))
   for _1 in range(1,(self._shape_p.nd)):
    _0._a_S(",")._a_I(self._shape_p._dim_I(_1))
   _0._a_S(" )")
   if ((self._shape_p._size) < 51):
    for _2 in range(0,(self._shape_p._size)):
     _0._a_S(",\n  ")
     self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(_2,_0)
   else:
    for _3 in range(0,25):
     _0._a_S(",\n  ")
     self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(_3,_0)
    _0._a_S("... (")._a_J(((self._shape_p._size) - 50))._a_S(" elements left out)")
    for _4 in range(((self._shape_p._size) - 25),(self._shape_p._size)):
     _0._a_S(",\n  ")
     self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(_4,_0)
   _0._a_S(" )")
   return (_0._toString_())
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   for _8 in range(_1,_2):
    self._inst_JJ_3I_3I_3I((_0[_8] - _3),((_4 + _8) - _1),_5,_6,_7)
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   pass
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _values_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._values_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_I_3DZ(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _5 in range(0,(self._shape_p.nd)):
    _3[_5] = self._shape_p._stride_I(_5)
   for _6 in range(0,(self._shape_p.nd)):
    _4[_6] = self._shape_p._dim_I(_6)
   self._values_J_3I_3JI_3DZ(0,_4,_3,_0,_1,_2)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   pass
  @staticmethod
  def _match_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setLevel_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setLevel__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setLevel__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((self._shape_p._size) > int((_0).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Invalid length of solution values vector")
   self._set_1values_J_3I_3JI_3DZ(0,numpy.array([self._shape_p._dim_I(_1) for _1 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32)),numpy.array([self._shape_p._stride_I(_2) for _2 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int64)),0,_0,True)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self._model)
  @staticmethod
  def _match_shape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_shape_(*args):
    if len(args) != 0: return False
    return True
  def _shape_alt_(self,):
    return self._shape_()
  def _shape_(self,):
   return (self._shape_p)
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (self._shape_p)
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int64((self._shape_p._size))
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros(((self._shape_p._size),), dtype=numpy.dtype(numpy.float64))
   if ((self._shape_p._size) > 0):
    self._values_I_3DZ(0,_0,False)
   return (_0)
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   _0=numpy.zeros(((self._shape_p._size),), dtype=numpy.dtype(numpy.float64))
   if ((self._shape_p._size) > 0):
    self._values_I_3DZ(0,_0,True)
   return (_0)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   self._make_1continuous__3J(numpy.array([_0 for _0 in range(0,self._size_())], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   self._make_1integer__3J(numpy.array([_0 for _0 in range(0,self._size_())], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   if ((self._shape_p.nd) > 2):
    raise mosek_fusion_DimensionError._ctor_S("Invalid shape for operation")
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,mosek.fusion.Set._make_II(self._shape_p._dim_I(1),self._shape_p._dim_I(0)),0,numpy.array([self._shape_p._stride_I(1),self._shape_p._stride_I(0)], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _index_alt_III(self,_t__0,_t__1,_t__2):
    return self._index_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _index_III(self,_0,_1,_2):
   return (self._index__3I(numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _index_alt_II(self,_t__0,_t__1):
    return self._index_II(numpy.int32(__0),numpy.int32(__1))
  def _index_II(self,_0,_1):
   return (self._index__3I(numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((self._shape_p.nd)!=int((_0).shape[0])):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   return (mosek_fusion_PickVariable._ctor_Lmosek_4fusion_4Variable_2_3J(self,numpy.array([self._shape_p._linearidx__3I(_0)], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   return (self._pick__3I(numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  def _pick_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I_3I(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((self._shape_p.nd)!=3):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   if ((int((_0).shape[0])!=int((_1).shape[0])) or (int((_0).shape[0])!=int((_2).shape[0]))):
    raise mosek_fusion_LengthError._ctor_S("Mismatching argument lengths")
   return (mosek_fusion_PickVariable._ctor_Lmosek_4fusion_4Variable_2_3J(self,numpy.array([self._shape_p._linearidx__3I(numpy.array([_0[_3],_1[_3],_2[_3]], dtype=numpy.dtype(numpy.int32))) for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _pick_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((self._shape_p.nd)!=2):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   if (int((_0).shape[0])!=int((_1).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching argument lengths")
   return (mosek_fusion_PickVariable._ctor_Lmosek_4fusion_4Variable_2_3J(self,numpy.array([self._shape_p._linearidx__3I(numpy.array([_0[_2],_1[_2]], dtype=numpy.dtype(numpy.int32))) for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((self._shape_p.nd)!=int((_0).shape[1])):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   return (mosek_fusion_PickVariable._ctor_Lmosek_4fusion_4Variable_2_3J(self,numpy.array([self._shape_p._linearidx__3I(numpy.array([_0[_1,_2] for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32))) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((self._shape_p.nd)!=1):
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   return (mosek_fusion_PickVariable._ctor_Lmosek_4fusion_4Variable_2_3J(self,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _antidiag_alt_I(self,_t__0):
    return self._antidiag_I(numpy.int32(__0))
  def _antidiag_I(self,_0):
   if ((self._shape_p.nd)!=2):
    raise mosek_fusion_DimensionError._ctor_S("antidiag() only works on two-dimensional objects")
   if (_0 >= 0):
    return (self.__general_1diag__3I_3I(numpy.array([0,((self._shape_p._dim_I(1) - 1) - _0)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32))))
   else:
    return (self.__general_1diag__3I_3I(numpy.array([(- _0),(self._shape_p._dim_I(1) - 1)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   if ((self._shape_p.nd)!=2):
    raise mosek_fusion_DimensionError._ctor_S("antidiag() only works on two-dimensional objects")
   return (self.__general_1diag__3I_3I(numpy.array([0,(self._shape_p._dim_I(1) - 1)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _diag_alt_I(self,_t__0):
    return self._diag_I(numpy.int32(__0))
  def _diag_I(self,_0):
   if ((self._shape_p.nd)!=2):
    raise mosek_fusion_DimensionError._ctor_S("diag() only works on two-dimensional objects")
   if (_0 >= 0):
    return (self.__general_1diag__3I_3I(numpy.array([0,_0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32))))
   else:
    return (self.__general_1diag__3I_3I(numpy.array([(- _0),0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   if ((self._shape_p.nd)!=2):
    raise mosek_fusion_DimensionError._ctor_S("diag() only works on two-dimensional objects")
   return (self.__general_1diag__3I_3I(numpy.array([0,0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32))))
  def __general_1diag_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self.__general_1diag__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __general_1diag__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (((self._shape_p.nd)!=int((_0).shape[0])) or ((self._shape_p.nd)!=int((_1).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Invalid start or step definition")
   for _2 in range(0,(self._shape_p.nd)):
    if ((_0[_2] < 0) or (_0[_2] >= self._shape_p._dim_I(_2))):
     raise mosek_fusion_LengthError._ctor_S("Start element is out of bounds")
   _3=0
   for _4 in range(0,(self._shape_p.nd)):
    _3 += (self._shape_p._stride_I(_4) * _0[_4])
   _5=numpy.array([(((((self._shape_p._dim_I(_6) - _0[_6]) - 1) // _1[_6]) + 1) if ((_1[_6] > 0) ) else (((_0[_6] // (- _1[_6])) + 1) if ((_1[_6] < 0) ) else 0)) for _6 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
   _7=_5[0]
   for _8 in range(1,(self._shape_p.nd)):
    _7 = (_7 if ((_7 < _5[_8]) ) else _5[_8])
   _9=0
   for _10 in range(0,(self._shape_p.nd)):
    _9 += (_1[_10] * self._shape_p._stride_I(_10))
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,mosek.fusion.Set._make_I(_7),_3,numpy.array([_9], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(numpy.array([_0 for _0 in range(0,((self._shape_p._size) + 1))], dtype=numpy.dtype(numpy.int64)),numpy.array([self], dtype=numpy.dtype(object)),numpy.array([_1 for _1 in range(0,(self._shape_p._size))], dtype=numpy.dtype(numpy.int64)),numpy.array([1.0 for _2 in range(0,(self._shape_p._size))], dtype=numpy.dtype(numpy.float64)),None,self._shape_p,None,1))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,mosek.fusion.Set._make__3I(numpy.array([(_1[_2] - _0[_2]) for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))),self._shape_p._linearidx__3I(_0),numpy.array([self._shape_p._stride_I(_3) for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,mosek.fusion.Set._make_I((_1 - _0)),_0,numpy.array([1], dtype=numpy.dtype(numpy.int64))))
 return BaseVariable
mosek_fusion_BaseVariable=__mk_mosek_fusion_BaseVariable()
del __mk_mosek_fusion_BaseVariable
#BEFORE CLASS
def __mk_mosek_fusion_CompoundVariable():
 class CompoundVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_CompoundVariable__stackdim','_CompoundVariable__varsb','_CompoundVariable__vars']
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.CompoundVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_CompoundVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.make_integer(array(int64,ndim=1))')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_CompoundVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_CompoundVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_CompoundVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.slice(int32,int32)\n\tmosek.fusion.CompoundVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_CompoundVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_CompoundVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_CompoundVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.CompoundVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_CompoundVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_CompoundVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.make_continuous(array(int64,ndim=1))')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_CompoundVariable._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.asExpr()')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_CompoundVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.CompoundVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.CompoundVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_CompoundVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_CompoundVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def __repr__(self): return 'mosek.fusion.CompoundVariable'
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Variable_2I(v,dim):
    o = CompoundVariable.__new__(CompoundVariable)
    o._ctor_init__3Lmosek_4fusion_4Variable_2I(v,dim)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    v,dim, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(v) and __arg_match_I__(dim))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    v,dim, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(v) and __arg_alt_match_I__(dim))
  def _ctor_alt_init__3Lmosek_4fusion_4Variable_2I(self,v,dim):
    self._ctor_init__3Lmosek_4fusion_4Variable_2I(numpy.array(v,dtype=numpy.dtype(object)),numpy.int32(dim))
  def _ctor_init__3Lmosek_4fusion_4Variable_2I(self,v,dim):
   assert v is None or isinstance(v,numpy.ndarray)
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,mosek.fusion.CompoundVariable.__model_1from_1var__3Lmosek_4fusion_4Variable_2(v),mosek.fusion.CompoundVariable.__compute_1shape__3Lmosek_4fusion_4Variable_2I(v,dim))
   _0=0
   _1=0
   for _2 in range(0,int((v).shape[0])):
    if ((v[_2]._getShape_()._size)==1):
     _0 += 1
     _1 += 1
    elif ((v[_2]._getShape_()._size) > 1):
     _0 += 1
     _1 += v[_2]._getShape_()._dim_I(dim)
   self.__vars = numpy.zeros((_0,), dtype=numpy.dtype(object))
   self.__varsb = numpy.zeros(((_0 + 1),), dtype=numpy.dtype(numpy.int32))
   self.__varsb[0] = 0
   self.__stackdim = dim
   _3=0
   for _4 in range(0,int((v).shape[0])):
    if ((v[_4]._getShape_()._size) > 0):
     self.__vars[_3] = v[_4]
     if ((v[_4]._getShape_()._size)==1):
      self.__varsb[(_3 + 1)] = (self.__varsb[_3] + 1)
     else:
      self.__varsb[(_3 + 1)] = (self.__varsb[_3] + v[_4]._getShape_()._dim_I(dim))
     _3 += 1
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _2=self._shape_p._idxtokey_J(_0)
   _3=0
   _3 = fragments._c_closure_80(_3,_2,self.__stackdim,self.__varsb) # src/fusion/CompoundVariable.mbi:620:20-60
   _3 = numpy.int32(_3) # postprocess
   _2[self.__stackdim] = (_2[self.__stackdim] - self.__varsb[_3])
   self.__vars[_3]._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self.__vars[_3]._getShape_()._linearidx__3I(_2),_1)
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _2=self._shape_p._idxtokey_J(_0)
   _3=0
   _3 = fragments._c_closure_81(_3,_2,self.__stackdim,self.__varsb) # src/fusion/CompoundVariable.mbi:608:20-60
   _3 = numpy.int32(_3) # postprocess
   _2[self.__stackdim] = (_2[self.__stackdim] - self.__varsb[_3])
   self.__vars[_3]._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self.__vars[_3]._getShape_()._linearidx__3I(_2),_1)
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _5=self._shape_p._idxtokey_J(_0)
   _6=0
   _6 = fragments._c_closure_82(_6,_5,self.__stackdim,self.__varsb) # src/fusion/CompoundVariable.mbi:595:20-60
   _6 = numpy.int32(_6) # postprocess
   _5[self.__stackdim] = (_5[self.__stackdim] - self.__varsb[_6])
   self.__vars[_6]._inst_JJ_3I_3I_3I(self.__vars[_6]._getShape_()._linearidx__3I(_5),_1,_2,_3,_4)
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=int((_2).shape[0])
   _7=_1[0]
   _7 = fragments._c_closure_83(_1,_7) # src/fusion/CompoundVariable.mbi:527:9-70
   _7 = numpy.int32(_7) # postprocess
   _8=numpy.array([_0 for _9 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _12[((self._shape_p.nd) - 1)] = 1
   for _13 in range(1,(self._shape_p.nd)):
    _12[(((self._shape_p.nd) - _13) - 1)] = (_12[((self._shape_p.nd) - _13)] * self._shape_p._dim_I(((self._shape_p.nd) - _13)))
   _14=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _15=numpy.zeros((1,), dtype=numpy.dtype(numpy.float64))
   for _16 in range(0,_7):
    _17=_8[0]
    for _18 in range(0,(self._shape_p.nd)):
     _11[_18] = numpy.int32((_17 // _12[_18]))
     _17 = (_17 - (numpy.int64(_11[_18]) * _12[_18]))
    _19=0
    _19 = fragments._c_closure_84(_11,self.__stackdim,self.__varsb,_19) # src/fusion/CompoundVariable.mbi:559:13-61
    _19 = numpy.int32(_19) # postprocess
    _11[self.__stackdim] = (_11[self.__stackdim] - self.__varsb[_19])
    _14[0] = self.__vars[_19]._getShape_()._linearidx__3I(_11)
    _15[0] = _4[(_3 + _16)]
    self.__vars[_19]._set_1values__3J_3DZ(_14,_15,_5)
    _10[0] += 1
    _8[0] = (_8[0] + _2[(_6 - 1)])
    _20=0
    _20 = 0
    while ((_20 < (_6 - 1)) and (_10[_20]==_1[_20])):
     _10[_20] = 0
     _10[(_20 + 1)] += 1
     _20 += 1
    fragments._c_closure_85(_20,_8) # src/fusion/CompoundVariable.mbi:576:13-577:28
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros((1,), dtype=numpy.dtype(numpy.float64))
   _5=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _6 in range(0,int((_0).shape[0])):
    _7=numpy.int64(_0[_6])
    for _8 in range(0,(self._shape_p.nd)):
     _5[_8] = numpy.int32((_7 // self._shape_p._stride_I(_8)))
     _7 = (_7 - (numpy.int64(_5[_8]) * self._shape_p._stride_I(_8)))
    _9=0
    _9 = fragments._c_closure_86(_5,self.__stackdim,self.__varsb,_9) # src/fusion/CompoundVariable.mbi:506:13-61
    _9 = numpy.int32(_9) # postprocess
    _5[self.__stackdim] = (_5[self.__stackdim] - self.__varsb[_9])
    _3[0] = self.__vars[_9]._getShape_()._linearidx__3I(_5)
    _4[0] = _1[_6]
    self.__vars[_9]._set_1values__3J_3DZ(_3,_4,_2)
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=int((_2).shape[0])
   _7=_1[0]
   _7 = fragments._c_closure_87(_1,_7) # src/fusion/CompoundVariable.mbi:428:9-59
   _7 = numpy.int32(_7) # postprocess
   _8=numpy.array([_0 for _9 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   for _13 in range(0,_7):
    _14=_8[0]
    for _15 in range(0,(self._shape_p.nd)):
     _11[(((self._shape_p.nd) - _15) - 1)] = numpy.int32((_14 % self._shape_p._dim_I((((self._shape_p.nd) - _15) - 1))))
     _14 /= self._shape_p._dim_I((((self._shape_p.nd) - _15) - 1))
    _16=0
    _16 = fragments._c_closure_88(_11,self.__stackdim,self.__varsb,_16) # src/fusion/CompoundVariable.mbi:457:13-61
    _16 = numpy.int32(_16) # postprocess
    _11[self.__stackdim] = (_11[self.__stackdim] - self.__varsb[_16])
    _12[0] = self.__vars[_16]._getShape_()._linearidx__3I(_11)
    self.__vars[_16]._values__3JI_3DZ(_12,(_3 + _13),_4,_5)
    _10[0] += 1
    _17=0
    _17 = 0
    while ((_17 < (_6 - 1)) and (_10[_17]==_1[((_6 - 1) - _17)])):
     _10[_17] = 0
     _10[(_17 + 1)] += 1
     _17 += 1
    _8[_17] += _2[((_6 - _17) - 1)]
    fragments._c_closure_89(_17,_8) # src/fusion/CompoundVariable.mbi:475:13-476:30
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _5=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _6 in range(0,int((_0).shape[0])):
    _7=numpy.int64(_0[_6])
    for _8 in range(0,(self._shape_p.nd)):
     _5[_8] = numpy.int32((_7 // self._shape_p._stride_I(_8)))
     _7 = (_7 - (numpy.int64(_5[_8]) * self._shape_p._stride_I(_8)))
    _9=0
    _9 = fragments._c_closure_90(_5,self.__stackdim,self.__varsb,_9) # src/fusion/CompoundVariable.mbi:410:13-61
    _9 = numpy.int32(_9) # postprocess
    _5[self.__stackdim] = (_5[self.__stackdim] - self.__varsb[_9])
    _4[0] = self.__vars[_9]._getShape_()._linearidx__3I(_5)
    self.__vars[_9]._values__3JI_3DZ(_4,(_1 + _6),_2,_3)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _2=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _3 in range(0,int((_0).shape[0])):
    _4=numpy.int64(_0[_3])
    for _5 in range(0,(self._shape_p.nd)):
     _2[_5] = numpy.int32((_4 // self._shape_p._stride_I(_5)))
     _4 = (_4 - (numpy.int64(_2[_5]) * self._shape_p._stride_I(_5)))
    _6=0
    _6 = fragments._c_closure_91(_2,self.__stackdim,self.__varsb,_6) # src/fusion/CompoundVariable.mbi:373:13-61
    _6 = numpy.int32(_6) # postprocess
    _2[self.__stackdim] = (_2[self.__stackdim] - self.__varsb[_6])
    _1[0] = self.__vars[_6]._getShape_()._linearidx__3I(_2)
    self.__vars[_6]._make_1continuous__3J(_1)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _2=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _3 in range(0,int((_0).shape[0])):
    _4=numpy.int64(_0[_3])
    for _5 in range(0,(self._shape_p.nd)):
     _2[_5] = numpy.int32((_4 // self._shape_p._stride_I(_5)))
     _4 = (_4 - (numpy.int64(_2[_5]) * self._shape_p._stride_I(_5)))
    _6=0
    _6 = fragments._c_closure_92(_2,self.__stackdim,self.__varsb,_6) # src/fusion/CompoundVariable.mbi:346:13-61
    _6 = numpy.int32(_6) # postprocess
    _2[self.__stackdim] = (_2[self.__stackdim] - self.__varsb[_6])
    _1[0] = self.__vars[_6]._getShape_()._linearidx__3I(_2)
    self.__vars[_6]._make_1integer__3J(_1)
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   _0=mosek.fusion.Utils.Tools._range_JJ(0,((self._shape_p._size) + 1))
   _1=mosek.fusion.Utils.Tools._ones_I(numpy.int32((self._shape_p._size)))
   _2=numpy.zeros(((self._shape_p._size),), dtype=numpy.dtype(numpy.int64))
   if (self.__stackdim < 1):
    for _3 in range(0,numpy.int32((self._shape_p._size))):
     _2[_3] = _3
   elif (self.__stackdim >= (self._shape_p.nd)):
    _4=0
    _5=(self.__vars[0]._getShape_()._size)
    for _6 in range(0,_5):
     for _7 in range(0,int((self.__vars).shape[0])):
      _2[_4] = ((_7 * _5) + _6)
      _4 += 1
   else:
    _8=1
    for _9 in range(0,self.__stackdim):
     _8 *= self._shape_p._dim_I(_9)
    _10=numpy.zeros((int((self.__vars).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _11=numpy.zeros(((int((self.__vars).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
    for _12 in range(1,(int((self.__vars).shape[0]) + 1)):
     _11[_12] = (_11[(_12 - 1)] + (self.__vars[(_12 - 1)]._getShape_()._size))
    _13=0
    for _14 in range(0,_8):
     _15=0
     for _16 in range(0,int((self.__vars).shape[0])):
      for _17 in range(0,self.__vars[_16]._getShape_()._stride_I((self.__stackdim - 1))):
       _2[_13] = ((_11[_16] + _10[_16]) + _17)
       _13 += 1
      _10[_16] += self.__vars[_16]._getShape_()._stride_I((self.__stackdim - 1))
   _18=numpy.array([self.__vars[_19] for _19 in range(0,int((self.__vars).shape[0]))], dtype=numpy.dtype(object))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_0,_18,_2,_1,None,self._shape_p,None,1))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (int((_0).shape[0])!=int((_1).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching array lengths")
   elif (int((_0).shape[0])!=(self._shape_p.nd)):
    raise mosek_fusion_SliceError._ctor_S("Slice has wrong number of dimensions")
   else:
    for _2 in range(0,int((_0).shape[0])):
     if ((_0[_2] < 0) or ((_0[_2] > _1[_2]) or (_1[_2] > self._shape_p._dim_I(_2)))):
      raise mosek_fusion_SliceError._ctor_S("Slice index is out of bounds")
   _3=False
   _3 = fragments._c_closure_93(_0,_3,_1) # src/fusion/CompoundVariable.mbi:197:9-201:10
   if _3:
    _4=int((_0).shape[0])
    _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_94(_0,_1,_4,_5) # src/fusion/CompoundVariable.mbi:206:11-210:30
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,mosek_fusion_NDSet._ctor__3I(_5),0,numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))))
   elif (int((_0).shape[0])==1):
    return (self._slice_II(_0[0],_1[0]))
   else:
    _6=(self._shape_p.nd)
    _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
    _8=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
    _9,_11,_10,_12 = fragments._c_closure_95(_0,_9,_11,_1,_10,_12,self.__stackdim,self.__varsb) # src/fusion/CompoundVariable.mbi:223:11-231:12
    _9 = numpy.int32(_9) # postprocess
    _11 = numpy.int32(_11) # postprocess
    _10 = numpy.int32(_10) # postprocess
    _12 = numpy.int32(_12) # postprocess
    fragments._c_closure_96(_0,_1,_6,_7,_8) # src/fusion/CompoundVariable.mbi:233:11-237:12
    if (_9==_11):
     _7[self.__stackdim] = _10
     _8[self.__stackdim] = _12
     return (self.__vars[_9]._slice__3I_3I(_7,_8))
    else:
     _13=numpy.zeros((((_11 - _9) + 1),), dtype=numpy.dtype(object))
     _7[self.__stackdim] = _10
     _8[self.__stackdim] = self.__vars[_9]._getShape_()._dim_I(self.__stackdim)
     _13[0] = self.__vars[_9]._slice__3I_3I(_7,_8)
     _7[self.__stackdim] = 0
     _8[self.__stackdim] = _12
     _13[(int((_13).shape[0]) - 1)] = self.__vars[_11]._slice__3I_3I(_7,_8)
     for _14 in range(1,(int((_13).shape[0]) - 1)):
      _7[self.__stackdim] = 0
      _8[self.__stackdim] = self.__vars[(_14 + _9)]._getShape_()._dim_I(self.__stackdim)
      _13[_14] = self.__vars[(_14 + _9)]._slice__3I_3I(_7,_8)
     return (mosek_fusion_CompoundVariable._ctor__3Lmosek_4fusion_4Variable_2I(_13,self.__stackdim))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if ((self._shape_p.nd)!=1):
    raise mosek_fusion_SliceError._ctor_S("Slice has wrong number of dimensions")
   elif (_0 > _1):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice range")
   elif ((_0 < 0) or (_1 > self._shape_p._dim_I(0))):
    raise mosek_fusion_SliceError._ctor_S("Slice index is out of bounds")
   if (_0==_1):
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,mosek_fusion_IntSet._ctor_I(0),0,numpy.array([0], dtype=numpy.dtype(numpy.int64))))
   _2,_4,_3,_5 = fragments._c_closure_97(_0,_2,_4,_1,_3,_5,self.__varsb) # src/fusion/CompoundVariable.mbi:149:9-157:10
   _2 = numpy.int32(_2) # postprocess
   _4 = numpy.int32(_4) # postprocess
   _3 = numpy.int32(_3) # postprocess
   _5 = numpy.int32(_5) # postprocess
   if (_2==_4):
    return (self.__vars[_2]._slice_II(_3,_5))
   else:
    _6=numpy.zeros((((_4 - _2) + 1),), dtype=numpy.dtype(object))
    if (_3 > 0):
     _6[0] = self.__vars[_2]._slice_II(_3,self.__vars[_2]._getShape_()._dim_I(0))
    else:
     _6[0] = self.__vars[_2]
    if (_5 < self.__vars[_4]._getShape_()._dim_I(0)):
     _6[(int((_6).shape[0]) - 1)] = self.__vars[_4]._slice_II(0,_5)
    else:
     _6[(int((_6).shape[0]) - 1)] = self.__vars[_4]
    _7=1
    while (_7 < (int((_6).shape[0]) - 1)):
     _6[_7] = self.__vars[(_2 + _7)]
     _7 += 1
    return (mosek_fusion_CompoundVariable._ctor__3Lmosek_4fusion_4Variable_2I(_6,0))
  @staticmethod
  def __compute_1shape_alt__3Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CompoundVariable.__compute_1shape__3Lmosek_4fusion_4Variable_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __compute_1shape__3Lmosek_4fusion_4Variable_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=_0[0]._getShape_()
   _3=0
   for _4 in range(0,int((_0).shape[0])):
    _5=_0[_4]
    if ((_5._getShape_()._size) > 0):
     if ((_5._getShape_().nd)!=(_2.nd)):
      raise mosek_fusion_DimensionError._ctor_S("Mismatching variable shape")
     for _6 in range(0,(_2.nd)):
      if ((_6!=_1) and (_2._dim_I(_6)!=_5._getShape_()._dim_I(_6))):
       raise mosek_fusion_DimensionError._ctor_S("Mismatching variable shape")
     _3 = (_3 + _5._getShape_()._dim_I(_1))
   if ((_2.nd)==1):
    return (mosek_fusion_IntSet._ctor_I(_3))
   else:
    _7=numpy.array([_2._dim_I(_8) for _8 in range(0,(_2.nd))], dtype=numpy.dtype(numpy.int32))
    _7[_1] = _3
    return (mosek_fusion_NDSet._ctor__3I(_7))
  @staticmethod
  def __model_1from_1var_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_CompoundVariable.__model_1from_1var__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __model_1from_1var__3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return ((None if (((_0 is None) or (int((_0).shape[0])==0)) ) else _0[0]._getModel_()))
 return CompoundVariable
mosek_fusion_CompoundVariable=__mk_mosek_fusion_CompoundVariable()
del __mk_mosek_fusion_CompoundVariable
#BEFORE CLASS
def __mk_mosek_fusion_RepeatVariable():
 class RepeatVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_RepeatVariable__d2','_RepeatVariable__d1','_RepeatVariable__d0','_RepeatVariable__dim','_RepeatVariable__count','_RepeatVariable__xsize','_RepeatVariable__xdims','_RepeatVariable__x']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      self._ctor_init_Lmosek_4fusion_4Variable_2II(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Variable_2II(*args):# mosek.fusion.Variable,int32,int32
      self._ctor_alt_init_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.RepeatVariable.ctor(mosek.fusion.Variable,int32,int32)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_RepeatVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_RepeatVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_RepeatVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.RepeatVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_RepeatVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_RepeatVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.RepeatVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_RepeatVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.make_integer(array(int64,ndim=1))')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_RepeatVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.make_continuous(array(int64,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_RepeatVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_RepeatVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RepeatVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.RepeatVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.RepeatVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def __repr__(self): return 'mosek.fusion.RepeatVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2II(x,dim,count):
    o = RepeatVariable.__new__(RepeatVariable)
    o._ctor_init_Lmosek_4fusion_4Variable_2II(x,dim,count)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    x,dim,count, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_I__(dim) and __arg_match_I__(count))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    x,dim,count, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_I__(dim) and __arg_alt_match_I__(count))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2II(self,x,dim,count):
    self._ctor_init_Lmosek_4fusion_4Variable_2II(x,numpy.int32(dim),numpy.int32(count))
  def _ctor_init_Lmosek_4fusion_4Variable_2II(self,x,dim,count):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,x._getModel_(),mosek.fusion.RepeatVariable.__compute_1shape_Lmosek_4fusion_4Variable_2II(x,dim,count))
   _0=x._getShape_()
   (self.__x) = x
   (self.__count) = count
   self.__xsize = _0._getSize_()
   if (dim >= 0):
    _1=(_0.nd)
    if (_1 <= dim):
     _1 = (dim + 1)
    (self.__dim) = dim
    (self.__xdims) = numpy.array([_0._dim_I(_2) for _2 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   else:
    (self.__dim) = 0
    self.__xdims = numpy.zeros((((_0.nd) + 1),), dtype=numpy.dtype(numpy.int32))
    self.__xdims[0] = 1
    for _3 in range(0,(_0.nd)):
     self.__xdims[(_3 + 1)] = _0._dim_I(_3)
   (self.__d0) = 1
   (self.__d1) = 1
   (self.__d2) = 1
   self.__d0 = fragments._c_closure_98(self.__d0,dim,self.__xdims) # src/fusion/RepeatVariable.monty:80:11-47
   self.__d0 = numpy.int64(self.__d0) # postprocess
   self.__d1 = (self.__xdims[(self.__dim)] * count)
   self.__d2 = fragments._c_closure_99(self.__d2,dim,self.__xdims) # src/fusion/RepeatVariable.monty:82:11-58
   self.__d2 = numpy.int64(self.__d2) # postprocess
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if (self.__dim==0):
    return (self.__x._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2((_0 % self.__xsize),_1))
   elif (self.__dim >= (self.__x._getShape_().nd)):
    return (self.__x._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2((_0 // self.__xsize),_1))
   else:
    _2=self.__d0
    _3=(self.__xdims[self.__dim] * self.__d2)
    _4=(_0 % _3)
    _5=(_0 // (_3 * self.__count))
    return (self.__x._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(((_5 * _3) + _4),_1))
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if (self.__dim==0):
    self.__x._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2((_0 % self.__xsize),_1)
   elif (self.__dim >= (self.__x._getShape_().nd)):
    self.__x._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2((_0 // self.__xsize),_1)
   else:
    _2=self.__d0
    _3=(self.__x._getShape_()._dim_I(self.__dim) * self.__d2)
    _4=(_0 % _3)
    _5=(_0 // (_3 * self.__count))
    self.__x._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(((_5 * _3) + _4),_1)
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if (self.__dim==0):
    self.__x._inst_JJ_3I_3I_3I((_0 % self.__xsize),_1,_2,_4,_3)
   elif ((self.__d1 * self.__d2)==1):
    self.__x._inst_JJ_3I_3I_3I((_0 // self.__count),_1,_2,_4,_3)
   else:
    _5=self.__d0
    _6=(self.__x._getShape_()._dim_I(self.__dim) * self.__d2)
    _7=(_0 % _6)
    _8=(_0 // (_6 * self.__count))
    self.__x._inst_JJ_3I_3I_3I(((_8 * _6) + _7),_1,_2,_4,_3)
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((int((_1).shape[0])!=(self._shape_p.nd)) or (int((_2).shape[0])!=(self._shape_p.nd))):
    raise mosek_fusion_IndexError._ctor_S("Lengths of nsize and strides are not correct")
   _6=int((_2).shape[0])
   _7=_1[0]
   _7 = fragments._c_closure_100(_1,_7) # src/fusion/RepeatVariable.monty:239:9-70
   _7 = numpy.int32(_7) # postprocess
   _8=numpy.array([_0 for _9 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _10=self._shape_p._idxtokey_J(_0)
   _11=numpy.zeros((_7,), dtype=numpy.dtype(numpy.float64))
   _12=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
   for _13 in range(0,_7):
    _11[_13] = _4[(_13 + _3)]
    _14=(_8[0] % self.__d2)
    _15=((_8[0] // self.__d2) % self.__xdims[self.__dim])
    _16=(_8[0] // (self.__d1 * self.__d2))
    _12[_13] = ((((_14 * self.__d2) + _15) * self.__xdims[self.__dim]) + _16)
    _10[0] += 1
    _8[0] = (_8[0] + _2[(_6 - 1)])
    _17=0
    while ((_17 < (_6 - 1)) and (_10[_17]==_1[_17])):
     _10[_17] = 0
     _10[(_17 + 1)] += 1
     _17 += 1
    fragments._c_closure_101(_17,_8) # src/fusion/RepeatVariable.monty:267:13-268:28
   self._set_1values__3J_3DZ(_12,_11,_5)
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (self.__dim==0):
    self.__x._set_1values__3J_3DZ(numpy.array([(_0[_3] % self.__xsize) for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_1,_2)
   elif ((self.__d1 * self.__d2)==1):
    self.__x._set_1values__3J_3DZ(numpy.array([(_0[_4] // self.__count) for _4 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_1,_2)
   else:
    _5=self.__d0
    _6=(self.__x._getShape_()._dim_I(self.__dim) * self.__d2)
    _7=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_102(self.__count,_6,_0,_7) # src/fusion/RepeatVariable.monty:215:11-220:12
    self.__x._set_1values__3J_3DZ(_7,_1,_2)
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((int((_1).shape[0])!=(self._shape_p.nd)) or (int((_2).shape[0])!=(self._shape_p.nd))):
    raise mosek_fusion_IndexError._ctor_S("Lengths of nsize and strides are not correct")
   _6=int((_2).shape[0])
   _7=_1[0]
   _7 = fragments._c_closure_103(_1,_7) # src/fusion/RepeatVariable.monty:168:9-70
   _7 = numpy.int32(_7) # postprocess
   _8=numpy.array([_0 for _9 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _10=self._shape_p._idxtokey_J(_0)
   _11=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
   for _12 in range(0,_7):
    _13=(_8[0] % self.__d2)
    _14=((_8[0] // self.__d2) % self.__xdims[self.__dim])
    _15=(_8[0] // (self.__d1 * self.__d2))
    _11[_12] = ((((_13 * self.__d2) + _14) * self.__xdims[self.__dim]) + _15)
    _10[0] += 1
    _8[0] = (_8[0] + _2[(_6 - 1)])
    _16=0
    while ((_16 < (_6 - 1)) and (_10[_16]==_1[_16])):
     _10[_16] = 0
     _10[(_16 + 1)] += 1
     _16 += 1
    fragments._c_closure_104(_16,_8) # src/fusion/RepeatVariable.monty:194:13-195:28
   self._values__3JI_3DZ(_11,_3,_4,_5)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (self.__d0==1):
    self.__x._values__3JI_3DZ(numpy.array([(_0[_4] % self.__xsize) for _4 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_1,_2,_3)
   elif ((self.__d1 * self.__d2)==1):
    self.__x._values__3JI_3DZ(numpy.array([(_0[_5] // self.__count) for _5 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_1,_2,_3)
   else:
    _6=self.__d0
    _7=(self.__x._getShape_()._dim_I(self.__dim) * self.__d2)
    _8=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_105(self.__count,_7,_0,_8) # src/fusion/RepeatVariable.monty:145:11-150:12
    self.__x._values__3JI_3DZ(_8,_1,_2,_3)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__d0==1):
    self.__x._make_1continuous__3J(numpy.array([(_0[_1] % self.__xsize) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
   elif ((self.__d1 * self.__d2)==1):
    self.__x._make_1continuous__3J(numpy.array([(_0[_2] // self.__count) for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
   else:
    _3=self.__d0
    _4=(self.__x._getShape_()._dim_I(self.__dim) * self.__d2)
    _5=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_106(self.__count,_4,_0,_5) # src/fusion/RepeatVariable.monty:120:11-125:12
    self.__x._make_1continuous__3J(_5)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__dim==0):
    self.__x._make_1integer__3J(numpy.array([(_0[_1] % self.__xsize) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
   elif ((self.__d1 * self.__d2)==1):
    self.__x._make_1integer__3J(numpy.array([(_0[_2] // self.__count) for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
   else:
    _3=self.__d0
    _4=(self.__x._getShape_()._dim_I(self.__dim) * self.__d2)
    _5=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_107(self.__count,_4,_0,_5) # src/fusion/RepeatVariable.monty:98:11-103:12
    self.__x._make_1integer__3J(_5)
  @staticmethod
  def __compute_1shape_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_RepeatVariable.__compute_1shape_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def __compute_1shape_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   _3=_0._getShape_()
   if (_1 >= 0):
    if (((_3.nd)==1) and (_1==0)):
     return (mosek.fusion.Set._make_I((_3._dim_I(0) * _2)))
    elif (_1 < (_3.nd)):
     _4=numpy.array([_3._dim_I(_5) for _5 in range(0,(_3.nd))], dtype=numpy.dtype(numpy.int32))
     _4[_1] *= _2
     return (mosek.fusion.Set._make__3I(_4))
    else:
     _6=numpy.zeros(((_1 + 1),), dtype=numpy.dtype(numpy.int32))
     for _7 in range(0,(_3.nd)):
      _6[_7] = _3._dim_I(_7)
     for _8 in range((_3.nd),_1):
      _6[_8] = 1
     _6[_1] = _2
     return (mosek.fusion.Set._make__3I(_6))
   else:
    _9=numpy.zeros((((_3.nd) + 1),), dtype=numpy.dtype(numpy.int32))
    _9[0] = _2
    for _10 in range(0,(_3.nd)):
     _9[(_10 + 1)] = _3._dim_I(_10)
    return (mosek.fusion.Set._make__3I(_9))
 return RepeatVariable
mosek_fusion_RepeatVariable=__mk_mosek_fusion_RepeatVariable()
del __mk_mosek_fusion_RepeatVariable
#BEFORE CLASS
def __mk_mosek_fusion_PickVariable():
 class PickVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_PickVariable__indexes','_PickVariable__origin']
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_PickVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_PickVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_PickVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_PickVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_PickVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_PickVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_PickVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.PickVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.PickVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_PickVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_PickVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_PickVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.slice(int32,int32)\n\tmosek.fusion.PickVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_PickVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.make_continuous(array(int64,ndim=1))')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_PickVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_PickVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_PickVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.PickVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_PickVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_PickVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_PickVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.PickVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_PickVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_PickVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PickVariable.make_integer(array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.PickVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2_3J(origin,idxs):
    o = PickVariable.__new__(PickVariable)
    o._ctor_init_Lmosek_4fusion_4Variable_2_3J(origin,idxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2_3J(*args):
    if len(args) != 2: return False
    origin,idxs, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(origin) and __arg_match__3J__(idxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2_3J(*args):
    if len(args) != 2: return False
    origin,idxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(origin) and __arg_alt_match__3J__(idxs))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2_3J(self,origin,idxs):
    self._ctor_init_Lmosek_4fusion_4Variable_2_3J(origin,numpy.array(idxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Variable_2_3J(self,origin,idxs):
   assert idxs is None or isinstance(idxs,numpy.ndarray)
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,origin._getModel_(),mosek.fusion.Set._make_I(int((idxs).shape[0])))
   (self.__origin) = origin
   _0=origin._getShape_()._getSize_()
   for _1 in range(0,int((idxs).shape[0])):
    if ((idxs[_1] < 0) or (idxs[_1] >= _0)):
     raise mosek_fusion_IndexError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Index (")._a_J(idxs[_1])._a_S(") is out of bounds")._toString_())
   (self.__indexes) = idxs
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   self.__origin._inst_JJ_3I_3I_3I(self.__indexes[_0],_1,_2,_3,_4)
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   self._set_1values__3J_3DZ(numpy.array([(_0 + (_2[0] * _6)) for _6 in range(0,_1[0])], dtype=numpy.dtype(numpy.int64)),(_4 if ((_3==0) ) else numpy.array([_4[(_7 + _3)] for _7 in range(0,_1[0])], dtype=numpy.dtype(numpy.float64))),_5)
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self.__origin._set_1values__3J_3DZ(numpy.array([self.__indexes[_0[_3]] for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_1,_2)
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   return (self.__origin._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self.__indexes[_0],_1))
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self.__origin._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self.__indexes[_0],_1)
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (mosek_fusion_PickVariable._ctor_Lmosek_4fusion_4Variable_2_3J(self.__origin,numpy.array([self.__indexes[_2] for _2 in range(_0,_1)], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=numpy.array([(_0 + (_7 * _2[0])) for _7 in range(0,_1[0])], dtype=numpy.dtype(numpy.int64))
   self._values__3JI_3DZ(_6,_3,_4,_5)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=numpy.array([self.__indexes[_0[_5]] for _5 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))
   self.__origin._values__3JI_3DZ(_4,_1,_2,_3)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   self.__origin._make_1continuous__3J(numpy.array([self.__indexes[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   self.__origin._make_1integer__3J(numpy.array([self.__indexes[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
 return PickVariable
mosek_fusion_PickVariable=__mk_mosek_fusion_PickVariable()
del __mk_mosek_fusion_PickVariable
#BEFORE CLASS
def __mk_mosek_fusion_SliceVariable():
 class SliceVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_SliceVariable__strides','_SliceVariable__first','_SliceVariable__origin']
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_SliceVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_SliceVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_SliceVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.slice(int32,int32)\n\tmosek.fusion.SliceVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_SliceVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.make_integer(array(int64,ndim=1))')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_SliceVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_SliceVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_SliceVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.SliceVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_SliceVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_SliceVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.SliceVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_SliceVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.SliceVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.SliceVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_SliceVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_SliceVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceVariable.make_continuous(array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.SliceVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(origin,shape,first,strides):
    o = SliceVariable.__new__(SliceVariable)
    o._ctor_init_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(origin,shape,first,strides)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(*args):
    if len(args) != 4: return False
    origin,shape,first,strides, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(origin) and __arg_match_Lmosek_4fusion_4Set_2__(shape) and __arg_match_J__(first) and __arg_match__3J__(strides))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(*args):
    if len(args) != 4: return False
    origin,shape,first,strides, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(origin) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape) and __arg_alt_match_J__(first) and __arg_alt_match__3J__(strides))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,origin,shape,first,strides):
    self._ctor_init_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(origin,shape,numpy.int64(first),numpy.array(strides,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,origin,shape,first,strides):
   assert strides is None or isinstance(strides,numpy.ndarray)
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,origin._getModel_(),shape)
   (self.__origin) = origin
   (self.__first) = first
   (self.__strides) = strides
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _5=self.__first
   _6=_0
   for _7 in range(0,(self._shape_p.nd)):
    _8=(_6 // self._shape_p._stride_I(_7))
    _6 = (_6 - (_8 * self._shape_p._stride_I(_7)))
    _5 = (_5 + (self.__strides[_7] * _8))
   self.__origin._inst_JJ_3I_3I_3I(_5,_1,_2,_3,_4)
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((_0==0) and ((int((_1).shape[0])==1) and ((_1[0]==(self._shape_p._size)) and (_2[0]==1)))):
    _6=numpy.array([self._shape_p._dim_I(_7) for _7 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
    self.__origin._set_1values_J_3I_3JI_3DZ(self.__first,_6,self.__strides,_3,_4,_5)
   else:
    _8=int((_1).shape[0])
    _9=(_8==(self._shape_p.nd))
    _10=0
    while ((_10 < _8) and _9):
     _9 = (_2[_10]==self._shape_p._stride_I(_10))
     _10 += 1
    if _9:
     _11=self.__first
     _12=_0
     for _13 in range(0,((self._shape_p.nd) - 1)):
      _14=(_12 // _2[_13])
      _12 = (_12 - (_2[_13] * _14))
      _11 = (_11 + (self._shape_p._stride_I(_13) * _14))
     self.__origin._set_1values_J_3I_3JI_3DZ(_11,_1,self.__strides,_3,_4,_5)
    else:
     _15=1
     _15 = fragments._c_closure_108(_1,_15) # src/fusion/SliceVariable.mbi:331:33-96
     _15 = numpy.int64(_15) # postprocess
     _16=numpy.zeros((_15,), dtype=numpy.dtype(numpy.int64))
     _17=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
     _18=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int64))
     for _19 in range(0,_15):
      _16[_19] = (self.__origin._getShape_()._linearidx__3I(self._shape_p._idxtokey_J((_0 + _18[0]))) + self.__first)
      _20=0
      _17[0] += 1
      _18[0] = (_18[0] + _2[(_8 - 1)])
      while ((_20 < (_8 - 1)) and (_17[_20] >= _1[((_8 - _20) - 1)])):
       _18[(_20 + 1)] = (_18[(_20 + 1)] + _2[((_8 - _20) - 2)])
       _17[_20] = 0
       _17[(_20 + 1)] += 1
       _20 += 1
      fragments._c_closure_109(_20,_18) # src/fusion/SliceVariable.mbi:352:20-55
     self.__origin._set_1values__3J_3DZ(_16,(_4 if ((_3==0) ) else numpy.array([_4[(_21 + _3)] for _21 in range(0,_15)], dtype=numpy.dtype(numpy.float64))),_5)
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _4 in range(0,int((_0).shape[0])):
    _5=self._shape_p._idxtokey_J(_0[_4])
    _6=self.__first
    for _7 in range(0,(self._shape_p.nd)):
     _6 = (_6 + (numpy.int64(_5[_7]) * self.__strides[_7]))
    _3[_4] = _6
   self.__origin._set_1values__3J_3DZ(_3,_1,_2)
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _2=self.__first
   _3=_0
   for _4 in range(0,(self._shape_p.nd)):
    _5=(_3 // self._shape_p._stride_I(_4))
    _3 = (_3 - (_5 * self._shape_p._stride_I(_4)))
    _2 = (_2 + (self.__strides[_4] * _5))
   self.__origin._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(_2,_1)
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _2=self.__first
   _3=_0
   for _4 in range(0,(self._shape_p.nd)):
    _5=(_3 // self._shape_p._stride_I(_4))
    _3 = (_3 - (_5 * self._shape_p._stride_I(_4)))
    _2 = (_2 + (self.__strides[_4] * _5))
   self.__origin._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_2,_1)
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=self._shape_p._slice__3I_3I(_0,_1)
   _3=self.__first
   _3 = fragments._c_closure_110(_0,_3,self.__strides) # src/fusion/SliceVariable.mbi:215:9-216:56
   _3 = numpy.int64(_3) # postprocess
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self.__origin,_2,_3,self.__strides))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self.__origin,self._shape_p._slice_II(_0,_1),(self.__first + numpy.int64(_0)),self.__strides))
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((_0==0) and ((int((_1).shape[0])==1) and ((_1[0]==(self._shape_p._size)) and (_2[0]==1)))):
    _6=numpy.array([self._shape_p._dim_I(_7) for _7 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
    self.__origin._values_J_3I_3JI_3DZ(self.__first,_6,self.__strides,_3,_4,_5)
   else:
    _8=int((_1).shape[0])
    _9=(_8==(self._shape_p.nd))
    _10=0
    while ((_10 < _8) and _9):
     _9 = (_2[_10]==self._shape_p._stride_I(_10))
     _10 += 1
    if _9:
     _11=self.__first
     _12=_0
     for _13 in range(0,((self._shape_p.nd) - 1)):
      _14=(_12 // _2[_13])
      _12 = (_12 - (_2[_13] * _14))
      _11 = (_11 + (self._shape_p._stride_I(_13) * _14))
     self.__origin._values_J_3I_3JI_3DZ(_11,_1,self.__strides,_3,_4,_5)
    else:
     _15=1
     _15 = fragments._c_closure_111(_1,_15) # src/fusion/SliceVariable.mbi:168:33-96
     _15 = numpy.int64(_15) # postprocess
     _16=numpy.zeros((_15,), dtype=numpy.dtype(numpy.int64))
     _17=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
     _18=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int64))
     for _19 in range(0,_15):
      _16[_19] = (self.__origin._getShape_()._linearidx__3I(self._shape_p._idxtokey_J((_0 + _18[0]))) + self.__first)
      _20=0
      _17[0] += 1
      _18[0] = (_18[0] + _2[(_8 - 1)])
      while ((_20 < (_8 - 1)) and (_17[_20] >= _1[((_8 - _20) - 1)])):
       _18[(_20 + 1)] = (_18[(_20 + 1)] + _2[((_8 - _20) - 2)])
       _17[_20] = 0
       _17[(_20 + 1)] += 1
       _20 += 1
      fragments._c_closure_112(_20,_18) # src/fusion/SliceVariable.mbi:189:20-55
     self.__origin._values__3JI_3DZ(_16,_3,_4,_5)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _5 in range(0,int((_0).shape[0])):
    _6=self._shape_p._idxtokey_J(_0[_5])
    _7=self.__first
    for _8 in range(0,(self._shape_p.nd)):
     _7 = (_7 + (numpy.int64(_6[_8]) * self.__strides[_8]))
    _4[_5] = _7
   self.__origin._values__3JI_3DZ(_4,_1,_2,_3)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _2 in range(0,int((_0).shape[0])):
    _3=self._shape_p._idxtokey_J(_0[_2])
    _4=self.__first
    for _5 in range(0,(self._shape_p.nd)):
     _4 = (_4 + (numpy.int64(_3[_5]) * self.__strides[_5]))
    _1[_2] = _4
   self.__origin._make_1continuous__3J(_1)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _2 in range(0,int((_0).shape[0])):
    _3=self._shape_p._idxtokey_J(_0[_2])
    _4=self.__first
    for _5 in range(0,(self._shape_p.nd)):
     _4 = (_4 + (numpy.int64(_3[_5]) * self.__strides[_5]))
    _1[_2] = _4
   self.__origin._make_1integer__3J(_1)
 return SliceVariable
mosek_fusion_SliceVariable=__mk_mosek_fusion_SliceVariable()
del __mk_mosek_fusion_SliceVariable
#BEFORE CLASS
def __mk_mosek_fusion_BoundInterfaceVariable():
 class BoundInterfaceVariable(mosek_fusion_SliceVariable):
  __slots__ = ['_BoundInterfaceVariable__originvar','_BoundInterfaceVariable__islower']
  def __repr__(self): return 'mosek.fusion.BoundInterfaceVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(origin_,shape_,first_,strides_,islower_):
    o = BoundInterfaceVariable.__new__(BoundInterfaceVariable)
    o._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(origin_,shape_,first_,strides_,islower_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(*args):
    if len(args) != 5: return False
    origin_,shape_,first_,strides_,islower_, = args
    return (__arg_match_Lmosek_4fusion_4RangedVariable_2__(origin_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match_J__(first_) and __arg_match__3J__(strides_) and __arg_match_Z__(islower_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(*args):
    if len(args) != 5: return False
    origin_,shape_,first_,strides_,islower_, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(origin_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match_J__(first_) and __arg_alt_match__3J__(strides_) and __arg_alt_match_Z__(islower_))
  def _ctor_alt_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(self,origin_,shape_,first_,strides_,islower_):
    self._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(origin_,shape_,numpy.int64(first_),numpy.array(strides_,dtype=numpy.dtype(numpy.int64)),islower_)
  def _ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(self,origin_,shape_,first_,strides_,islower_):
   assert strides_ is None or isinstance(strides_,numpy.ndarray)
   mosek_fusion_SliceVariable._ctor_init_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,origin_,shape_,first_,strides_)
   self.__originvar = origin_
   self.__islower = islower_
  def _slice_1_alt_Lmosek_4fusion_4Set_2J_3J(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self._slice_1_Lmosek_4fusion_4Set_2J_3J(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice_1_Lmosek_4fusion_4Set_2J_3J(self,_0,_1,_2):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(self.__originvar,_0,_1,_2,self.__islower))
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if self.__islower:
    self.__originvar._dual_1l_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   else:
    self.__originvar._dual_1u_J_3I_3JI_3D(_0,_1,_2,_3,_4)
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if self.__islower:
    self.__originvar._dual_1l__3JI_3D(_0,_1,_2)
   else:
    self.__originvar._dual_1u__3JI_3D(_0,_1,_2)
 return BoundInterfaceVariable
mosek_fusion_BoundInterfaceVariable=__mk_mosek_fusion_BoundInterfaceVariable()
del __mk_mosek_fusion_BoundInterfaceVariable
#BEFORE CLASS
def __mk_mosek_fusion_ModelVariable():
 class ModelVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_varid','_name']
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_ModelVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_ModelVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_ModelVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_ModelVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_ModelVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_ModelVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelVariable.slice(int32,int32)\n\tmosek.fusion.ModelVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.ModelVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = ModelVariable.__new__(ModelVariable)
    o._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4ModelVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self._name = (v._name)
   self._varid = (v._varid)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(model_,name_,shape_p,varid_):
    o = ModelVariable.__new__(ModelVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(model_,name_,shape_p,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(*args):
    if len(args) != 4: return False
    model_,name_,shape_p,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(*args):
    if len(args) != 4: return False
    model_,name_,shape_p,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,shape_p,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(model_,name_,shape_p,numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,shape_p,varid_):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,model_,shape_p)
   self._name = name_
   self._varid = varid_
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _1._a_S(("_" if ((int(len(self._name))==0) ) else self._name))._a_S("[")._a_S(self._shape_p._indexToString_J(_0))._a_S("]")
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (int((_0).shape[0])!=int((_1).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching array lengths")
   _2=self._shape_p._slice__3I_3I(_0,_1)
   _3=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _3[((self._shape_p.nd) - 1)] = 1
   _4=((self._shape_p.nd) - 1)
   while (_4 > 0):
    _3[(_4 - 1)] = (_3[_4] * self._shape_p._dim_I(_4))
    _4 = (_4 - 1)
   _5=0
   _5 = fragments._c_closure_113(_0,_5,_3) # src/fusion/ModelVariable.mbi:76:9-77:57
   _5 = numpy.int64(_5) # postprocess
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,_2,_5,_3))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if ((self._shape_p.nd)!=1):
    raise mosek_fusion_DimensionError._ctor_S("Wrong size of slice")
   _2=numpy.array([1], dtype=numpy.dtype(numpy.int64))
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(self,self._shape_p._slice_II(_0,_1),numpy.int64(_0),_2))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   pass
 return ModelVariable
mosek_fusion_ModelVariable=__mk_mosek_fusion_ModelVariable()
del __mk_mosek_fusion_ModelVariable
#BEFORE CLASS
def __mk_mosek_fusion_SymRangedVariable():
 class SymRangedVariable(mosek_fusion_SymmetricVariable,mosek_fusion_ModelVariable):
  __slots__ = ['_dim','_SymRangedVariable__names_flushed','_SymRangedVariable__nativeidxs','_SymRangedVariable__dom','_SymRangedVariable__idxmap']
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_SymRangedVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymRangedVariable.make_continuous(array(int64,ndim=1))')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_SymRangedVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymRangedVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.SymRangedVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_SymRangedVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymRangedVariable.make_integer(array(int64,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SymRangedVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymRangedVariable.toString()')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_SymRangedVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_SymRangedVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymRangedVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.SymRangedVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_SymRangedVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_SymRangedVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymRangedVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.SymRangedVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.SymRangedVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def __repr__(self): return 'mosek.fusion.SymRangedVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = SymRangedVariable.__new__(SymRangedVariable)
    o._ctor_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4SymRangedVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymRangedVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__nativeidxs = (numpy.array([(v.__nativeidxs)[_0] for _0 in range(0,int(((v.__nativeidxs)).shape[0]))], dtype=numpy.dtype(numpy.int32)) if (((v.__nativeidxs) is not None) ) else None)
   self.__idxmap = ((v.__idxmap)._clone_() if (((v.__idxmap) is not None) ) else None)
   self.__dom = (v.__dom)
   (self._dim) = (v._dim)
   self.__names_flushed = (v.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(model_,name_,dom_,dim,nativeidxs_,varid_):
    o = SymRangedVariable.__new__(SymRangedVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(model_,name_,dom_,dim,nativeidxs_,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(*args):
    if len(args) != 6: return False
    model_,name_,dom_,dim,nativeidxs_,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(dom_) and __arg_match_I__(dim) and __arg_match__3I__(nativeidxs_) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(*args):
    if len(args) != 6: return False
    model_,name_,dom_,dim,nativeidxs_,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(dom_) and __arg_alt_match_I__(dim) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(self,model_,name_,dom_,dim,nativeidxs_,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(model_,name_,dom_,numpy.int32(dim),numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4RangeDomain_2I_3IJ(self,model_,name_,dom_,dim,nativeidxs_,varid_):
   assert nativeidxs_ is None or isinstance(nativeidxs_,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,mosek.fusion.Set._make_II(dim,dim),varid_)
   (self._dim) = dim
   self.__nativeidxs = nativeidxs_
   if (nativeidxs_ is None):
    self.__idxmap = mosek.fusion.Utils.IntMap()
   else:
    self.__idxmap = None
   self.__dom = dom_
   self.__names_flushed = False
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("RangedVariable(")
   if (int(len(self._name)) > 0):
    _0._a_S("'")._a_S(self._name)._a_S("',")
   _0._a_I(self._shape_p._dim_I(0))
   for _1 in range(1,(self._shape_p.nd)):
    _0._a_S(",")._a_I(self._shape_p._dim_I(_1))
   _0._a_S(") )")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    if (self.__nativeidxs is not None):
     for _0 in range(0,int((self.__nativeidxs).shape[0])):
      self._model._varname_IS(self.__nativeidxs[_0],mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_0))._a_S("]")._toString_())
    else:
     _1=self.__idxmap._keys_()
     _2=self.__idxmap._values_()
     for _3 in range(0,int((_1).shape[0])):
      self._model._varname_IS(_2[_3],mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_3))._a_S("]")._toString_())
    self.__names_flushed = True
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   if (self.__nativeidxs is not None):
    for _8 in range(_1,_2):
     _5[((_4 + _8) - _1)] = self.__nativeidxs[self.__tril_1lin_1idx_J((_0[_8] - _3))]
   else:
    for _9 in range(_1,_2):
     _10=self.__tril_1lin_1idx_J((_0[_9] - _3))
     _11=self.__tril_1idx_J((_0[_9] - _3))
     if (not self.__idxmap._hasItem_J(_10)):
      _12=self._model._append_1rangedvar_Lmosek_4fusion_4ModelVariable_2JDD(self,_11,self.__dom._get_1lb_1item_J(_11),self.__dom._get_1ub_1item_J(_11))
      self.__idxmap._setItem_JI(_11,_12)
      _5[((_4 + _9) - _1)] = _12
      self.__names_flushed = False
     else:
      _5[((_4 + _9) - _1)] = self.__idxmap._getItem_J(_11)
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _5=self.__tril_1lin_1idx_J(_0)
   _6=self.__tril_1idx_J(_0)
   if (self.__nativeidxs is not None):
    _2[_1] = self.__nativeidxs[_5]
   else:
    if (not self.__idxmap._hasItem_J(_6)):
     _7=self
     _8=self._model._append_1rangedvar_Lmosek_4fusion_4ModelVariable_2JDD(_7,_5,self.__dom._get_1lb_1item_J(_6),self.__dom._get_1ub_1item_J(_6))
     self.__idxmap._setItem_JI(_6,_8)
     _2[_1] = _8
     self.__names_flushed = False
    else:
     _2[_1] = self.__idxmap._getItem_J(_6)
  def _dual_1u_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_114(_6,_1,_5) # src/fusion/SymRangedVariable.mbi:516:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _9 in range(0,_5):
     _10=self.__nativeidxs[self.__tril_1lin_1idx_J(_7._get_())]
     _4[(_9 + _3)] = _8[_10]
     _7._inc_()
   else:
    _11=self._model._getPrimalSolutionStatus_()
    for _12 in range(0,numpy.int32(_5)):
     _13=self.__tril_1idx_J(_7._get_())
     if self.__idxmap._hasItem_J(_13):
      _14=self.__idxmap._getItem_J(_13)
      _4[_12] = _8[_14]
     else:
      if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _12)] = self.__dom._get_1ub_1item_J(_13)
      else:
       _4[(_3 + _12)] = 0.0
     _7._inc_()
  def _dual_1u_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    for _4 in range(0,int((_0).shape[0])):
     _5=self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_4])]
     _2[(_1 + _4)] = _3[_5]
   else:
    _6=self._model._getPrimalSolutionStatus_()
    for _7 in range(0,int((_0).shape[0])):
     _8=self.__tril_1idx_J(_0[_7])
     if self.__idxmap._hasItem_J(_8):
      _9=self.__idxmap._getItem_J(_8)
      _2[(_1 + _7)] = _3[_9]
     else:
      if ((_6==mosek.fusion.SolutionStatus.Optimal) or ((_6==mosek.fusion.SolutionStatus.NearOptimal) or ((_6==mosek.fusion.SolutionStatus.Feasible) or (_6==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _7)] = self.__dom._get_1ub_1item_J(_8)
      else:
       _2[(_1 + _7)] = 0.0
  def _dual_1l_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_115(_6,_1,_5) # src/fusion/SymRangedVariable.mbi:426:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _9 in range(0,_5):
     _10=self.__nativeidxs[self.__tril_1lin_1idx_J(_7._get_())]
     _4[(_9 + _3)] = _8[_10]
     _7._inc_()
   else:
    _11=self._model._getPrimalSolutionStatus_()
    for _12 in range(0,numpy.int32(_5)):
     _13=self.__tril_1idx_J(_7._get_())
     if self.__idxmap._hasItem_J(_13):
      _14=self.__idxmap._getItem_J(_13)
      _4[_12] = _8[_14]
     else:
      if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _12)] = self.__dom._get_1ub_1item_J(_13)
      else:
       _4[(_3 + _12)] = 0.0
     _7._inc_()
  def _dual_1l_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    for _4 in range(0,int((_0).shape[0])):
     _5=self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_4])]
     _2[(_1 + _4)] = _3[_5]
   else:
    _6=self._model._getPrimalSolutionStatus_()
    for _7 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_7]):
      _8=self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_7])]
      _2[(_1 + _7)] = _3[_8]
     else:
      if ((_6==mosek.fusion.SolutionStatus.Optimal) or ((_6==mosek.fusion.SolutionStatus.NearOptimal) or ((_6==mosek.fusion.SolutionStatus.Feasible) or (_6==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _7)] = self.__dom._get_1ub_1item_J(self.__tril_1idx_J(_0[_7]))
      else:
       _2[(_1 + _7)] = 0.0
  def __dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _9=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_116(_6,_1,_5) # src/fusion/SymRangedVariable.mbi:340:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _10 in range(0,_5):
     _11=self.__nativeidxs[self.__tril_1lin_1idx_J(_7._get_())]
     _4[(_10 + _3)] = (_8[_11] - _9[_11])
     _7._inc_()
   else:
    _12=self._model._getPrimalSolutionStatus_()
    for _13 in range(0,numpy.int32(_5)):
     if self.__idxmap._hasItem_J(_7._get_()):
      _14=self.__idxmap._getItem_J(self.__tril_1idx_J(_7._get_()))
      _4[_13] = (_8[_14] - _9[_14])
     else:
      if ((_12==mosek.fusion.SolutionStatus.Optimal) or ((_12==mosek.fusion.SolutionStatus.NearOptimal) or ((_12==mosek.fusion.SolutionStatus.Feasible) or (_12==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _13)] = self.__dom._get_1ub_1item_J(self.__tril_1idx_J(_7._get_()))
      else:
       _4[(_3 + _13)] = 0.0
     _7._inc_()
  def __dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    for _5 in range(0,int((_0).shape[0])):
     _6=self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_5])]
     _2[(_1 + _5)] = (_3[_6] - _4[_6])
   else:
    _7=self._model._getPrimalSolutionStatus_()
    for _8 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(self.__tril_1idx_J(_0[_8])):
      _9=self.__idxmap._getItem_J(self.__tril_1idx_J(_0[_8]))
      _2[(_1 + _8)] = (_3[_9] - _4[_9])
     else:
      if ((_7==mosek.fusion.SolutionStatus.Optimal) or ((_7==mosek.fusion.SolutionStatus.NearOptimal) or ((_7==mosek.fusion.SolutionStatus.Feasible) or (_7==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _8)] = self.__dom._get_1ub_1item_J(self.__tril_1idx_J(_0[_8]))
      else:
       _2[(_1 + _8)] = 0.0
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _6 = fragments._c_closure_117(_7,_1,_6) # src/fusion/SymRangedVariable.mbi:264:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     _9=int((self.__nativeidxs).shape[0])
     _10=numpy.array([self.__nativeidxs[self.__tril_1lin_1idx_J(_8._next_())] for _11 in range(0,_6)], dtype=numpy.dtype(numpy.int32))
     _12=(numpy.array([_4[(_3 + _13)] for _13 in range(0,_9)], dtype=numpy.dtype(numpy.float64)) if ((_3 > 0) ) else _4)
     self._model._setSolution_1xx__3I_3D(_10,_12)
    else:
     _14=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
     for _15 in range(0,_6):
      self._inst_JJ_3I_3I_3I(_8._next_(),_15,_14,None,None)
     _16=numpy.array([_4[(_3 + _17)] for _17 in range(0,_6)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_14,_16)
   else:
    pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if _2:
    if (self.__nativeidxs is not None):
     _3=int((self.__nativeidxs).shape[0])
     _4=numpy.array([self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_5])] for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
     _6=numpy.array([_1[_7] for _7 in range(0,_3)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_4,_6)
    else:
     _8=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
     for _9 in range(0,int((_0).shape[0])):
      self._inst_JJ_3I_3I_3I(_0[_9],_9,_8,None,None)
     _10=numpy.array([_1[_11] for _11 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_8,_10)
   else:
    pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _9=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _6 = fragments._c_closure_118(_7,_1,_6) # src/fusion/SymRangedVariable.mbi:183:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     for _10 in range(0,_6):
      _4[(_10 + _3)] = _9[self.__nativeidxs[self.__tril_1lin_1idx_J(_8._get_())]]
      _8._inc_()
    else:
     _11=self._model._getPrimalSolutionStatus_()
     for _12 in range(0,numpy.int32(_6)):
      if self.__idxmap._hasItem_J(_8._get_()):
       _4[_12] = _9[self.__idxmap._getItem_J(self.__tril_1idx_J(_8._get_()))]
      else:
       if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
        _4[(_3 + _12)] = self.__dom._get_1lb_1item_J(self.__tril_1idx_J(_8._get_()))
       else:
        _4[(_3 + _12)] = 0.0
      _8._inc_()
   else:
    self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if _3:
    _4=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    if (self.__nativeidxs is not None):
     for _5 in range(0,int((_0).shape[0])):
      _2[(_1 + _5)] = _4[self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_5])]]
    else:
     _6=self._model._getPrimalSolutionStatus_()
     if ((_6==mosek.fusion.SolutionStatus.Optimal) or ((_6==mosek.fusion.SolutionStatus.NearOptimal) or ((_6==mosek.fusion.SolutionStatus.Feasible) or (_6==mosek.fusion.SolutionStatus.NearFeasible)))):
      for _7 in range(0,int((_0).shape[0])):
       _8=_0[_7]
       if self.__idxmap._hasItem_J(_8):
        _2[(_1 + _7)] = _4[self.__idxmap._getItem_J(_8)]
       else:
        _2[(_1 + _7)] = self.__dom._get_1lb_1item_J(_8)
     else:
      for _9 in range(0,int((_0).shape[0])):
       if self.__idxmap._hasItem_J(_0[_9]):
        _2[(_1 + _9)] = _4[self.__idxmap._getItem_J(_0[_9])]
       else:
        _2[(_1 + _9)] = 0.0
   else:
    self.__dual_1values__3JI_3D(_0,_1,_2)
  def __tril_1idx_alt_J(self,_t__0):
    return self.__tril_1idx_J(numpy.int64(__0))
  def __tril_1idx_J(self,_0):
   _1=(_0 // self._dim)
   _2=(_0 % self._dim)
   if (_2 > _1):
    return numpy.int64(((_2 * self._dim) + _1))
   else:
    return numpy.int64(_0)
  def __tril_1lin_1idx_alt_J(self,_t__0):
    return self.__tril_1lin_1idx_J(numpy.int64(__0))
  def __tril_1lin_1idx_J(self,_0):
   _1=(_0 // self._dim)
   _2=(_0 % self._dim)
   if (_2 > _1):
    return numpy.int64((((_2 * (_2 + 1)) // 2) + _1))
   else:
    return numpy.int64((((_1 * (_1 + 1)) // 2) + _2))
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putcontlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putcontlist__3I(_2)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putintlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putintlist__3I(_2)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_SymRangedVariable._ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return SymRangedVariable
mosek_fusion_SymRangedVariable=__mk_mosek_fusion_SymRangedVariable()
del __mk_mosek_fusion_SymRangedVariable
#BEFORE CLASS
def __mk_mosek_fusion_RangedVariable():
 class RangedVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_RangedVariable__names_flushed','_RangedVariable__nativeidxs','_RangedVariable__dom','_RangedVariable__idxmap']
  def values(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.RangedVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.RangedVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_RangedVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.RangedVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def upperBoundVar(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_upperBoundVar_(*args): # 
      return self._upperBoundVar_(*args)
    elif mosek_fusion_RangedVariable._match_alt_upperBoundVar_(*args): # 
      return self._upperBoundVar_alt_(*args)
    else:
      raise ValueError('Invalid argument list upperBoundVar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.upperBoundVar()')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_RangedVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.make_continuous(array(int64,ndim=1))')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_RangedVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_RangedVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_RangedVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.RangedVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_RangedVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_RangedVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.make_integer(array(int64,ndim=1))')
  def lowerBoundVar(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_lowerBoundVar_(*args): # 
      return self._lowerBoundVar_(*args)
    elif mosek_fusion_RangedVariable._match_alt_lowerBoundVar_(*args): # 
      return self._lowerBoundVar_alt_(*args)
    else:
      raise ValueError('Invalid argument list lowerBoundVar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.lowerBoundVar()')
  def __repr__(self): return 'mosek.fusion.RangedVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = RangedVariable.__new__(RangedVariable)
    o._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4RangedVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__dom = (v.__dom)
   self.__idxmap = ((v.__idxmap)._clone_() if (((v.__idxmap) is not None) ) else None)
   self.__nativeidxs = (numpy.array([(v.__nativeidxs)[_0] for _0 in range(0,int(((v.__nativeidxs)).shape[0]))], dtype=numpy.dtype(numpy.int32)) if (((v.__nativeidxs) is not None) ) else None)
   self.__names_flushed = (v.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(model_,name_,shape_p,dom_,nativeidxs_,varid_):
    o = RangedVariable.__new__(RangedVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(model_,name_,shape_p,dom_,nativeidxs_,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(*args):
    if len(args) != 6: return False
    model_,name_,shape_p,dom_,nativeidxs_,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(dom_) and __arg_match__3I__(nativeidxs_) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(*args):
    if len(args) != 6: return False
    model_,name_,shape_p,dom_,nativeidxs_,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(dom_) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(self,model_,name_,shape_p,dom_,nativeidxs_,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(model_,name_,shape_p,dom_,numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3IJ(self,model_,name_,shape_p,dom_,nativeidxs_,varid_):
   assert nativeidxs_ is None or isinstance(nativeidxs_,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,shape_p,varid_)
   self.__nativeidxs = nativeidxs_
   if (nativeidxs_ is None):
    self.__idxmap = mosek.fusion.Utils.IntMap()
   else:
    self.__idxmap = None
   self.__dom = dom_
   self.__names_flushed = False
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   self.__dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   return (_1)
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    if (self.__nativeidxs is not None):
     for _0 in range(0,int((self.__nativeidxs).shape[0])):
      self._model._varname_IS(self.__nativeidxs[_0],mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_0))._a_S("]")._toString_())
    else:
     _1=self.__idxmap._keys_()
     _2=self.__idxmap._values_()
     for _3 in range(0,int((_1).shape[0])):
      self._model._varname_IS(_2[_3],mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_3))._a_S("]")._toString_())
    self.__names_flushed = True
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   if (self.__nativeidxs is not None):
    fragments._c_closure_119(_5,_4,_1,_0,_3,_2,self.__nativeidxs) # src/fusion/RangedVariable.mbi:592:9-595:10
   else:
    for _8 in range(_1,_2):
     if (not self.__idxmap._hasItem_J(_0[(numpy.int64(_8) - _3)])):
      _9=self._model._append_1rangedvar_Lmosek_4fusion_4ModelVariable_2JDD(self,_0[(_8 - _3)],self.__dom._get_1lb_1item_J(_0[(_8 - _3)]),self.__dom._get_1ub_1item_J(_0[(_8 - _3)]))
      self.__idxmap._setItem_JI(_0[(_8 - _3)],_9)
      _5[((_4 + _8) - _1)] = _9
      self.__names_flushed = False
     else:
      _5[((_4 + _8) - _1)] = self.__idxmap._getItem_J(_0[(numpy.int64(_8) - _3)])
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   if (self.__nativeidxs is not None):
    _2[_1] = self.__nativeidxs[_0]
   else:
    if (not self.__idxmap._hasItem_J(_0)):
     _5=self
     _6=self._model._append_1rangedvar_Lmosek_4fusion_4ModelVariable_2JDD(_5,_0,self.__dom._get_1lb_1item_J(_0),self.__dom._get_1ub_1item_J(_0))
     self.__idxmap._setItem_JI(_0,_6)
     _2[_1] = _6
     self.__names_flushed = False
    else:
     _2[_1] = self.__idxmap._getItem_J(_0)
  @staticmethod
  def _match_upperBoundVar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_upperBoundVar_(*args):
    if len(args) != 0: return False
    return True
  def _upperBoundVar_alt_(self,):
    return self._upperBoundVar_()
  def _upperBoundVar_(self,):
   _0=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _0[((self._shape_p.nd) - 1)] = 1
   _1=((self._shape_p.nd) - 1)
   while (_1 > 0):
    _0[(_1 - 1)] = (_0[_1] * numpy.int64(self._shape_p._dim_I(_1)))
    _1 -= 1
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(self,self._shape_p,0,_0,False))
  @staticmethod
  def _match_lowerBoundVar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_lowerBoundVar_(*args):
    if len(args) != 0: return False
    return True
  def _lowerBoundVar_alt_(self,):
    return self._lowerBoundVar_()
  def _lowerBoundVar_(self,):
   _0=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _0[((self._shape_p.nd) - 1)] = 1
   _1=((self._shape_p.nd) - 1)
   while (_1 > 0):
    _0[(_1 - 1)] = (_0[_1] * self._shape_p._dim_I(_1))
    _1 -= 1
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Set_2J_3JZ(self,self._shape_p,0,_0,True))
  def _dual_1u_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_120(_6,_1,_5) # src/fusion/RangedVariable.mbi:482:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _9 in range(0,_5):
     _10=self.__nativeidxs[_7._get_()]
     _4[(_9 + _3)] = _8[_10]
     _7._inc_()
   else:
    _11=self._model._getPrimalSolutionStatus_()
    for _12 in range(0,numpy.int32(_5)):
     if self.__idxmap._hasItem_J(_7._get_()):
      _13=self.__idxmap._getItem_J(_7._get_())
      _4[_12] = _8[_13]
     else:
      if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _12)] = self.__dom._get_1ub_1item_J(_7._get_())
      else:
       _4[(_3 + _12)] = 0.0
     _7._inc_()
  def _dual_1u_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    fragments._c_closure_121(_0,self.__nativeidxs,_1,_3,_2) # src/fusion/RangedVariable.mbi:442:11-446:12
   else:
    _4=self._model._getPrimalSolutionStatus_()
    for _5 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_5]):
      _6=self.__idxmap._getItem_J(_0[_5])
      _2[(_1 + _5)] = _3[_6]
     else:
      if ((_4==mosek.fusion.SolutionStatus.Optimal) or ((_4==mosek.fusion.SolutionStatus.NearOptimal) or ((_4==mosek.fusion.SolutionStatus.Feasible) or (_4==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _5)] = self.__dom._get_1ub_1item_J(_0[_5])
      else:
       _2[(_1 + _5)] = 0.0
  def _dual_1l_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_122(_6,_1,_5) # src/fusion/RangedVariable.mbi:396:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _9 in range(0,_5):
     _10=self.__nativeidxs[_7._get_()]
     _4[(_9 + _3)] = _8[_10]
     _7._inc_()
   else:
    _11=self._model._getPrimalSolutionStatus_()
    for _12 in range(0,numpy.int32(_5)):
     if self.__idxmap._hasItem_J(_7._get_()):
      _13=self.__idxmap._getItem_J(_7._get_())
      _4[_12] = _8[_13]
     else:
      if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _12)] = self.__dom._get_1ub_1item_J(_7._get_())
      else:
       _4[(_3 + _12)] = 0.0
     _7._inc_()
  def _dual_1l_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    fragments._c_closure_123(_0,self.__nativeidxs,_1,_3,_2) # src/fusion/RangedVariable.mbi:357:11-361:12
   else:
    _4=self._model._getPrimalSolutionStatus_()
    for _5 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_5]):
      _6=self.__idxmap._getItem_J(_0[_5])
      _2[(_1 + _5)] = _3[_6]
     else:
      if ((_4==mosek.fusion.SolutionStatus.Optimal) or ((_4==mosek.fusion.SolutionStatus.NearOptimal) or ((_4==mosek.fusion.SolutionStatus.Feasible) or (_4==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _5)] = self.__dom._get_1ub_1item_J(_0[_5])
      else:
       _2[(_1 + _5)] = 0.0
  def __dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _9=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_124(_6,_1,_5) # src/fusion/RangedVariable.mbi:310:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _10 in range(0,_5):
     _11=self.__nativeidxs[_7._get_()]
     _4[(_10 + _3)] = (_8[_11] - _9[_11])
     _7._inc_()
   else:
    _12=self._model._getPrimalSolutionStatus_()
    for _13 in range(0,numpy.int32(_5)):
     if self.__idxmap._hasItem_J(_7._get_()):
      _14=self.__idxmap._getItem_J(_7._get_())
      _4[_13] = (_8[_14] - _9[_14])
     else:
      if ((_12==mosek.fusion.SolutionStatus.Optimal) or ((_12==mosek.fusion.SolutionStatus.NearOptimal) or ((_12==mosek.fusion.SolutionStatus.Feasible) or (_12==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _13)] = self.__dom._get_1ub_1item_J(_7._get_())
      else:
       _4[(_3 + _13)] = 0.0
     _7._inc_()
  def __dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    fragments._c_closure_125(_0,self.__nativeidxs,_1,_3,_4,_2) # src/fusion/RangedVariable.mbi:270:11-274:12
   else:
    _5=self._model._getPrimalSolutionStatus_()
    for _6 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_6]):
      _7=self.__idxmap._getItem_J(_0[_6])
      _2[(_1 + _6)] = (_3[_7] - _4[_7])
     else:
      if ((_5==mosek.fusion.SolutionStatus.Optimal) or ((_5==mosek.fusion.SolutionStatus.NearOptimal) or ((_5==mosek.fusion.SolutionStatus.Feasible) or (_5==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _6)] = self.__dom._get_1ub_1item_J(_0[_6])
      else:
       _2[(_1 + _6)] = 0.0
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _6 = fragments._c_closure_126(_7,_1,_6) # src/fusion/RangedVariable.mbi:233:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     _9=int((self.__nativeidxs).shape[0])
     _10=numpy.array([self.__nativeidxs[_8._next_()] for _11 in range(0,_6)], dtype=numpy.dtype(numpy.int32))
     _12=(numpy.array([_4[(_3 + _13)] for _13 in range(0,_9)], dtype=numpy.dtype(numpy.float64)) if ((_3 > 0) ) else _4)
     self._model._setSolution_1xx__3I_3D(_10,_12)
    else:
     _14=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
     for _15 in range(0,_6):
      self._inst_JJ_3I_3I_3I(_8._next_(),_15,_14,None,None)
     _16=numpy.array([_4[(_3 + _17)] for _17 in range(0,_6)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_14,_16)
   else:
    pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if _2:
    if (self.__nativeidxs is not None):
     _3=int((self.__nativeidxs).shape[0])
     _4=numpy.array([self.__nativeidxs[_0[_5]] for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
     _6=numpy.array([_1[_7] for _7 in range(0,_3)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_4,_6)
    else:
     _8=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
     for _9 in range(0,int((_0).shape[0])):
      self._inst_JJ_3I_3I_3I(_0[_9],_9,_8,None,None)
     _10=numpy.array([_1[_11] for _11 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_8,_10)
   else:
    pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _9=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _6 = fragments._c_closure_127(_7,_1,_6) # src/fusion/RangedVariable.mbi:153:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     for _10 in range(0,_6):
      _4[(_10 + _3)] = _9[self.__nativeidxs[_8._get_()]]
      _8._inc_()
    else:
     _11=self._model._getPrimalSolutionStatus_()
     for _12 in range(0,numpy.int32(_6)):
      if self.__idxmap._hasItem_J(_8._get_()):
       _4[_12] = _9[self.__idxmap._getItem_J(_8._get_())]
      else:
       if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
        _4[(_3 + _12)] = self.__dom._get_1ub_1item_J(_8._get_())
       else:
        _4[(_3 + _12)] = 0.0
      _8._inc_()
   else:
    self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if _3:
    _4=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    if (self.__nativeidxs is not None):
     fragments._c_closure_128(_0,self.__nativeidxs,_1,_2,_4) # src/fusion/RangedVariable.mbi:113:13-114:58
    else:
     _5=self._model._getPrimalSolutionStatus_()
     for _6 in range(0,int((_0).shape[0])):
      if self.__idxmap._hasItem_J(_0[_6]):
       _2[(_1 + _6)] = _4[self.__idxmap._getItem_J(_0[_6])]
      else:
       if ((_5==mosek.fusion.SolutionStatus.Optimal) or ((_5==mosek.fusion.SolutionStatus.NearOptimal) or ((_5==mosek.fusion.SolutionStatus.Feasible) or (_5==mosek.fusion.SolutionStatus.NearFeasible)))):
        _2[(_1 + _6)] = self.__dom._get_1ub_1item_J(_0[_6])
       else:
        _2[(_1 + _6)] = 0.0
   else:
    self.__dual_1values__3JI_3D(_0,_1,_2)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putcontlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putcontlist__3I(_2)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putintlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putintlist__3I(_2)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_RangedVariable._ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return RangedVariable
mosek_fusion_RangedVariable=__mk_mosek_fusion_RangedVariable()
del __mk_mosek_fusion_RangedVariable
#BEFORE CLASS
def __mk_mosek_fusion_LinearPSDVariable():
 class LinearPSDVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_LinearPSDVariable__numcones','_LinearPSDVariable__coneidx','_LinearPSDVariable__conesize','_LinearPSDVariable__sdpvardim','_LinearPSDVariable__blocksize']
  def values(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.LinearPSDVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.LinearPSDVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_LinearPSDVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.LinearPSDVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.make_integer(array(int64,ndim=1))')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.make_continuous(array(int64,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.toString()')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.LinearPSDVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def __repr__(self): return 'mosek.fusion.LinearPSDVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = LinearPSDVariable.__new__(LinearPSDVariable)
    o._ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearPSDVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__blocksize = (v.__blocksize)
   self.__conesize = (v.__conesize)
   self.__coneidx = (v.__coneidx)
   self.__sdpvardim = (v.__sdpvardim)
   self.__numcones = (v.__numcones)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(model_,name_,n,shp_,coneidx_,varid_):
    o = LinearPSDVariable.__new__(LinearPSDVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(model_,name_,n,shp_,coneidx_,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(*args):
    if len(args) != 6: return False
    model_,name_,n,shp_,coneidx_,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_I__(n) and __arg_match_Lmosek_4fusion_4Set_2__(shp_) and __arg_match_I__(coneidx_) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(*args):
    if len(args) != 6: return False
    model_,name_,n,shp_,coneidx_,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_I__(n) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shp_) and __arg_alt_match_I__(coneidx_) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(self,model_,name_,n,shp_,coneidx_,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(model_,name_,numpy.int32(n),shp_,numpy.int32(coneidx_),numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SILmosek_4fusion_4Set_2IJ(self,model_,name_,n,shp_,coneidx_,varid_):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,shp_,varid_)
   self.__blocksize = shp_._dim_I(0)
   self.__conesize = shp_._dim_I(0)
   self.__coneidx = coneidx_
   self.__sdpvardim = n
   self.__numcones = 1
   for _0 in range(1,(shp_.nd)):
    self.__numcones *= shp_._dim_I(_0)
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("PSDVariable(")
   if (int(len(self._name)) > 0):
    _0._a_S("'")._a_S(self._name)._a_S("',")
   _0._a_I(self._shape_p._dim_I(0))
   for _1 in range(1,(self._shape_p.nd)):
    _0._a_S(",")._a_I(self._shape_p._dim_I(_1))
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   for _8 in range(_1,_2):
    if ((_0[_8] < _3) or (_0[_8] >= ((self._shape_p._size) + _3))):
     raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _9=_4
   _10=self.__sdpvardim
   for _11 in range(_1,_2):
    _12=(_0[_11] - _3)
    _13=numpy.int32((_12 // self.__blocksize))
    _14=(_12 % self.__blocksize)
    _5[_9] = (- ((1 + self.__coneidx) + _13))
    _15=numpy.int32(((_10 + 0.5) - mosek.fusion.Utils.Tools._sqrt_D((((_10 + 0.5) * (_10 + 0.5)) - (_14 * 2)))))
    _16=numpy.int32((_14 - ((_15 * (((2 * _10) - _15) - 1)) // 2)))
    if (_16 >= _15):
     _6[_9] = _16
     _7[_9] = _15
    else:
     _6[_9] = _15
     _7[_9] = _16
    _9 += 1
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _5=self.__sdpvardim
   _6=numpy.int32((_0 // self.__blocksize))
   _7=(_0 % self.__blocksize)
   _2[_1] = (- ((1 + self.__coneidx) + _6))
   _8=numpy.int32(((_5 + 0.5) - mosek.fusion.Utils.Tools._sqrt_D((((_5 + 0.5) * (_5 + 0.5)) - (_7 * 2)))))
   _9=numpy.int32((_7 - ((_8 * (((2 * _5) + 1) + _8)) // 2)))
   if (_9 >= _8):
    _3[_1] = _9
    _4[_1] = _8
   else:
    _3[_1] = _8
    _4[_1] = _9
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   raise mosek_fusion_UnimplementedError._ctor_S("Cannot make PSDVariable elements integer")
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   raise mosek_fusion_UnimplementedError._ctor_S("Cannot make PSDVariable elements integer")
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=1
   _7=int((_2).shape[0])
   _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _9=(self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_5 ) else self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _6 = fragments._c_closure_129(_7,_1,_6) # src/fusion/LinearPSDVariable.monty:105:9-51
   _6 = numpy.int64(_6) # postprocess
   for _10 in range(0,_6):
    _11=(_8._get_() // self.__blocksize)
    _12=(_8._get_() % self.__blocksize)
    _4[_10] = _9[(numpy.int64(self.__coneidx) + _11)][_12]
    _8._inc_()
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=(self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_3 ) else self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   for _5 in range(0,int((_0).shape[0])):
    if ((_0[_5] < 0) or (_0[_5] >= (self._shape_p._size))):
     raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   fragments._c_closure_130(_4,self.__blocksize,self.__coneidx,_0,_2) # src/fusion/LinearPSDVariable.monty:79:9-85:10
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   raise mosek_fusion_UnimplementedError._ctor_S("Cannot make PSDVariable elements integer")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearPSDVariable._ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearPSDVariable
mosek_fusion_LinearPSDVariable=__mk_mosek_fusion_LinearPSDVariable()
del __mk_mosek_fusion_LinearPSDVariable
#BEFORE CLASS
def __mk_mosek_fusion_PSDVariable():
 class PSDVariable(mosek_fusion_SymmetricVariable,mosek_fusion_ModelVariable):
  __slots__ = ['_PSDVariable__numcones','_PSDVariable__coneidx','_PSDVariable__conesize']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_PSDVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.toString()')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_PSDVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_PSDVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_PSDVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.PSDVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.PSDVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_PSDVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_PSDVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_PSDVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.make_integer(array(int64,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_PSDVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.PSDVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.PSDVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_PSDVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.make_continuous(array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.PSDVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = PSDVariable.__new__(PSDVariable)
    o._ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4PSDVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__conesize = (v.__conesize)
   self.__coneidx = (v.__coneidx)
   self.__numcones = (v.__numcones)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SIIIJ(model_,name_,conesize_,coneidx_,num_,varid_):
    o = PSDVariable.__new__(PSDVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SIIIJ(model_,name_,conesize_,coneidx_,num_,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SIIIJ(*args):
    if len(args) != 6: return False
    model_,name_,conesize_,coneidx_,num_,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_I__(conesize_) and __arg_match_I__(coneidx_) and __arg_match_I__(num_) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SIIIJ(*args):
    if len(args) != 6: return False
    model_,name_,conesize_,coneidx_,num_,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_I__(conesize_) and __arg_alt_match_I__(coneidx_) and __arg_alt_match_I__(num_) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SIIIJ(self,model_,name_,conesize_,coneidx_,num_,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SIIIJ(model_,name_,numpy.int32(conesize_),numpy.int32(coneidx_),numpy.int32(num_),numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SIIIJ(self,model_,name_,conesize_,coneidx_,num_,varid_):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,(mosek_fusion_NDSet._ctor_II(conesize_,conesize_) if ((num_==1) ) else mosek_fusion_NDSet._ctor_III(num_,conesize_,conesize_)),varid_)
   self.__conesize = conesize_
   self.__coneidx = coneidx_
   self.__numcones = num_
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("PSDVariable(")
   if (int(len(self._name)) > 0):
    _0._a_S("'")._a_S(self._name)._a_S("',")
   _0._a_I(self._shape_p._dim_I(0))
   for _1 in range(1,(self._shape_p.nd)):
    _0._a_S(",")._a_I(self._shape_p._dim_I(_1))
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _2=(numpy.int64(self.__conesize) * numpy.int64(self.__conesize))
   _3=(_0 // _2)
   _4=(_0 % _2)
   _5=(_4 // self.__conesize)
   _6=(_4 % self.__conesize)
   _1._a_S(("_" if ((int(len(self._name))==0) ) else self._name))._a_S("[")._a_J(_3)._a_S(",")._a_J(_5)._a_S(",")._a_J(_6)._a_S("] ")
   if (self.__numcones > 1):
    _1._a_S(" : element (")._a_J(_3)._a_S(",")._a_J(_5)._a_S(",")._a_J(_6)
   else:
    _1._a_S(" : element (")._a_J(_5)._a_S(",")._a_J(_6)
   _1._a_S(") in a semidefinite cone of size (")._a_I(self.__numcones)._a_S(",")._a_I(self.__conesize)._a_S(",")._a_I(self.__conesize)._a_S(")")
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _2=(numpy.int64(self.__conesize) * numpy.int64(self.__conesize))
   _3=(_0 // _2)
   _4=(_0 % _2)
   _5=(_4 // self.__conesize)
   _6=(_4 % self.__conesize)
   _1._a_S(("_" if ((int(len(self._name))==0) ) else self._name))._a_S("[")._a_J(_3)._a_S(",")._a_J(_5)._a_S(",")._a_J(_6)._a_S("] ")
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   for _8 in range(_1,_2):
    if ((_0[_8] < _3) or (_0[_8] >= ((self._shape_p._size) + _3))):
     raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _9=_4
   for _10 in range(_1,_2):
    _11=(_0[_10] - _3)
    _12=numpy.int32((_11 // (self.__conesize * self.__conesize)))
    _13=(_11 - ((self.__conesize * self.__conesize) * _12))
    _5[_9] = (- ((1 + self.__coneidx) + _12))
    _14=(numpy.int32(_13) // self._shape_p._dim_I(1))
    _15=(numpy.int32(_13) - numpy.int32((_14 * self._shape_p._dim_I(1))))
    if (_14 >= _15):
     _6[_9] = _14
     _7[_9] = _15
    else:
     _6[_9] = _15
     _7[_9] = _14
    _9 += 1
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((_0 < 0) or (_0 >= (self._shape_p._size))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _5=numpy.int32((_0 // (self.__conesize * self.__conesize)))
   _6=(_0 - ((self.__conesize * self.__conesize) * _5))
   _2[_1] = (- ((1 + self.__coneidx) + _5))
   _7=(numpy.int32(_6) // self._shape_p._dim_I(1))
   _8=(numpy.int32(_6) - numpy.int32((_7 * self._shape_p._dim_I(1))))
   if (_7 >= _8):
    _3[_1] = _7
    _4[_1] = _8
   else:
    _3[_1] = _8
    _4[_1] = _7
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=1
   _7=int((_2).shape[0])
   _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _9=(self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_5 ) else self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _10=(self.__conesize * self.__conesize)
   _6 = fragments._c_closure_131(_7,_1,_6) # src/fusion/SemidefiniteVariable.mbi:106:9-51
   _6 = numpy.int64(_6) # postprocess
   for _11 in range(0,_6):
    _12=(_8._get_() // _10)
    _13=(_8._get_() - (_12 * _10))
    _14=(_13 // self.__conesize)
    _15=(_13 - (_14 * self.__conesize))
    if (_15 > _14):
     _4[_11] = _9[(numpy.int64(self.__coneidx) + _12)][(((_14 * self.__conesize) + _15) - ((_14 * (_14 + 1)) // 2))]
    else:
     _4[_11] = _9[(numpy.int64(self.__coneidx) + _12)][(((_15 * self.__conesize) + _14) - ((_15 * (_15 + 1)) // 2))]
    _8._inc_()
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=(self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_3 ) else self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _5=(self.__conesize * self.__conesize)
   fragments._c_closure_132(_4,_5,self.__coneidx,self.__conesize,_0,_2) # src/fusion/SemidefiniteVariable.mbi:74:9-85:10
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   raise mosek_fusion_UnimplementedError._ctor_S("Cannot make PSDVariable elements integer")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_PSDVariable._ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return PSDVariable
mosek_fusion_PSDVariable=__mk_mosek_fusion_PSDVariable()
del __mk_mosek_fusion_PSDVariable
#BEFORE CLASS
def __mk_mosek_fusion_SymLinearVariable():
 class SymLinearVariable(mosek_fusion_SymmetricVariable,mosek_fusion_ModelVariable):
  __slots__ = ['_SymLinearVariable__dim','_SymLinearVariable__names_flushed','_SymLinearVariable__dom','_SymLinearVariable__nativeidxs','_SymLinearVariable__idxmap']
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_SymLinearVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymLinearVariable.make_continuous(array(int64,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_SymLinearVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymLinearVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.SymLinearVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.SymLinearVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_SymLinearVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_SymLinearVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymLinearVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.SymLinearVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SymLinearVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymLinearVariable.toString()')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_SymLinearVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymLinearVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.SymLinearVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_SymLinearVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_SymLinearVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymLinearVariable.make_integer(array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.SymLinearVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = SymLinearVariable.__new__(SymLinearVariable)
    o._ctor_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4SymLinearVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymLinearVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__nativeidxs = (numpy.array([(v.__nativeidxs)[_0] for _0 in range(0,int(((v.__nativeidxs)).shape[0]))], dtype=numpy.dtype(numpy.int32)) if (((v.__nativeidxs) is not None) ) else None)
   self.__idxmap = ((v.__idxmap)._clone_() if (((v.__idxmap) is not None) ) else None)
   self.__dom = (v.__dom)
   (self.__dim) = (v.__dim)
   self.__names_flushed = (v.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(model,name,dom,dim,nativeidxs,varid):
    o = SymLinearVariable.__new__(SymLinearVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(model,name,dom,dim,nativeidxs,varid)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(*args):
    if len(args) != 6: return False
    model,name,dom,dim,nativeidxs,varid, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(dom) and __arg_match_I__(dim) and __arg_match__3I__(nativeidxs) and __arg_match_J__(varid))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(*args):
    if len(args) != 6: return False
    model,name,dom,dim,nativeidxs,varid, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(dom) and __arg_alt_match_I__(dim) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match_J__(varid))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(self,model,name,dom,dim,nativeidxs,varid):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(model,name,dom,numpy.int32(dim),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),numpy.int64(varid))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4SymmetricLinearDomain_2I_3IJ(self,model,name,dom,dim,nativeidxs,varid):
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model,name,mosek.fusion.Set._make_II(dim,dim),varid)
   (self.__nativeidxs) = nativeidxs
   self.__idxmap = (mosek.fusion.Utils.IntMap() if (((self.__nativeidxs) is None) ) else None)
   (self.__dom) = dom
   (self.__dim) = dim
   self.__names_flushed = False
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SymLinearVariable( (")
   if (int(len(self._name)) > 0):
    _0._a_S("'")._a_S(self._name)._a_S("',")
   _0._a_I(self._shape_p._dim_I(0))
   for _1 in range(1,(self._shape_p.nd)):
    _0._a_S(",")._a_I(self._shape_p._dim_I(_1))
   _0._a_S(") )")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    if (self.__nativeidxs is not None):
     for _0 in range(0,self.__dim):
      for _1 in range(0,(_0 + 1)):
       _2=(((_0 * self.__dim) - ((_0 * (_0 + 1)) // 2)) + _1)
       _3=((_0 * self.__dim) + _1)
       self._model._varname_IS(self.__nativeidxs[_2],("" if ((int(len(self._name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_3))._a_S("]")._toString_()))
    else:
     for _4 in range(0,self.__dim):
      for _5 in range(0,(_4 + 1)):
       _6=((_4 * self.__dim) + _5)
       if self.__idxmap._hasItem_J(_6):
        self._model._varname_IS(self.__nativeidxs[self.__idxmap._getItem_J(_6)],("" if ((int(len(self._name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_6))._a_S("]")._toString_()))
    self.__names_flushed = True
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   if (self.__nativeidxs is not None):
    for _8 in range(_1,_2):
     _5[((_4 + _8) - _1)] = self.__nativeidxs[self.__tril_1lin_1idx_J((_0[_8] - _3))]
   else:
    for _9 in range(_1,_2):
     _10=self.__tril_1lin_1idx_J((_0[_9] - _3))
     _11=self.__tril_1idx_J((_0[_9] - _3))
     if (not self.__idxmap._hasItem_J(_11)):
      _12=self._model._append_1linearvar_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(self,_11,(self.__dom._key),self.__dom._get_1rhs_1item_J(_10))
      self.__idxmap._setItem_JI(_11,_12)
      _5[((_4 + _9) - _1)] = _12
      self.__names_flushed = False
     else:
      _5[((_4 + _9) - _1)] = self.__idxmap._getItem_J(_11)
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=self.__tril_1lin_1idx_J(_0)
   _6=self.__tril_1idx_J(_0)
   if (self.__nativeidxs is not None):
    _2[_1] = self.__nativeidxs[_5]
   else:
    if (not self.__idxmap._hasItem_J(_6)):
     _7=self._model._append_1linearvar_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(self,_6,(self.__dom._key),self.__dom._get_1rhs_1item_J(_6))
     self.__idxmap._setItem_JI(_5,_7)
     _2[_1] = _7
    else:
     _2[_1] = self.__idxmap._getItem_J(_5)
  def __dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _9=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_133(_6,_1,_5) # src/fusion/SymLinearVariable.monty:350:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _10 in range(0,_5):
     _11=self.__nativeidxs[self.__tril_1lin_1idx_J(_7._get_())]
     _4[(_10 + _3)] = (_8[_11] - _9[_11])
     _7._inc_()
   else:
    _12=self._model._getPrimalSolutionStatus_()
    for _13 in range(0,numpy.int32(_5)):
     if self.__idxmap._hasItem_J(self.__tril_1lin_1idx_J(_7._get_())):
      _14=self.__idxmap._getItem_J(_7._get_())
      _4[(_3 + _13)] = (_8[_14] - _9[_14])
     else:
      _4[(_3 + _13)] = 0.0
     _7._inc_()
  def __dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    for _5 in range(0,int((_0).shape[0])):
     _6=self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_5])]
     _2[(_1 + _5)] = (_3[_6] - _4[_6])
   else:
    _7=self._model._getPrimalSolutionStatus_()
    for _8 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_8]):
      _9=self.__idxmap._getItem_J(_0[_8])
      _2[(_1 + _8)] = (_3[_9] - _4[_9])
     else:
      _2[(_1 + _8)] = 0.0
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _6 = fragments._c_closure_134(_7,_1,_6) # src/fusion/SymLinearVariable.monty:271:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     _9=int((self.__nativeidxs).shape[0])
     _10=numpy.array([self.__nativeidxs[self.__tril_1lin_1idx_J(_8._next_())] for _11 in range(0,_6)], dtype=numpy.dtype(numpy.int32))
     _12=(numpy.array([_4[(_3 + _13)] for _13 in range(0,_9)], dtype=numpy.dtype(numpy.float64)) if ((_3 > 0) ) else _4)
     self._model._setSolution_1xx__3I_3D(_10,_12)
    else:
     _14=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
     for _15 in range(0,_6):
      self._inst_JJ_3I_3I_3I(_8._next_(),_15,_14,None,None)
     _16=numpy.array([_4[(_3 + _17)] for _17 in range(0,_6)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_14,_16)
   else:
    pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if _2:
    if (self.__nativeidxs is not None):
     _3=int((self.__nativeidxs).shape[0])
     _4=numpy.array([self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_5])] for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
     _6=numpy.array([_1[_7] for _7 in range(0,_3)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_4,_6)
    else:
     _8=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
     for _9 in range(0,int((_0).shape[0])):
      self._inst_JJ_3I_3I_3I(_0[_9],_9,_8,None,None)
     self._model._setSolution_1xx__3I_3D(_8,_1)
   else:
    pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _9=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _6 = fragments._c_closure_135(_7,_1,_6) # src/fusion/SymLinearVariable.monty:182:11-47
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     for _10 in range(0,_6):
      _4[(_10 + _3)] = _9[self.__nativeidxs[self.__tril_1lin_1idx_J(_8._get_())]]
      _8._inc_()
    else:
     _11=self._model._getPrimalSolutionStatus_()
     if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
      for _12 in range(0,numpy.int32(_6)):
       if self.__idxmap._hasItem_J(_8._get_()):
        _4[(_3 + _12)] = _9[self.__idxmap._getItem_J(_8._get_())]
       else:
        _4[(_3 + _12)] = self.__dom._get_1rhs_1item_J(self.__tril_1idx_J(_8._get_()))
       _8._inc_()
     else:
      for _13 in range(0,numpy.int32(_6)):
       if self.__idxmap._hasItem_J(_8._get_()):
        _4[(_3 + _13)] = _9[self.__idxmap._getItem_J(_8._get_())]
       else:
        _4[(_3 + _13)] = 0.0
       _8._inc_()
   else:
    self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if _3:
    _4=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    if (self.__nativeidxs is not None):
     for _5 in range(0,int((_0).shape[0])):
      _2[(_1 + _5)] = _4[self.__nativeidxs[self.__tril_1lin_1idx_J(_0[_5])]]
    else:
     _6=self._model._getPrimalSolutionStatus_()
     if ((_6==mosek.fusion.SolutionStatus.Optimal) or ((_6==mosek.fusion.SolutionStatus.NearOptimal) or ((_6==mosek.fusion.SolutionStatus.Feasible) or (_6==mosek.fusion.SolutionStatus.NearFeasible)))):
      for _7 in range(0,int((_0).shape[0])):
       _8=_0[_7]
       if self.__idxmap._hasItem_J(_8):
        _2[(_1 + _7)] = _4[self.__idxmap._getItem_J(_8)]
       else:
        _2[(_1 + _7)] = self.__dom._get_1rhs_1item_J(self.__tril_1idx_J(_8))
     else:
      for _9 in range(0,int((_0).shape[0])):
       _10=_0[_9]
       if self.__idxmap._hasItem_J(_10):
        _2[(_1 + _9)] = _4[self.__idxmap._getItem_J(self.__tril_1idx_J(_10))]
       else:
        _2[(_1 + _9)] = 0.0
   else:
    self.__dual_1values__3JI_3D(_0,_1,_2)
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putcontlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putcontlist__3I(_2)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putintlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putintlist__3I(_2)
  def __tril_1idx_alt_J(self,_t__0):
    return self.__tril_1idx_J(numpy.int64(__0))
  def __tril_1idx_J(self,_0):
   _1=(_0 // self.__dim)
   _2=(_0 % self.__dim)
   if (_2 > _1):
    return numpy.int64(((_2 * self.__dim) + _1))
   else:
    return numpy.int64(_0)
  def __tril_1lin_1idx_alt_J(self,_t__0):
    return self.__tril_1lin_1idx_J(numpy.int64(__0))
  def __tril_1lin_1idx_J(self,_0):
   _1=(_0 // self.__dim)
   _2=(_0 % self.__dim)
   if (_2 > _1):
    return numpy.int64((((_2 * (_2 + 1)) // 2) + _1))
   else:
    return numpy.int64((((_1 * (_1 + 1)) // 2) + _2))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_SymLinearVariable._ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return SymLinearVariable
mosek_fusion_SymLinearVariable=__mk_mosek_fusion_SymLinearVariable()
del __mk_mosek_fusion_SymLinearVariable
#BEFORE CLASS
def __mk_mosek_fusion_LinearVariable():
 class LinearVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_LinearVariable__names_flushed','_LinearVariable__dom','_LinearVariable__nativeidxs','_LinearVariable__idxmap']
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_LinearVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.make_integer(array(int64,ndim=1))')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_LinearVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_LinearVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_LinearVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.LinearVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_LinearVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_LinearVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.LinearVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.LinearVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_LinearVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.make_continuous(array(int64,ndim=1))')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_LinearVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.LinearVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def __repr__(self): return 'mosek.fusion.LinearVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = LinearVariable.__new__(LinearVariable)
    o._ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__nativeidxs = (numpy.array([(v.__nativeidxs)[_0] for _0 in range(0,int(((v.__nativeidxs)).shape[0]))], dtype=numpy.dtype(numpy.int32)) if (((v.__nativeidxs) is not None) ) else None)
   self.__idxmap = ((v.__idxmap)._clone_() if (((v.__idxmap) is not None) ) else None)
   self.__dom = (v.__dom)
   self.__names_flushed = (v.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(model_,name_,dom_,shape_p,nativeidxs_,varid_):
    o = LinearVariable.__new__(LinearVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(model_,name_,dom_,shape_p,nativeidxs_,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(*args):
    if len(args) != 6: return False
    model_,name_,dom_,shape_p,nativeidxs_,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(dom_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_match__3I__(nativeidxs_) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(*args):
    if len(args) != 6: return False
    model_,name_,dom_,shape_p,nativeidxs_,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(dom_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(self,model_,name_,dom_,shape_p,nativeidxs_,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(model_,name_,dom_,shape_p,numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3IJ(self,model_,name_,dom_,shape_p,nativeidxs_,varid_):
   assert nativeidxs_ is None or isinstance(nativeidxs_,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,shape_p,varid_)
   self.__nativeidxs = nativeidxs_
   if (nativeidxs_ is None):
    self.__idxmap = mosek.fusion.Utils.IntMap()
   else:
    self.__idxmap = None
   self.__dom = dom_
   self.__names_flushed = False
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   self.__dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _1._a_S(("_" if ((int(len(self._name))==0) ) else self._name))._a_S("[")._a_S(self._shape_p._indexToString_J(_0))._a_S("] ")
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    if (self.__nativeidxs is not None):
     for _0 in range(0,int((self.__nativeidxs).shape[0])):
      self._model._varname_IS(self.__nativeidxs[_0],("" if ((int(len(self._name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_0))._a_S("]")._toString_()))
    else:
     _1=self.__idxmap._keys_()
     _2=self.__idxmap._values_()
     for _3 in range(0,int((_1).shape[0])):
      self._model._varname_IS(_2[_3],mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_1[_3]))._a_S("]")._toString_())
    self.__names_flushed = True
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   if (self.__nativeidxs is not None):
    fragments._c_closure_136(_5,_4,_1,_0,_3,_2,self.__nativeidxs) # src/fusion/LinearVariable.mbi:387:9-390:10
   else:
    for _8 in range(_1,_2):
     if (not self.__idxmap._hasItem_J(_0[(numpy.int64(_8) - _3)])):
      _9=self._model._append_1linearvar_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(self,_0[(numpy.int64(_8) - _3)],(self.__dom._key),self.__dom._get_1rhs_1item_J(_0[(numpy.int64(_8) - _3)]))
      self.__idxmap._setItem_JI(_0[(_8 - _3)],_9)
      _5[((_4 + _8) - _1)] = _9
      self.__names_flushed = False
     else:
      _5[((_4 + _8) - _1)] = self.__idxmap._getItem_J(_0[(numpy.int64(_8) - _3)])
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if (self.__nativeidxs is not None):
    _2[_1] = self.__nativeidxs[_0]
   else:
    if (not self.__idxmap._hasItem_J(_0)):
     _5=self._model._append_1linearvar_Lmosek_4fusion_4ModelVariable_2JEmosek_4fusion_4RelationKey_2D(self,_0,(self.__dom._key),self.__dom._get_1rhs_1item_J(_0))
     self.__idxmap._setItem_JI(_0,_5)
     _2[_1] = _5
    else:
     _2[_1] = self.__idxmap._getItem_J(_0)
  def __dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _9=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_137(_6,_1,_5) # src/fusion/LinearVariable.mbi:312:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self.__nativeidxs is not None):
    for _10 in range(0,_5):
     _11=self.__nativeidxs[_7._get_()]
     _4[(_10 + _3)] = (_8[_11] - _9[_11])
     _7._inc_()
   else:
    _12=self._model._getPrimalSolutionStatus_()
    for _13 in range(0,numpy.int32(_5)):
     if self.__idxmap._hasItem_J(_7._get_()):
      _14=self.__idxmap._getItem_J(_7._get_())
      _4[(_3 + _13)] = (_8[_14] - _9[_14])
     else:
      if ((_12==mosek.fusion.SolutionStatus.Optimal) or ((_12==mosek.fusion.SolutionStatus.NearOptimal) or ((_12==mosek.fusion.SolutionStatus.Feasible) or (_12==mosek.fusion.SolutionStatus.NearFeasible)))):
       _4[(_3 + _13)] = self.__dom._get_1rhs_1item_J(_7._get_())
      else:
       _4[(_3 + _13)] = 0.0
     _7._inc_()
  def __dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self.__dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self._model._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self.__nativeidxs is not None):
    fragments._c_closure_138(_0,self.__nativeidxs,_1,_3,_4,_2) # src/fusion/LinearVariable.mbi:270:11-274:12
   else:
    _5=self._model._getPrimalSolutionStatus_()
    for _6 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_6]):
      _7=self.__idxmap._getItem_J(_0[_6])
      _2[(_1 + _6)] = (_3[_7] - _4[_7])
     else:
      if ((_5==mosek.fusion.SolutionStatus.Optimal) or ((_5==mosek.fusion.SolutionStatus.NearOptimal) or ((_5==mosek.fusion.SolutionStatus.Feasible) or (_5==mosek.fusion.SolutionStatus.NearFeasible)))):
       _2[(_1 + _6)] = self.__dom._get_1rhs_1item_J(_0[_6])
      else:
       _2[(_1 + _6)] = 0.0
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _6 = fragments._c_closure_139(_7,_1,_6) # src/fusion/LinearVariable.mbi:229:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     _9=int((self.__nativeidxs).shape[0])
     _10=numpy.array([self.__nativeidxs[_8._next_()] for _11 in range(0,_6)], dtype=numpy.dtype(numpy.int32))
     _12=(numpy.array([_4[_13] for _13 in range(0,_9)], dtype=numpy.dtype(numpy.float64)) if ((_3 > 0) ) else _4)
     self._model._setSolution_1xx__3I_3D(_10,_12)
    else:
     _14=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
     for _15 in range(0,_6):
      self._inst_JJ_3I_3I_3I(_8._next_(),_15,_14,None,None)
     _16=numpy.array([_4[(_3 + _17)] for _17 in range(0,_6)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_14,_16)
   else:
    pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if _2:
    if (self.__nativeidxs is not None):
     _3=int((self.__nativeidxs).shape[0])
     _4=numpy.array([self.__nativeidxs[_0[_5]] for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
     _6=numpy.array([_1[_7] for _7 in range(0,_3)], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_4,_6)
    else:
     _8=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
     for _9 in range(0,int((_0).shape[0])):
      self._inst_JJ_3I_3I_3I(_0[_9],_9,_8,None,None)
     _10=numpy.array([_1[_11] for _11 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64))
     self._model._setSolution_1xx__3I_3D(_8,_10)
   else:
    pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if (not _5):
    self.__dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   else:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _9=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _6 = fragments._c_closure_140(_7,_1,_6) # src/fusion/LinearVariable.mbi:149:11-53
    _6 = numpy.int64(_6) # postprocess
    if (self.__nativeidxs is not None):
     for _10 in range(0,_6):
      _4[(_10 + _3)] = _9[self.__nativeidxs[_8._get_()]]
      _8._inc_()
    else:
     _11=self._model._getPrimalSolutionStatus_()
     for _12 in range(0,numpy.int32(_6)):
      if self.__idxmap._hasItem_J(_8._get_()):
       _4[(_3 + _12)] = _9[self.__idxmap._getItem_J(_8._get_())]
      else:
       if ((_11==mosek.fusion.SolutionStatus.Optimal) or ((_11==mosek.fusion.SolutionStatus.NearOptimal) or ((_11==mosek.fusion.SolutionStatus.Feasible) or (_11==mosek.fusion.SolutionStatus.NearFeasible)))):
        _4[(_3 + _12)] = self.__dom._get_1rhs_1item_J(_8._get_())
       else:
        _4[(_3 + _12)] = 0.0
      _8._inc_()
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putcontlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putcontlist__3I(_2)
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__nativeidxs is not None):
    self._getModel_()._task_1var_1putintlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
   else:
    _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
    self._inst__3JIIJJ_3I_3I_3I(_0,0,int((_0).shape[0]),0,0,_2,None,None)
    self._getModel_()._task_1var_1putintlist__3I(_2)
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (not _3):
    self.__dual_1values__3JI_3D(_0,_1,_2)
   else:
    _4=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    if (self.__nativeidxs is not None):
     fragments._c_closure_141(_0,self.__nativeidxs,_1,_2,_4) # src/fusion/LinearVariable.mbi:85:13-86:58
    else:
     _5=self._model._getPrimalSolutionStatus_()
     for _6 in range(0,int((_0).shape[0])):
      if self.__idxmap._hasItem_J(_0[_6]):
       _2[(_1 + _6)] = _4[self.__idxmap._getItem_J(_0[_6])]
      else:
       if ((_5==mosek.fusion.SolutionStatus.Optimal) or ((_5==mosek.fusion.SolutionStatus.NearOptimal) or ((_5==mosek.fusion.SolutionStatus.Feasible) or (_5==mosek.fusion.SolutionStatus.NearFeasible)))):
        _2[(_1 + _6)] = self.__dom._get_1rhs_1item_J(_0[_6])
       else:
        _2[(_1 + _6)] = 0.0
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearVariable._ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearVariable
mosek_fusion_LinearVariable=__mk_mosek_fusion_LinearVariable()
del __mk_mosek_fusion_LinearVariable
#BEFORE CLASS
def __mk_mosek_fusion_ConicVariable():
 class ConicVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_ConicVariable__names_flushed','_ConicVariable__nativeidxs','_ConicVariable__dom','_ConicVariable__numcone','_ConicVariable__conesize','_ConicVariable__coneidx']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ConicVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.toString()')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_ConicVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.make_continuous(array(int64,ndim=1))')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_ConicVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_ConicVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_ConicVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_ConicVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_ConicVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.ConicVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.ConicVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.ConicVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_ConicVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.ConicVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_ConicVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.make_integer(array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.ConicVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = ConicVariable.__new__(ConicVariable)
    o._ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4ConicVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConicVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__dom = (v.__dom)
   self.__coneidx = (v.__coneidx)
   self.__conesize = (v.__conesize)
   self.__numcone = (v.__numcone)
   self.__nativeidxs = (numpy.array([(v.__nativeidxs)[_0] for _0 in range(0,int(((v.__nativeidxs)).shape[0]))], dtype=numpy.dtype(numpy.int32)) if (((v.__nativeidxs) is not None) ) else None)
   self.__names_flushed = (v.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(model_,name_,dom_,shape_p,nativeidxs_,conesize_,firstcone_,numcone_,varid_):
    o = ConicVariable.__new__(ConicVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(model_,name_,dom_,shape_p,nativeidxs_,conesize_,firstcone_,numcone_,varid_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(*args):
    if len(args) != 9: return False
    model_,name_,dom_,shape_p,nativeidxs_,conesize_,firstcone_,numcone_,varid_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(dom_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_match__3I__(nativeidxs_) and __arg_match_I__(conesize_) and __arg_match_I__(firstcone_) and __arg_match_I__(numcone_) and __arg_match_J__(varid_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(*args):
    if len(args) != 9: return False
    model_,name_,dom_,shape_p,nativeidxs_,conesize_,firstcone_,numcone_,varid_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(dom_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_p) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_I__(conesize_) and __arg_alt_match_I__(firstcone_) and __arg_alt_match_I__(numcone_) and __arg_alt_match_J__(varid_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(self,model_,name_,dom_,shape_p,nativeidxs_,conesize_,firstcone_,numcone_,varid_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(model_,name_,dom_,shape_p,numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int32(conesize_),numpy.int32(firstcone_),numpy.int32(numcone_),numpy.int64(varid_))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIJ(self,model_,name_,dom_,shape_p,nativeidxs_,conesize_,firstcone_,numcone_,varid_):
   assert nativeidxs_ is None or isinstance(nativeidxs_,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2J(self,model_,name_,shape_p,varid_)
   self.__dom = dom_
   self.__conesize = conesize_
   self.__coneidx = firstcone_
   self.__numcone = numcone_
   self.__nativeidxs = nativeidxs_
   self.__names_flushed = False
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("ConicVariable( ")
   if (int(len(self._name)) > 0):
    _0._a_S("'")._a_S(self._name)._a_S("',")
   _0._a_S("(")
   _0._a_I(self._shape_p._dim_I(0))
   for _1 in range(1,(self._shape_p.nd)):
    _0._a_S(",")._a_I(self._shape_p._dim_I(_1))
   _0._a_S(") )")
   return (_0._toString_())
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   self.__dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _1._a_S(("_" if ((int(len(self._name))==0) ) else self._name))._a_S("[")._a_S(self._shape_p._indexToString_J(_0))._a_S("] ")
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    for _0 in range(0,int((self.__nativeidxs).shape[0])):
     self._model._varname_IS(self.__nativeidxs[_0],mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_0))._a_S("]")._toString_())
    self.__names_flushed = True
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   fragments._c_closure_142(_5,_4,_1,_0,_3,_2,self.__nativeidxs) # src/fusion/ConicVariable.mbi:209:7-215:8
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((_0 < 0) or (_0 >= int((self.__nativeidxs).shape[0]))):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   _2[_1] = self.__nativeidxs[_0]
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if _5:
    _6=1
    _7=int((_2).shape[0])
    _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
    _6 = fragments._c_closure_143(_7,_1,_6) # src/fusion/ConicVariable.mbi:169:11-53
    _6 = numpy.int64(_6) # postprocess
    _9=int((self.__nativeidxs).shape[0])
    _10=numpy.array([self.__nativeidxs[_8._next_()] for _11 in range(0,_6)], dtype=numpy.dtype(numpy.int32))
    _12=(numpy.array([_4[(_3 + _13)] for _13 in range(0,_9)], dtype=numpy.dtype(numpy.float64)) if ((_3 > 0) ) else _4)
    self._model._setSolution_1xx__3I_3D(_10,_12)
   else:
    pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if _2:
    _3=int((self.__nativeidxs).shape[0])
    _4=numpy.array([self.__nativeidxs[_0[_5]] for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
    _6=numpy.array([_1[_7] for _7 in range(0,_3)], dtype=numpy.dtype(numpy.float64))
    self._model._setSolution_1xx__3I_3D(_4,_6)
   else:
    pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=1
   _7=int((_2).shape[0])
   _8=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _9=(self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_5 ) else self._model._getSolution_1snx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _6 = fragments._c_closure_144(_7,_1,_6) # src/fusion/ConicVariable.mbi:126:9-51
   _6 = numpy.int64(_6) # postprocess
   for _10 in range(0,_6):
    _4[(_10 + _3)] = _9[self.__nativeidxs[_8._get_()]]
    _8._inc_()
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=(self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_3 ) else self._model._getSolution_1snx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   fragments._c_closure_145(_0,self.__nativeidxs,_1,_2,_4) # src/fusion/ConicVariable.mbi:106:9-107:54
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   self._getModel_()._task_1var_1putcontlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   self._getModel_()._task_1var_1putintlist__3I(numpy.array([self.__nativeidxs[_0[_1]] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  def _get_1variable_1index_alt_I(self,_t__0):
    return self._get_1variable_1index_I(numpy.int32(__0))
  def _get_1variable_1index_I(self,_0):
   if (_0 >= int((self.__nativeidxs).shape[0])):
    raise mosek_fusion_IndexError._ctor_S("Variable index out of range")
   else:
    return numpy.int32(self.__nativeidxs[_0])
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_ConicVariable._ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,_0))
 return ConicVariable
mosek_fusion_ConicVariable=__mk_mosek_fusion_ConicVariable()
del __mk_mosek_fusion_ConicVariable
#BEFORE CLASS
def __mk_mosek_fusion_NilVariable():
 class NilVariable(mosek_fusion_SymmetricVariable,mosek_fusion_BaseVariable):
  def size(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_NilVariable._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.size()')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values__3J_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_set_1values__3J_3DZ(*args): # []int64,[]double,bool
      return self._set_1values_alt__3J_3DZ(*args)
    elif mosek_fusion_NilVariable._match_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_set_1values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._set_1values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.set_values(array(int64,ndim=1),array(double,ndim=1),bool)\n\tmosek.fusion.NilVariable.set_values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_NilVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    elif mosek_fusion_NilVariable._match_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values__3JI_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_values__3JI_3DZ(*args): # []int64,int32,[]double,bool
      return self._values_alt__3JI_3DZ(*args)
    elif mosek_fusion_NilVariable._match_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_J_3I_3JI_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_values_J_3I_3JI_3DZ(*args): # int64,[]int32,[]int64,int32,[]double,bool
      return self._values_alt_J_3I_3JI_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.values(int32,array(double,ndim=1),bool)\n\tmosek.fusion.NilVariable.values(array(int64,ndim=1),int32,array(double,ndim=1),bool)\n\tmosek.fusion.NilVariable.values(int64,array(int32,ndim=1),array(int64,ndim=1),int32,array(double,ndim=1),bool)')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_NilVariable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.dual()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_NilVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_NilVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_NilVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.slice(int32,int32)\n\tmosek.fusion.NilVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_NilVariable._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.level()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_NilVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.toString()')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_NilVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_NilVariable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_NilVariable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_NilVariable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_NilVariable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_NilVariable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_NilVariable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_NilVariable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.index(int32)\n\tmosek.fusion.NilVariable.index(array(int32,ndim=1))\n\tmosek.fusion.NilVariable.index(int32,int32)\n\tmosek.fusion.NilVariable.index(int32,int32,int32)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_NilVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.make_continuous(array(int64,ndim=1))')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_JJ_3I_3I_3I(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_JJ_3I_3I_3I(*args): # int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt_JJ_3I_3I_3I(*args)
    elif mosek_fusion_NilVariable._match_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst__3JIIJJ_3I_3I_3I(*args)
    elif mosek_fusion_NilVariable._match_alt_inst__3JIIJJ_3I_3I_3I(*args): # []int64,int32,int32,int64,int64,[]int32,[]int32,[]int32
      return self._inst_alt__3JIIJJ_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.inst(int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.NilVariable.inst(array(int64,ndim=1),int32,int32,int64,int64,array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_NilVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.make_integer(array(int64,ndim=1))')
  def makeContinuous(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_makeContinuous_(*args): # 
      return self._makeContinuous_(*args)
    elif mosek_fusion_NilVariable._match_alt_makeContinuous_(*args): # 
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.makeContinuous()')
  def makeInteger(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_makeInteger_(*args): # 
      return self._makeInteger_(*args)
    elif mosek_fusion_NilVariable._match_alt_makeInteger_(*args): # 
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.makeInteger()')
  def __repr__(self): return 'mosek.fusion.NilVariable'
  @staticmethod
  def _ctor_():
    o = NilVariable.__new__(NilVariable)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,None,mosek.fusion.Set._make_I(0))
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  @staticmethod
  def _match_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5) and __arg_match__3I__(_6) and __arg_match__3I__(_7))
  @staticmethod
  def _match_alt_inst__3JIIJJ_3I_3I_3I(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3I__(_7))
  def _inst_alt__3JIIJJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst__3JIIJJ_3I_3I_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst__3JIIJJ_3I_3I_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   pass
  @staticmethod
  def _match_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_J__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3I__(_4))
  @staticmethod
  def _match_alt_inst_JJ_3I_3I_3I(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3I__(_4))
  def _inst_alt_JJ_3I_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self._inst_JJ_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_JJ_3I_3I_3I(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   pass
  @staticmethod
  def _match_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_set_1values__3J_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _set_1values_alt__3J_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._set_1values__3J_3DZ(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3J_3DZ(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_set_1values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _set_1values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._set_1values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   pass
  @staticmethod
  def _match_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_values__3JI_3DZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_Z__(_3))
  def _values_alt__3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_t__3
   _1 = self._values__3JI_3DZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values__3JI_3DZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  @staticmethod
  def _match_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match_J__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_values_J_3I_3JI_3DZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Z__(_5))
  def _values_alt_J_3I_3JI_3DZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = self._values_J_3I_3JI_3DZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_J_3I_3JI_3DZ(self,_0,_1,_2,_3,_4,_5):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   pass
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   self._make_1continuous__3J(numpy.array([_0 for _0 in range(0,self._size_())], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   self._make_1integer__3J(numpy.array([_0 for _0 in range(0,self._size_())], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("NilVariable")
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int32(0)
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   return (numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   return (numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   for _2 in range(0,int((_0).shape[0])):
    if (_1[_2] > _0[_2]):
     raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
   return (self)
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if (_1 > _0):
    raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
   else:
    return (self)
 return NilVariable
mosek_fusion_NilVariable=__mk_mosek_fusion_NilVariable()
del __mk_mosek_fusion_NilVariable
#BEFORE CLASS
def __mk_mosek_fusion_Var():
 class Var(object):
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Var._match_hstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._hstack__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.hstack(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  @staticmethod
  def reshape(*args):
    if False: pass
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Variable,mosek.fusion.Set
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Variable,mosek.fusion.Set
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2_3I(*args): # mosek.fusion.Variable,[]int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2_3I(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2_3I(*args): # mosek.fusion.Variable,[]int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2_3I(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,mosek.fusion.Set)\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,array(int32,ndim=1))\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,int32,int32)')
  @staticmethod
  def hrepeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_hrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._hrepeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_hrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._hrepeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list hrepeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.hrepeat(mosek.fusion.Variable,int32)')
  @staticmethod
  def vrepeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_vrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._vrepeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_vrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._vrepeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list vrepeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.vrepeat(mosek.fusion.Variable,int32)')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Var._match_vstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._vstack__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.vstack(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Var._match_stack__3_3Lmosek_4fusion_4Variable_2(*args): # [][]mosek.fusion.Variable
      return mosek_fusion_Var._stack__3_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_stack__3_3Lmosek_4fusion_4Variable_2(*args): # [][]mosek.fusion.Variable
      return mosek_fusion_Var._stack_alt__3_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_stack__3Lmosek_4fusion_4Variable_2I(*args): # []mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack__3Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack__3Lmosek_4fusion_4Variable_2I(*args): # []mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt__3Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.stack(array(array(mosek.fusion.Variable,ndim=1),ndim=1))\n\tmosek.fusion.Var.stack(array(mosek.fusion.Variable,ndim=1),int32)\n\tmosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32)')
  @staticmethod
  def flatten(*args):
    if False: pass
    elif mosek_fusion_Var._match_flatten_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._flatten_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_flatten_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._flatten_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list flatten('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.flatten(mosek.fusion.Variable)')
  @staticmethod
  def repeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_repeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_repeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._repeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Var._match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._repeat_alt_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.repeat(mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.repeat(mosek.fusion.Variable,int32,int32)')
  @staticmethod
  def compress(*args):
    if False: pass
    elif mosek_fusion_Var._match_compress_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._compress_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_compress_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._compress_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list compress('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.compress(mosek.fusion.Variable)')
  def __repr__(self): return 'mosek.fusion.Var'
  @staticmethod
  def _match_compress_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_compress_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _compress_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Var._compress_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _compress_Lmosek_4fusion_4Variable_2(_0):
   _1=_0._getShape_()._realnd_()
   if (_1==(_0._getShape_().nd)):
    return (_0)
   elif (_1==1):
    return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2I(_0,numpy.int32((_0._getShape_()._size))))
   else:
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    _3=0
    for _4 in range(0,(_0._getShape_().nd)):
     if (_0._getShape_()._dim_I(_4) > 1):
      _2[_3] = _0._getShape_()._dim_I(_4)
      _3 += 1
    return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,mosek_fusion_NDSet._ctor__3I(_2)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2I(_0,_1):
   if (_1!=(_0._getShape_()._size)):
    raise mosek_fusion_DimensionError._ctor_S("New shape has wrong number of elements")
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(_0,mosek_fusion_IntSet._ctor_I(_1),0,numpy.array([1], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   if ((_1 * _2)!=(_0._getShape_()._size)):
    raise mosek_fusion_DimensionError._ctor_S("New shape has wrong number of elements")
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(_0,mosek_fusion_NDSet._ctor_II(_1,_2),0,numpy.array([numpy.int64(_2),1], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_flatten_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_flatten_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _flatten_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Var._flatten_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _flatten_Lmosek_4fusion_4Variable_2(_0):
   if ((_0._getShape_().nd)==1):
    return (_0)
   else:
    return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,mosek.fusion.Set._make_I(numpy.int32((_0._getShape_()._size)))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=mosek.fusion.Set._make__3I(_1)
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_2))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_t__0,_t__1):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1)
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1):
   if ((_1._size)!=(_0._getShape_()._size)):
    raise mosek_fusion_DimensionError._ctor_S("New shape has wrong number of elements")
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(_0,_1,0,numpy.array([_1._stride_I(_2) for _2 in range(0,(_1.nd))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _reshape_1_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_t__0,_t__1):
    return mosek_fusion_Var._reshape_1_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1)
  @staticmethod
  def _reshape_1_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1):
   _2=numpy.array([_1._stride_I(_3) for _3 in range(0,(_1.nd))], dtype=numpy.dtype(numpy.int64))
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(_0,_1,0,_2))
  @staticmethod
  def _index_1flip_1_alt_Lmosek_4fusion_4Variable_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._index_1flip_1_Lmosek_4fusion_4Variable_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _index_1flip_1_Lmosek_4fusion_4Variable_2_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=numpy.array([_0._getShape_()._stride_I(_3) for _3 in range(0,(_0._getShape_().nd))], dtype=numpy.dtype(numpy.int64))
   _4=numpy.array([_0._getShape_()._dim_I(_5) for _5 in range(0,(_0._getShape_().nd))], dtype=numpy.dtype(numpy.int32))
   _6=0
   _6 = fragments._c_closure_146(_4,_1,_6,_2) # src/fusion/Var.monty:466:9-470:10
   _6 = numpy.int64(_6) # postprocess
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(_0,_0._getShape_(),0,_2))
  @staticmethod
  def _index_1permute_1_alt_Lmosek_4fusion_4Variable_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._index_1permute_1_Lmosek_4fusion_4Variable_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _index_1permute_1_Lmosek_4fusion_4Variable_2_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=numpy.array([_0._getShape_()._stride_I(_1[_3]) for _3 in range(0,(_0._getShape_().nd))], dtype=numpy.dtype(numpy.int64))
   _4=numpy.array([_0._getShape_()._dim_I(_1[_5]) for _5 in range(0,(_0._getShape_().nd))], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2J_3J(_0,mosek_fusion_NDSet._ctor__3I(_4),0,_2))
  @staticmethod
  def _match_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _hrepeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._hrepeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _hrepeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,1,_1))
  @staticmethod
  def _match_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _vrepeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._vrepeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _vrepeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,0,_1))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,0,_1))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2))
  @staticmethod
  def __drepeat_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def __drepeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   if (_2 < 0):
    raise mosek_fusion_LengthError._ctor_S("Cannot repeat less than 0 times")
   elif (_2==0):
    return (mosek_fusion_NilVariable._ctor_())
   elif (_2==1):
    return (_0)
   else:
    return (mosek_fusion_RepeatVariable._ctor_Lmosek_4fusion_4Variable_2II(_0,_1,_2))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Variable_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Var._stack__3_3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=None
   for _2 in range(0,int((_0).shape[0])):
    for _3 in range(0,int((_0[_2]).shape[0])):
     if (_1 is None):
      _1 = _0[_2][_3]._getModel_()
     elif ((_0[_2][_3]._getModel_() is not None) and (_0[_2][_3]._getModel_() is not _1)):
      raise mosek_fusion_ModelError._ctor_S("Variables belong to different models")
   _4=0
   for _5 in range(0,int((_0).shape[0])):
    if (int((_0[_5]).shape[0]) > 0):
     _4 += 1
   _6=numpy.zeros((_4,), dtype=numpy.dtype(object))
   if (_4==0):
    return (mosek_fusion_NilVariable._ctor_())
   _7=0
   for _8 in range(0,int((_0).shape[0])):
    if (int((_0[_8]).shape[0])==0):
     pass
    elif (int((_0[_8]).shape[0])==1):
     _9=_0[_8][0]
     _6[_7] = (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2II(_9,_9._getShape_()._dim_I(0),1) if (((_9._getShape_().nd)==1) ) else _9)
     _7 += 1
    else:
     _10=0
     for _11 in range(0,int((_0[_8]).shape[0])):
      if ((_0[_8][_11]._getShape_()._size) > 0):
       _10 += 1
     _12=numpy.zeros((_10,), dtype=numpy.dtype(object))
     _13=0
     for _14 in range(0,int((_0[_8]).shape[0])):
      _15=_0[_8][_14]
      if ((_15._getShape_()._size) > 0):
       if ((_15._getShape_().nd)==1):
        _12[_13] = mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2II(_15,_15._getShape_()._dim_I(0),1)
       else:
        _12[_13] = _15
       _13 += 1
     _6[_7] = mosek_fusion_CompoundVariable._ctor__3Lmosek_4fusion_4Variable_2I(_12,1)
     _7 += 1
   return ((_6[0] if ((int((_6).shape[0])==1) ) else mosek_fusion_CompoundVariable._ctor__3Lmosek_4fusion_4Variable_2I(_6,0)))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Var._vstack__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Var._hstack__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,1))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_I__(_3))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2,numpy.int32(__3))
  @staticmethod
  def _stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2,_3):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),_3))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,numpy.int32(__2))
  @staticmethod
  def _stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),_2))
  @staticmethod
  def _match_stack__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_stack__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _stack_alt__3Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Var._stack__3Lmosek_4fusion_4Variable_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3Lmosek_4fusion_4Variable_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,_1))
  @staticmethod
  def _dstack_alt__3Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dstack__3Lmosek_4fusion_4Variable_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=None
   for _3 in range(0,int((_0).shape[0])):
    if (_2 is None):
     _2 = _0[_3]._getModel_()
    elif ((_0[_3]._getModel_() is not None) and (_0[_3]._getModel_() is not _2)):
     _4=mosek.fusion.Utils.StringBuffer()
     _5=(_2._getName_() if ((int(len(_2._getName_())) > 0) ) else "?")
     _6=(_0[_3]._getModel_()._getName_() if ((int(len(_0[_3]._getModel_()._getName_())) > 0) ) else "?")
     _4._a_S("Variables belong to different models: '")._a_S(_5)._a_S("' and '")._a_S(_6)._a_S("'")
     raise mosek_fusion_ModelError._ctor_S(_4._toString_())
   if (int((_0).shape[0])==0):
    return (mosek_fusion_NilVariable._ctor_())
   elif (int((_0).shape[0])==1):
    return (_0[1])
   else:
    _7=int((_0).shape[0])
    _8=(_1 + 1)
    for _9 in range(0,_7):
     if ((_0[_9]._getShape_().nd) > _8):
      _8 = (_0[_9]._getShape_().nd)
    _10=numpy.array([_0[0]._getShape_()._dim_I(_11) for _11 in range(0,_8)], dtype=numpy.dtype(numpy.int32))
    _12=numpy.zeros((_7,), dtype=numpy.dtype(object))
    _12[0] = mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0[0],mosek_fusion_NDSet._ctor__3I(_10))
    for _13 in range(1,_7):
     for _14 in range(0,_8):
      if ((_14!=_1) and (_0[_13]._getShape_()._dim_I(_14)!=_10[_14])):
       raise mosek_fusion_DimensionError._ctor_S("Variable dimensions do not match")
     _10[_1] = _0[_13]._getShape_()._dim_I(_1)
     _12[_13] = mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0[_13],mosek_fusion_NDSet._ctor__3I(_10))
    return (mosek_fusion_CompoundVariable._ctor__3Lmosek_4fusion_4Variable_2I(_12,_1))
 return Var
mosek_fusion_Var=__mk_mosek_fusion_Var()
del __mk_mosek_fusion_Var
#BEFORE CLASS
def __mk_mosek_fusion_ConstraintCache():
 class ConstraintCache(object):
  __slots__ = ['barmatidx','barsubj','barsubi','nbarnz','nunordered','buffer_subi','buffer_subj','buffer_cof','bfix','cof','subi','subj','nnz','nrows']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3D_3I_3D_3I_3I_3I(*args): # []int64,[]double,[]int32,[]double,[]int32,[]int32,[]int32
      self._ctor_init__3J_3D_3I_3D_3I_3I_3I(*args)
    elif self.__match_alt_ctor__3J_3D_3I_3D_3I_3I_3I(*args):# []int64,[]double,[]int32,[]double,[]int32,[]int32,[]int32
      self._ctor_alt_init__3J_3D_3I_3D_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ConstraintCache.ctor(array(int64,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def add(self,*args):
    if False: pass
    elif mosek_fusion_ConstraintCache._match_add__3J_3I_3D_3D(*args): # []int64,[]int32,[]double,[]double
      return self._add__3J_3I_3D_3D(*args)
    elif mosek_fusion_ConstraintCache._match_alt_add__3J_3I_3D_3D(*args): # []int64,[]int32,[]double,[]double
      return self._add_alt__3J_3I_3D_3D(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConstraintCache.add(array(int64,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1))')
  def flush(self,*args):
    if False: pass
    elif mosek_fusion_ConstraintCache._match_flush__3I_3I_3D_3D(*args): # []int32,[]int32,[]double,[]double
      return self._flush__3I_3I_3D_3D(*args)
    elif mosek_fusion_ConstraintCache._match_alt_flush__3I_3I_3D_3D(*args): # []int32,[]int32,[]double,[]double
      return self._flush_alt__3I_3I_3D_3D(*args)
    else:
      raise ValueError('Invalid argument list flush('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConstraintCache.flush(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1))')
  def numUnsorted(self,*args):
    if False: pass
    elif mosek_fusion_ConstraintCache._match_numUnsorted_(*args): # 
      return self._numUnsorted_(*args)
    elif mosek_fusion_ConstraintCache._match_alt_numUnsorted_(*args): # 
      return self._numUnsorted_alt_(*args)
    else:
      raise ValueError('Invalid argument list numUnsorted('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConstraintCache.numUnsorted()')
  def __repr__(self): return 'mosek.fusion.ConstraintCache'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConstraintCache_2(cc):
    o = ConstraintCache.__new__(ConstraintCache)
    o._ctor_init_Lmosek_4fusion_4ConstraintCache_2(cc)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConstraintCache_2(*args):
    if len(args) != 1: return False
    cc, = args
    return (__arg_match_Lmosek_4fusion_4ConstraintCache_2__(cc))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConstraintCache_2(*args):
    if len(args) != 1: return False
    cc, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConstraintCache_2__(cc))
  def _ctor_alt_init_Lmosek_4fusion_4ConstraintCache_2(self,cc):
    self._ctor_init_Lmosek_4fusion_4ConstraintCache_2(cc)
  def _ctor_init_Lmosek_4fusion_4ConstraintCache_2(self,cc):
   object.__init__(self)
   self.nrows = (cc.nrows)
   self.nnz = (cc.nnz)
   self.subj = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.subj)) if (((cc.subj) is not None) ) else None)
   self.subi = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.subi)) if (((cc.subi) is not None) ) else None)
   self.cof = (mosek.fusion.Utils.Tools._arraycopy__3D((cc.cof)) if (((cc.cof) is not None) ) else None)
   self.bfix = (mosek.fusion.Utils.Tools._arraycopy__3D((cc.bfix)) if (((cc.bfix) is not None) ) else None)
   self.buffer_cof = (mosek.fusion.Utils.Tools._arraycopy__3D((cc.buffer_cof)) if (((cc.buffer_cof) is not None) ) else None)
   self.buffer_subj = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.buffer_subj)) if (((cc.buffer_subj) is not None) ) else None)
   self.buffer_subi = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.buffer_subi)) if (((cc.buffer_subi) is not None) ) else None)
   self.nunordered = (cc.nunordered)
   self.nbarnz = (cc.nbarnz)
   self.barsubi = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.barsubi)) if (((cc.barsubi) is not None) ) else None)
   self.barsubj = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.barsubj)) if (((cc.barsubj) is not None) ) else None)
   self.barmatidx = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.barmatidx)) if (((cc.barmatidx) is not None) ) else None)
  @staticmethod
  def _ctor__3J_3D_3I_3D_3I_3I_3I(ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_):
    o = ConstraintCache.__new__(ConstraintCache)
    o._ctor_init__3J_3D_3I_3D_3I_3I_3I(ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_)
    return o
  @staticmethod
  def __match_ctor__3J_3D_3I_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_, = args
    return (__arg_match__3J__(ptrb_) and __arg_match__3D__(cof_) and __arg_match__3I__(subj_) and __arg_match__3D__(bfix_) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barmatidx_))
  @staticmethod
  def __match_alt_ctor__3J_3D_3I_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_, = args
    return (__arg_alt_match__3J__(ptrb_) and __arg_alt_match__3D__(cof_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(bfix_) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barmatidx_))
  def _ctor_alt_init__3J_3D_3I_3D_3I_3I_3I(self,ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_):
    self._ctor_init__3J_3D_3I_3D_3I_3I_3I(numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barmatidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3J_3D_3I_3D_3I_3I_3I(self,ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_):
   assert ptrb_ is None or isinstance(ptrb_,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert bfix_ is None or isinstance(bfix_,numpy.ndarray)
   assert barsubi_ is None or isinstance(barsubi_,numpy.ndarray)
   assert barsubj_ is None or isinstance(barsubj_,numpy.ndarray)
   assert barmatidx_ is None or isinstance(barmatidx_,numpy.ndarray)
   object.__init__(self)
   self.nrows = (int((ptrb_).shape[0]) - 1)
   self.nnz = ptrb_[(int((ptrb_).shape[0]) - 1)]
   self.subj = numpy.zeros((self.nnz,), dtype=numpy.dtype(numpy.int32))
   self.subi = numpy.zeros((self.nnz,), dtype=numpy.dtype(numpy.int32))
   self.cof = numpy.zeros((self.nnz,), dtype=numpy.dtype(numpy.float64))
   if (bfix_ is not None):
    self.bfix = bfix_
   else:
    self.bfix = numpy.zeros((self.nrows,), dtype=numpy.dtype(numpy.float64))
   if ((barsubi_ is not None) and ((barsubj_ is not None) and (barmatidx_ is not None))):
    self.nbarnz = int((barsubi_).shape[0])
    if (self.nbarnz > int((barsubj_).shape[0])):
     self.nbarnz = int((barsubj_).shape[0])
    if (self.nbarnz > int((barmatidx_).shape[0])):
     self.nbarnz = int((barmatidx_).shape[0])
    self.barsubi = numpy.zeros((self.nbarnz,), dtype=numpy.dtype(numpy.int32))
    self.barsubj = numpy.zeros((self.nbarnz,), dtype=numpy.dtype(numpy.int32))
    self.barmatidx = numpy.zeros((self.nbarnz,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(barsubi_,0,self.barsubi,0,self.nbarnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(barsubj_,0,self.barsubj,0,self.nbarnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(barmatidx_,0,self.barmatidx,0,self.nbarnz)
   else:
    self.nbarnz = 0
    self.barsubi = None
    self.barsubj = None
    self.barmatidx = None
   mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(subj_,0,self.subj,0,self.nnz)
   mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(cof_,0,self.cof,0,self.nnz)
   fragments._c_closure_147(self.nrows,ptrb_,self.subi) # src/fusion/ConstraintCache.mbi:103:9-105:25
   self.buffer_cof = None
   self.buffer_subj = None
   self.buffer_subi = None
   self.nunordered = 0
  def _unchecked_1add_1fx_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._unchecked_1add_1fx__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _unchecked_1add_1fx__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   fragments._c_closure_148(self.bfix,_0,self.nrows) # src/fusion/ConstraintCache.mbi:476:7-479:8
  def _order_1barentries_alt_(self,):
    return self._order_1barentries_()
  def _order_1barentries_(self,):
   _0=numpy.array([_1 for _1 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int64))
   if (not mosek.fusion.Sort._issorted__3J_3I_3IJJZ(_0,self.barsubi,self.barsubj,0,self.nbarnz,False)):
    mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,self.barsubi,self.barsubj,0,self.nbarnz,False)
    _2=self.barsubi
    _3=self.barsubj
    _4=self.barmatidx
    self.barsubi = numpy.array([_2[_0[_5]] for _5 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int32))
    self.barsubj = numpy.array([_3[_0[_6]] for _6 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int32))
    self.barmatidx = numpy.array([_4[_0[_7]] for _7 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int32))
   return numpy.int64(self.nbarnz)
  def _add_1bar_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._add_1bar__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1bar__3I_3I_3I(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (_0 is not None):
    _3=int((_0).shape[0])
    if (int((_0).shape[0]) <= (self.nbarnz + _3)):
     _4=self.barsubi
     _5=self.barsubj
     _6=self.barmatidx
     _7=((2 * self.nbarnz) if (((2 * self.nbarnz) > (self.nbarnz + _3)) ) else (self.nbarnz + (_3 * 2)))
     self.barsubi = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     self.barsubj = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     self.barmatidx = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     if (self.nbarnz > 0):
      mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_4,0,self.barsubi,0,self.nbarnz)
      mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_5,0,self.barsubj,0,self.nbarnz)
      mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_6,0,self.barmatidx,0,self.nbarnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_0,0,self.barsubi,self.nbarnz,_3)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_1,0,self.barsubj,self.nbarnz,_3)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_2,0,self.barmatidx,self.nbarnz,_3)
    self.nbarnz += _3
  def _unchecked_1add_1l_alt__3J_3I_3D_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._unchecked_1add_1l__3J_3I_3D_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _unchecked_1add_1l__3J_3I_3D_3D(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _4=(self.nunordered + _0[self.nrows])
   _5=_0[self.nrows]
   if ((self.buffer_cof is None) or (int((self.buffer_cof).shape[0]) < _4)):
    _6 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
    _7 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
    _8 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
    if (self.buffer_cof is not None):
     mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self.buffer_subi,0,_6,0,self.nunordered)
     mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self.buffer_subj,0,_7,0,self.nunordered)
     mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self.buffer_cof,0,_8,0,self.nunordered)
   else:
    _6 = self.buffer_subi
    _7 = self.buffer_subj
    _8 = self.buffer_cof
   fragments._c_closure_149(self.nrows,self.nunordered,_0,_6) # src/fusion/ConstraintCache.mbi:403:9-405:40
   mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_1,0,_7,self.nunordered,_5)
   mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_2,0,_8,self.nunordered,_5)
   self.buffer_subi = _6
   self.buffer_subj = _7
   self.buffer_cof = _8
   fragments._c_closure_150(self.bfix,_3,self.nrows) # src/fusion/ConstraintCache.mbi:413:9-415:42
   self.nunordered = _4
  @staticmethod
  def _match_add__3J_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3D__(_3))
  @staticmethod
  def _match_alt_add__3J_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3D__(_3))
  def _add_alt__3J_3I_3D_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._add__3J_3I_3D_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add__3J_3I_3D_3D(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   if ((int((_0).shape[0])!=(self.nrows + 1)) or ((_3 is not None) and (int((_3).shape[0])!=self.nrows))):
    raise mosek_fusion_LengthError._ctor_S("Mismatching expression lengths")
   self._unchecked_1add_1l__3J_3I_3D_3D(_0,_1,_2,_3)
  @staticmethod
  def _match_flush__3I_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3D__(_3))
  @staticmethod
  def _match_alt_flush__3I_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3D__(_3))
  def _flush_alt__3I_3I_3D_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._flush__3I_3I_3D_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _flush__3I_3I_3D_3D(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _4=None
   fragments._c_closure_151(self.bfix,self.nrows,_3) # src/fusion/ConstraintCache.mbi:170:9-172:34
   if (self.nunordered==0):
    return numpy.int64(0)
   _5=False
   _5 = fragments._c_closure_152(self.buffer_subi,self.buffer_subj,_5,self.nunordered) # src/fusion/ConstraintCache.mbi:180:9-184:10
   if (not _5):
    _4 = numpy.array([_6 for _6 in range(0,self.nunordered)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_4,self.buffer_subi,self.buffer_subj,0,self.nunordered)
   _7=self.nnz
   _8=numpy.zeros(((self.nunordered + _7),), dtype=numpy.dtype(numpy.int32))
   _9=numpy.zeros(((self.nunordered + _7),), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros(((self.nunordered + _7),), dtype=numpy.dtype(numpy.float64))
   _11=0
   self.nnz,_11 = fragments._c_closure_153(self.buffer_cof,self.buffer_subi,self.buffer_subj,self.cof,_5,self.nnz,_7,self.nunordered,_11,_4,_10,_8,_9,_2,_0,_1,self.subi,self.subj) # src/fusion/ConstraintCache.mbi:199:9-328:10
   self.nnz = numpy.int64(self.nnz) # postprocess
   _11 = numpy.int64(_11) # postprocess
   self.subi = _8
   self.subj = _9
   self.cof = _10
   self.nunordered = 0
   return numpy.int64(_11)
  @staticmethod
  def _match_numUnsorted_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numUnsorted_(*args):
    if len(args) != 0: return False
    return True
  def _numUnsorted_alt_(self,):
    return self._numUnsorted_()
  def _numUnsorted_(self,):
   return numpy.int64(self.nunordered)
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_ConstraintCache._ctor_Lmosek_4fusion_4ConstraintCache_2(self))
 return ConstraintCache
mosek_fusion_ConstraintCache=__mk_mosek_fusion_ConstraintCache()
del __mk_mosek_fusion_ConstraintCache
#BEFORE CLASS
def __mk_mosek_fusion_Constraint():
 class Constraint(object):
  __slots__ = ['_shape_p','_model']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args): # mosek.fusion.Constraint,mosek.fusion.Model
      self._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):# mosek.fusion.Constraint,mosek.fusion.Model
      self._ctor_alt_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Model,mosek.fusion.Set
      self._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args):# mosek.fusion.Model,mosek.fusion.Set
      self._ctor_alt_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Constraint.ctor(mosek.fusion.Constraint,mosek.fusion.Model)\n\tmosek.fusion.Constraint.ctor(mosek.fusion.Model,mosek.fusion.Set)')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_Constraint._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    elif mosek_fusion_Constraint._match_dual_II(*args): # int32,int32
      return self._dual_II(*args)
    elif mosek_fusion_Constraint._match_alt_dual_II(*args): # int32,int32
      return self._dual_alt_II(*args)
    elif mosek_fusion_Constraint._match_dual__3I_3I(*args): # []int32,[]int32
      return self._dual__3I_3I(*args)
    elif mosek_fusion_Constraint._match_alt_dual__3I_3I(*args): # []int32,[]int32
      return self._dual_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.dual()\n\tmosek.fusion.Constraint.dual(int32,int32)\n\tmosek.fusion.Constraint.dual(array(int32,ndim=1),array(int32,ndim=1))')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Constraint._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Constraint._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Constraint._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.index(int32)\n\tmosek.fusion.Constraint.index(array(int32,ndim=1))')
  def add(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_add_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._add_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Constraint._match_alt_add_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._add_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Constraint._match_add_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return self._add_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Constraint._match_alt_add_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return self._add_alt_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Constraint._match_add__3D(*args): # []double
      return self._add__3D(*args)
    elif mosek_fusion_Constraint._match_alt_add__3D(*args): # []double
      return self._add_alt__3D(*args)
    elif mosek_fusion_Constraint._match_add_D(*args): # double
      return self._add_D(*args)
    elif mosek_fusion_Constraint._match_alt_add_D(*args): # double
      return self._add_alt_D(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.add(mosek.fusion.Expression)\n\tmosek.fusion.Constraint.add(mosek.fusion.Variable)\n\tmosek.fusion.Constraint.add(array(double,ndim=1))\n\tmosek.fusion.Constraint.add(double)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Constraint._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Constraint._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Constraint._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.slice(int32,int32)\n\tmosek.fusion.Constraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def shape(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_shape_(*args): # 
      return self._shape_(*args)
    elif mosek_fusion_Constraint._match_alt_shape_(*args): # 
      return self._shape_alt_(*args)
    else:
      raise ValueError('Invalid argument list shape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.shape()')
  def get_model(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_get_1model_(*args): # 
      return self._get_1model_(*args)
    elif mosek_fusion_Constraint._match_alt_get_1model_(*args): # 
      return self._get_1model_alt_(*args)
    else:
      raise ValueError('Invalid argument list get_model('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.get_model()')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_Constraint._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.size()')
  def get_nd(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_get_1nd_(*args): # 
      return self._get_1nd_(*args)
    elif mosek_fusion_Constraint._match_alt_get_1nd_(*args): # 
      return self._get_1nd_alt_(*args)
    else:
      raise ValueError('Invalid argument list get_nd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.get_nd()')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Constraint._match_stack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._stack__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_stack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._stack_alt__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.stack(array(mosek.fusion.Constraint,ndim=1))\n\tmosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint)\n\tmosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Constraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.toString()')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_Constraint._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.level()')
  def __repr__(self): return 'mosek.fusion.Constraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m):
    o = Constraint.__new__(Constraint)
    o._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m):
   object.__init__(self)
   self._model = m
   self._shape_p = (c._shape_p)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(model_,shape_):
    o = Constraint.__new__(Constraint)
    o._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(model_,shape_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    model_,shape_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    model_,shape_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,model_,shape_):
    self._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(model_,shape_)
  def _ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,model_,shape_):
   object.__init__(self)
   self._model = model_
   self._shape_p = shape_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=(self._shape_p._size)
   _1=numpy.zeros((_0,), dtype=numpy.dtype(object))
   self._toStringArray__3JJ_3S(mosek.fusion.Utils.Tools._range_J(_0),0,_1)
   _2=mosek.fusion.Utils.StringBuffer()
   _2._a_S("Constraint( (")._a_I(self._shape_p._dim_I(0))
   for _3 in range(1,(self._shape_p.nd)):
    _2._a_S(",")._a_I(self._shape_p._dim_I(_3))
   _2._a_S("),")._lf_()
   _2._a_S("  ")._a_S(_1[0])
   for _4 in range(1,int((_1).shape[0])):
    _2._a_S(",")._lf_()._a_S("  ")._a_S(_1[_4])
   _2._a_S(" )")
   return (_2._toString_())
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  @staticmethod
  def _match_add_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_add_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _add_alt_D(self,_t__0):
    return self._add_D(numpy.float64(__0))
  def _add_D(self,_0):
   _1=(self._shape_p._size)
   self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(numpy.array([_2 for _2 in range(0,_1)], dtype=numpy.dtype(numpy.int64)),numpy.array([0 for _3 in range(0,(_1 + 1))], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),numpy.array([_0 for _4 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),0,0,numpy.int32(_1))
   return (self)
  @staticmethod
  def _match_add__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_add__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _add_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._add__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=(self._shape_p._size)
   if (((self._shape_p.nd)!=1) or (int((_0).shape[0])!=self._shape_p._dim_I(0))):
    raise mosek_fusion_DimensionError._ctor_S("The added constant array does not have the same shape as the constraint")
   self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(numpy.array([_2 for _2 in range(0,_1)], dtype=numpy.dtype(numpy.int64)),numpy.array([0 for _3 in range(0,(_1 + 1))], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),_0,0,0,numpy.int32(_1))
   return (self)
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  def _add_alt_Lmosek_4fusion_4Variable_2(self,_t__0):
    return self._add_Lmosek_4fusion_4Variable_2(_0)
  def _add_Lmosek_4fusion_4Variable_2(self,_0):
   if (not _0._shape_()._compare_Lmosek_4fusion_4Set_2(self._shape_p)):
    raise mosek_fusion_DimensionError._ctor_S("The added variable does not have the same shape as the constraint")
   _1=(_0._getShape_()._size)
   _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _5=mosek.fusion.Utils.Tools._range_JJ(0,(_1 + 1))
   _6=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
   for _7 in range(0,_1):
    _0._inst_JJ_3I_3I_3I(_7,_7,_2,_3,_4)
    _6[_7] = 1.0
   _8=mosek.fusion.Utils.Tools._range_JJ(0,_1)
   self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_8,_5,_2,_3,_3,_6,None,0,0,numpy.int32(_1))
   return (self)
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  def _add_alt_Lmosek_4fusion_4Expression_2(self,_t__0):
    return self._add_Lmosek_4fusion_4Expression_2(_0)
  def _add_Lmosek_4fusion_4Expression_2(self,_0):
   if (not _0._shape_()._compare_Lmosek_4fusion_4Set_2(self._shape_p)):
    raise mosek_fusion_DimensionError._ctor_S("The added expression does not have the same shape as the constraint")
   _1=_0._eval_()
   _2=(int(((_1.ptrb)).shape[0]) - 1)
   _3=numpy.zeros(((_1.nnz),), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros(((_1.nnz),), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros(((_1.nnz),), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Constraint._inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I((_1.x),(_1.subj),_3,_3,_3)
   _6=(_1.inst)
   if (_6 is None):
    _6 = mosek.fusion.Utils.Tools._range_JJ(0,numpy.int64(_2))
   self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_6,(_1.ptrb),_3,_4,_5,(_1.cof),(_1.bfix),0,0,_2)
   return (self)
  @staticmethod
  def _inst_alt__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Constraint._inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inst__3Lmosek_4fusion_4Variable_2_3J_3I_3I_3I(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=numpy.zeros(((int((_0).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
   for _6 in range(0,int((_0).shape[0])):
    _5[(_6 + 1)] = (_5[_6] + _0[_6]._size_())
   for _7 in range(0,int((_1).shape[0])):
    _8=(int((_5).shape[0]) // 2)
    _8 = fragments._c_closure_154(_7,_8,_1,_5) # src/fusion/Constraint.mbi:631:11-644:12
    _8 = numpy.int32(_8) # postprocess
    _0[_8]._inst_JJ_3I_3I_3I((_1[_7] - _5[_8]),numpy.int64(_7),_2,_3,_4)
  def _add_1l_alt__3J_3J_3I_3I_3I_3D_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.int64(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.int32(_t__9)
   _1 = self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1l__3J_3J_3I_3I_3I_3D_3DJII(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   pass
  @staticmethod
  def _match_dual__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_dual__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _dual_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._dual__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (((self._shape_p.nd)!=int((_0).shape[0])) or ((self._shape_p.nd)!=int((_1).shape[0]))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   _2=1
   _3=0
   while (_3 < (self._shape_p.nd)):
    if ((_0[_3] > _1[_3]) or ((_0[_3] < 0) or (_1[_3] >= self._shape_p._dim_I(_3)))):
     raise mosek_fusion_SliceError._ctor_S("Slice index out of bound")
    _2 = (_2 * (_1[_3] * _0[_3]))
    _3 += 1
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _5=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _7=0
   for _8 in range(0,(self._shape_p.nd)):
    _5[_8] = (_1[_8] - _0[_8])
    _6[_8] = self._shape_p._stride_I(_8)
    _7 = (_7 + (_6[_8] * _0[_8]))
   self._dual_1values_J_3I_3JI_3D(_7,_5,_6,0,_4)
   return (_4)
  @staticmethod
  def _match_dual_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_dual_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _dual_alt_II(self,_t__0,_t__1):
    return self._dual_II(numpy.int32(__0),numpy.int32(__1))
  def _dual_II(self,_0,_1):
   if (((self._shape_p.nd)!=1) or ((_0 > _1) or ((_0 < 0) or (_1 >= self._shape_p._dim_I(0))))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   _2=(_1 - _0)
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   self._dual_1values_J_3I_3JI_3D(_0,numpy.array([_2], dtype=numpy.dtype(numpy.int32)),numpy.array([1], dtype=numpy.dtype(numpy.int64)),0,_3)
   return (_3)
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros(((self._shape_p._size),), dtype=numpy.dtype(numpy.float64))
   self._dual_1values_I_3D(0,_0)
   return (_0)
  def _dual_1values_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_I_3D(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=numpy.array([self._shape_p._dim_I(_3) for _3 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
   _4=numpy.array([self._shape_p._stride_I(_5) for _5 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int64))
   self._dual_1values_J_3I_3JI_3D(0,_2,_4,_0,_1)
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   pass
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   _0=numpy.zeros(((self._shape_p._size),), dtype=numpy.dtype(numpy.float64))
   self._level_1values_I_3D(0,_0)
   return (_0)
  def _level_alt_I(self,_t__0):
    return self._level_I(numpy.int32(__0))
  def _level_I(self,_0):
   if (((self._shape_p.nd)!=1) or ((_0 < 0) or (_0 >= self._shape_p._dim_I(0)))):
    raise mosek_fusion_SliceError._ctor_S("Invalid index.")
   _1=numpy.array([numpy.int64(_0)], dtype=numpy.dtype(numpy.int64))
   _2=numpy.zeros((1,), dtype=numpy.dtype(numpy.float64))
   self._level_1values__3JI_3D(_1,0,_2)
   return numpy.float64(_2[0])
  def _level_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._level__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (((self._shape_p.nd)!=int((_0).shape[0])) or ((self._shape_p.nd)!=int((_1).shape[0]))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   _2=1
   _3=0
   while (_3 < (self._shape_p.nd)):
    if ((_0[_3] > _1[_3]) or ((_0[_3] < 0) or (_1[_3] > self._shape_p._dim_I(_3)))):
     raise mosek_fusion_SliceError._ctor_S("Slice index out of bound")
    _2 = (_2 * (_1[_3] - _0[_3]))
    _3 += 1
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   if (_2 > 0):
    _5=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
    for _7 in range(0,(self._shape_p.nd)):
     _6[_7] = self._shape_p._stride_I(_7)
    for _8 in range(0,(self._shape_p.nd)):
     _5[_8] = (_1[_8] - _0[_8])
    _9=0
    for _10 in range(0,(self._shape_p.nd)):
     _9 = (_9 + (numpy.int64(_0[_10]) * _6[_10]))
    self._level_1values_J_3I_3JI_3D(_9,_5,_6,0,_4)
   return (_4)
  def _level_alt_II(self,_t__0,_t__1):
    return self._level_II(numpy.int32(__0),numpy.int32(__1))
  def _level_II(self,_0,_1):
   if (((self._shape_p.nd)!=1) or ((_0 < 0) or ((_0 > _1) or (_1 > self._shape_p._dim_I(0))))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   _2=(_1 - _0)
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _4=numpy.array([(_1 - _0)], dtype=numpy.dtype(numpy.int32))
   _5=numpy.array([1], dtype=numpy.dtype(numpy.int64))
   self._level_1values_J_3I_3JI_3D(numpy.int64(_0),_4,_5,0,_3)
   return (_3)
  def _level_1values_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_I_3D(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=numpy.array([self._shape_p._stride_I(_3) for _3 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int64))
   _4=numpy.array([self._shape_p._dim_I(_5) for _5 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
   self._level_1values_J_3I_3JI_3D(0,_4,_2,_0,_1)
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   pass
  @staticmethod
  def _match_get_1model_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_1model_(*args):
    if len(args) != 0: return False
    return True
  def _get_1model_alt_(self,):
    return self._get_1model_()
  def _get_1model_(self,):
   return (self._model)
  @staticmethod
  def _match_get_1nd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_1nd_(*args):
    if len(args) != 0: return False
    return True
  def _get_1nd_alt_(self,):
    return self._get_1nd_()
  def _get_1nd_(self,):
   return numpy.int32((self._shape_p._nd_p))
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int64((self._shape_p._size))
  @staticmethod
  def _match_stack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _match_alt_stack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _stack_alt__3Lmosek_4fusion_4Constraint_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Constraint._stack__3Lmosek_4fusion_4Constraint_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3Lmosek_4fusion_4Constraint_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_CompoundConstraint._ctor__3Lmosek_4fusion_4Constraint_2(_0))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2)
  @staticmethod
  def _stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2):
   _3=numpy.array([_0,_1], dtype=numpy.dtype(object))
   return (mosek_fusion_CompoundConstraint._ctor__3Lmosek_4fusion_4Constraint_2(_3))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1):
    return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1)
  @staticmethod
  def _stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1):
   _2=numpy.array([_0,_1], dtype=numpy.dtype(object))
   return (mosek_fusion_CompoundConstraint._ctor__3Lmosek_4fusion_4Constraint_2(_2))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self._slice__3I_3I(_0,numpy.array([(_0[_1] + 1) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))).__reduceDims_())
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   return (self._slice_II(_0,(_0 + 1)))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  def __reduceDims_alt_(self,):
    return self.__reduceDims_()
  def __reduceDims_(self,):
   if ((self._shape_p.nd) > 1):
    _0=self._shape_p._realnd_()
    _1=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    _2=0
    _3=0
    while (_3 < _0):
     if (self._shape_p._dim_I(_3) > 1):
      _1[_2] = self._shape_p._dim_I(_3)
      _2 += 1
     _3 += 1
    self._shape_p = mosek_fusion_NDSet._ctor__3I(_1)
   return (self)
  @staticmethod
  def _match_shape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_shape_(*args):
    if len(args) != 0: return False
    return True
  def _shape_alt_(self,):
    return self._shape_()
  def _shape_(self,):
   return (self._shape_p)
 return Constraint
mosek_fusion_Constraint=__mk_mosek_fusion_Constraint()
del __mk_mosek_fusion_Constraint
#BEFORE CLASS
def __mk_mosek_fusion_CompoundConstraint():
 class CompoundConstraint(mosek_fusion_Constraint):
  __slots__ = ['_CompoundConstraint__stackdim','_CompoundConstraint__consb','_CompoundConstraint__cons']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      self._ctor_init__3Lmosek_4fusion_4Constraint_2(*args)
    elif self.__match_alt_ctor__3Lmosek_4fusion_4Constraint_2(*args):# []mosek.fusion.Constraint
      self._ctor_alt_init__3Lmosek_4fusion_4Constraint_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.CompoundConstraint.ctor(array(mosek.fusion.Constraint,ndim=1))')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_CompoundConstraint._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_CompoundConstraint._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_CompoundConstraint._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_CompoundConstraint._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundConstraint.slice(int32,int32)\n\tmosek.fusion.CompoundConstraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def add(self,*args):
    if False: pass
    elif mosek_fusion_CompoundConstraint._match_add_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return self._add_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_CompoundConstraint._match_alt_add_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return self._add_alt_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_CompoundConstraint._match_add_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._add_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_CompoundConstraint._match_alt_add_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._add_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_CompoundConstraint._match_add__3D(*args): # []double
      return self._add__3D(*args)
    elif mosek_fusion_CompoundConstraint._match_alt_add__3D(*args): # []double
      return self._add_alt__3D(*args)
    elif mosek_fusion_CompoundConstraint._match_add_D(*args): # double
      return self._add_D(*args)
    elif mosek_fusion_CompoundConstraint._match_alt_add_D(*args): # double
      return self._add_alt_D(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CompoundConstraint.add(mosek.fusion.Variable)\n\tmosek.fusion.CompoundConstraint.add(mosek.fusion.Expression)\n\tmosek.fusion.CompoundConstraint.add(array(double,ndim=1))\n\tmosek.fusion.CompoundConstraint.add(double)')
  def __repr__(self): return 'mosek.fusion.CompoundConstraint'
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Constraint_2(c):
    o = CompoundConstraint.__new__(CompoundConstraint)
    o._ctor_init__3Lmosek_4fusion_4Constraint_2(c)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    c, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(c))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    c, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(c))
  def _ctor_alt_init__3Lmosek_4fusion_4Constraint_2(self,c):
    self._ctor_init__3Lmosek_4fusion_4Constraint_2(numpy.array(c,dtype=numpy.dtype(object)))
  def _ctor_init__3Lmosek_4fusion_4Constraint_2(self,c):
   assert c is None or isinstance(c,numpy.ndarray)
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,mosek.fusion.CompoundConstraint.__model_1from_1con__3Lmosek_4fusion_4Constraint_2(c),mosek.fusion.CompoundConstraint.__compute_1shape__3Lmosek_4fusion_4Constraint_2I(c,0))
   _0=0
   _1=0
   _2=0
   _3=0
   while (_3 < int((c).shape[0])):
    if (((c[_3]._shape_p)._size)==1):
     _1 += 1
     _2 += 1
    elif (((c[_3]._shape_p)._size) > 1):
     _1 += 1
     _2 = (_2 + (c[_3]._shape_p)._dim_I(_0))
    _3 += 1
   self.__cons = numpy.zeros((_1,), dtype=numpy.dtype(object))
   self.__consb = numpy.zeros(((_1 + 1),), dtype=numpy.dtype(numpy.int32))
   self.__consb[0] = 0
   self.__stackdim = _0
   _4=0
   _5=0
   while (_5 < int((c).shape[0])):
    if (((c[_5]._shape_p)._size) > 0):
     self.__cons[_4] = c[_5]
     _4 += 1
     if (((c[_5]._shape_p)._size)==1):
      self.__consb[(_5 + 1)] = (self.__consb[_5] + 1)
     else:
      self.__consb[(_5 + 1)] = (self.__consb[_5] + (c[_5]._shape_p)._dim_I(_0))
    _5 += 1
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   raise mosek_fusion_UnimplementedError._ctor_S("SliceConstraint.toStringArray() not implemented")
  def _add_1l_alt__3J_3J_3I_3I_3I_3D_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.int64(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.int32(_t__9)
   _1 = self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1l__3J_3J_3I_3I_3I_3D_3DJII(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   _10=numpy.array([(_0[(_8 + _11)] - _7) for _11 in range(0,_9)], dtype=numpy.dtype(numpy.int64))
   _12=numpy.array([_13 for _13 in range(0,_9)], dtype=numpy.dtype(numpy.int64))
   _14=numpy.array([self._shape_p._idxtokey_J((_0[(_8 + _15)] - _7))[self.__stackdim] for _15 in range(0,_9)], dtype=numpy.dtype(numpy.int64))
   mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_12,_14,_10,0,numpy.int64(_9))
   _16=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_155(_14,self.__consb,_16,_9,_12) # src/fusion/CompoundConstraint.mbi:385:9-393:10
   _17=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
   _18=numpy.zeros(((_9 + 1),), dtype=numpy.dtype(numpy.int64))
   _19=(_1[(_8 + _9)] - _1[_8])
   _20=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _21=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _22=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _23=numpy.zeros((_19,), dtype=numpy.dtype(numpy.float64))
   _24=(None if ((_6 is None) ) else numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64)))
   _18[0] = 0
   for _25 in range(0,_9):
    _26=_16[_25]
    if (((self.__cons[_26]._shape_p)._size)==1):
     _17[_25] = 0
    else:
     _27=self._shape_p._idxtokey_J(_10[_12[_25]])
     _27[self.__stackdim] = (_27[self.__stackdim] - self.__consb[_26])
     _17[_25] = (self.__cons[_26]._shape_p)._linearidx__3I(_27)
    _28=(_1[(_12[_25] + 1)] - _1[_12[_25]])
    _18[(_25 + 1)] = (_18[_25] + _28)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_2,_1[_12[_25]],_20,_18[_25],_28)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_3,_1[_12[_25]],_21,_18[_25],_28)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_4,_1[_12[_25]],_22,_18[_25],_28)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_5,_1[_12[_25]],_23,_18[_25],_28)
   fragments._c_closure_156(_6,_9,_12,_24) # src/fusion/CompoundConstraint.mbi:426:11-428:42
   _29=0
   while (_29 < _9):
    _30=_29
    _29 += 1
    _29 = fragments._c_closure_157(_16,_29,_30,_9) # src/fusion/CompoundConstraint.mbi:435:36-86
    _29 = numpy.int32(_29) # postprocess
    self.__cons[_16[_30]]._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_17,_18,_20,_21,_22,_23,_24,0,_30,(_29 - _30))
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=int((_2).shape[0])
   _6=_1[0]
   _6 = fragments._c_closure_158(_1,_6) # src/fusion/CompoundConstraint.mbi:312:9-70
   _6 = numpy.int32(_6) # postprocess
   _7=numpy.array([_0 for _8 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _9=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _11[((self._shape_p.nd) - 1)] = 1
   for _12 in range(1,(self._shape_p.nd)):
    _11[(((self._shape_p.nd) - _12) - 1)] = (_11[((self._shape_p.nd) - _12)] * self._shape_p._dim_I(((self._shape_p.nd) - _12)))
   _13=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   for _14 in range(0,_6):
    _15=_7[0]
    for _16 in range(0,(self._shape_p.nd)):
     _10[_16] = numpy.int32((_15 // _11[_16]))
     _15 = (_15 - (numpy.int64(_10[_16]) * _11[_16]))
    _17=0
    _17 = fragments._c_closure_159(self.__consb,_10,self.__stackdim,_17) # src/fusion/CompoundConstraint.mbi:343:13-61
    _17 = numpy.int32(_17) # postprocess
    _10[self.__stackdim] = (_10[self.__stackdim] - self.__consb[_17])
    _13[0] = (self.__cons[_17]._shape_p)._linearidx__3I(_10)
    self.__cons[_17]._dual_1values__3JI_3D(_13,(_3 + _14),_4)
    _9[0] += 1
    _7[0] = (_7[0] + _2[(_5 - 1)])
    _18=0
    _18 = 0
    while ((_18 < (_5 - 1)) and (_9[_18]==_1[_18])):
     _9[_18] = 0
     _9[(_18 + 1)] += 1
     _18 += 1
    fragments._c_closure_160(_18,_7) # src/fusion/CompoundConstraint.mbi:359:13-360:28
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _5 in range(0,int((_0).shape[0])):
    _6=numpy.int64(_0[_5])
    for _7 in range(0,(self._shape_p.nd)):
     _4[_7] = numpy.int32((_6 // self._shape_p._stride_I(_7)))
     _6 = (_6 - (numpy.int64(_4[_7]) * self._shape_p._stride_I(_7)))
    _8=0
    _8 = fragments._c_closure_161(self.__consb,_4,self.__stackdim,_8) # src/fusion/CompoundConstraint.mbi:295:13-61
    _8 = numpy.int32(_8) # postprocess
    _4[self.__stackdim] = (_4[self.__stackdim] - self.__consb[_8])
    _3[0] = (self.__cons[_8]._shape_p)._linearidx__3I(_4)
    self.__cons[_8]._dual_1values__3JI_3D(_3,(_1 + _5),_2)
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=int((_2).shape[0])
   _6=_1[0]
   _6 = fragments._c_closure_162(_1,_6) # src/fusion/CompoundConstraint.mbi:218:9-70
   _6 = numpy.int32(_6) # postprocess
   _7=numpy.array([_0 for _8 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _9=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _11[((self._shape_p.nd) - 1)] = 1
   for _12 in range(1,(self._shape_p.nd)):
    _11[(((self._shape_p.nd) - _12) - 1)] = (_11[((self._shape_p.nd) - _12)] * self._shape_p._dim_I(((self._shape_p.nd) - _12)))
   _13=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   for _14 in range(0,_6):
    _15=_7[0]
    for _16 in range(0,(self._shape_p.nd)):
     _10[_16] = numpy.int32((_15 // _11[_16]))
     _15 = (_15 - (numpy.int64(_10[_16]) * _11[_16]))
    _17=0
    _17 = fragments._c_closure_163(self.__consb,_10,self.__stackdim,_17) # src/fusion/CompoundConstraint.mbi:249:13-61
    _17 = numpy.int32(_17) # postprocess
    _10[self.__stackdim] = (_10[self.__stackdim] - self.__consb[_17])
    _13[0] = (self.__cons[_17]._shape_p)._linearidx__3I(_10)
    self.__cons[_17]._level_1values__3JI_3D(_13,(_3 + _14),_4)
    _9[0] += 1
    _7[0] = (_7[0] + _2[(_5 - 1)])
    _18=0
    _18 = 0
    while ((_18 < (_5 - 1)) and (_9[_18]==_1[_18])):
     _9[_18] = 0
     _9[(_18 + 1)] += 1
     _18 += 1
    fragments._c_closure_164(_18,_7) # src/fusion/CompoundConstraint.mbi:265:13-266:28
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int32))
   for _5 in range(0,int((_0).shape[0])):
    _6=numpy.int64(_0[_5])
    for _7 in range(0,(self._shape_p.nd)):
     _4[_7] = numpy.int32((_6 // self._shape_p._stride_I(_7)))
     _6 = (_6 - (numpy.int64(_4[_7]) * self._shape_p._stride_I(_7)))
    _8=0
    _8 = fragments._c_closure_165(self.__consb,_4,self.__stackdim,_8) # src/fusion/CompoundConstraint.mbi:201:13-61
    _8 = numpy.int32(_8) # postprocess
    _4[self.__stackdim] = (_4[self.__stackdim] - self.__consb[_8])
    _3[0] = (self.__cons[_8]._shape_p)._linearidx__3I(_4)
    self.__cons[_8]._level_1values__3JI_3D(_3,(_1 + _5),_2)
  def _add_alt__3J_3I_3D_3DI_3II(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.int32(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.int32(_t__6)
   _1 = self._add__3J_3I_3D_3DI_3II(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add__3J_3I_3D_3DI_3II(self,_0,_1,_2,_3,_4,_5,_6):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   raise mosek_fusion_UnimplementedError._ctor_S("Functionality not implemented yet.")
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   raise mosek_fusion_UnimplementedError._ctor_S("Compound constraints cannot be sliced")
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   raise mosek_fusion_UnimplementedError._ctor_S("Compound constraints cannot be sliced")
  @staticmethod
  def __compute_1shape_alt__3Lmosek_4fusion_4Constraint_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CompoundConstraint.__compute_1shape__3Lmosek_4fusion_4Constraint_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __compute_1shape__3Lmosek_4fusion_4Constraint_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=_0[0]._shape_()
   _3=0
   for _4 in range(0,int((_0).shape[0])):
    if (((_0[_4]._shape_p)._size) > 0):
     if (((_0[_4]._shape_p).nd)!=(_2.nd)):
      raise mosek_fusion_DimensionError._ctor_S("Mismatching variable shape")
     _5=0
     while (_5 < (_2.nd)):
      if ((_5!=_1) and (_2._dim_I(_5)!=(_0[_4]._shape_p)._dim_I(_5))):
       raise mosek_fusion_DimensionError._ctor_S("Mismatching variable shape")
      _5 += 1
     _3 = (_3 + (_0[_4]._shape_p)._dim_I(_1))
    else:
     raise mosek_fusion_DimensionError._ctor_S("Empty element in compound variable")
   if ((_2.nd)==1):
    return (mosek_fusion_IntSet._ctor_I(_3))
   else:
    _6=numpy.array([_2._dim_I(_7) for _7 in range(0,(_2.nd))], dtype=numpy.dtype(numpy.int32))
    _6[_1] = _3
    return (mosek_fusion_NDSet._ctor__3I(_6))
  @staticmethod
  def __count_1numcon_alt__3Lmosek_4fusion_4Constraint_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_CompoundConstraint.__count_1numcon__3Lmosek_4fusion_4Constraint_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __count_1numcon__3Lmosek_4fusion_4Constraint_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=0
   _2=0
   while (_2 < int((_0).shape[0])):
    _3=_0[_2]
    _5=_3
    if   isinstance(_5,mosek_fusion_CompoundConstraint):
     cc=_5
     _1 = (_1 + int(((cc.__cons)).shape[0]))
    else:
     cc=_5
     _1 += 1
    _2 += 1
   return numpy.int32(_1)
  @staticmethod
  def __model_1from_1con_alt__3Lmosek_4fusion_4Constraint_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_CompoundConstraint.__model_1from_1con__3Lmosek_4fusion_4Constraint_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __model_1from_1con__3Lmosek_4fusion_4Constraint_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return ((_0[0]._model))
 return CompoundConstraint
mosek_fusion_CompoundConstraint=__mk_mosek_fusion_CompoundConstraint()
del __mk_mosek_fusion_CompoundConstraint
#BEFORE CLASS
def __mk_mosek_fusion_SliceConstraint():
 class SliceConstraint(mosek_fusion_Constraint):
  __slots__ = ['_strides','_first','_origin']
  def size(self,*args):
    if False: pass
    elif mosek_fusion_SliceConstraint._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_SliceConstraint._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceConstraint.size()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_SliceConstraint._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_SliceConstraint._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_SliceConstraint._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_SliceConstraint._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceConstraint.slice(int32,int32)\n\tmosek.fusion.SliceConstraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.SliceConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(origin_,shape_,first_,strides_):
    o = SliceConstraint.__new__(SliceConstraint)
    o._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(origin_,shape_,first_,strides_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(*args):
    if len(args) != 4: return False
    origin_,shape_,first_,strides_, = args
    return (__arg_match_Lmosek_4fusion_4ModelConstraint_2__(origin_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match_J__(first_) and __arg_match__3J__(strides_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(*args):
    if len(args) != 4: return False
    origin_,shape_,first_,strides_, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(origin_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match_J__(first_) and __arg_alt_match__3J__(strides_))
  def _ctor_alt_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(self,origin_,shape_,first_,strides_):
    self._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(origin_,shape_,numpy.int64(first_),numpy.array(strides_,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(self,origin_,shape_,first_,strides_):
   assert strides_ is None or isinstance(strides_,numpy.ndarray)
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,(origin_._model),shape_)
   self._origin = origin_
   self._first = first_
   self._strides = strides_
  def _add_1l_alt__3J_3J_3I_3I_3I_3D_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.int64(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.int32(_t__9)
   _1 = self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1l__3J_3J_3I_3I_3I_3D_3DJII(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   _10=(_1[(_8 + _9)] - _1[_8])
   _11=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
   _12=numpy.zeros(((_9 + 1),), dtype=numpy.dtype(numpy.int64))
   _13=(None if ((_6 is None) ) else numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64)))
   fragments._c_closure_166(_9,_1,_12,_8) # src/fusion/SliceConstraint.mbi:346:9-63
   if ((self._shape_p.nd)==1):
    fragments._c_closure_167(self._first,_9,_11,_8,_0,_7) # src/fusion/SliceConstraint.mbi:349:9-352:10
   else:
    for _14 in range(0,_9):
     _15=self._shape_p._idxtokey_J((_0[(_8 + _14)] - _7))
     _16=0
     _16 = fragments._c_closure_168(_15,_16,self._strides) # src/fusion/SliceConstraint.mbi:359:13-92
     _16 = numpy.int64(_16) # postprocess
     _11[_14] = _16
   if (_6 is not None):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_6,_8,_13,0,_9)
   self._origin._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_11,_12,_2,_3,_4,_5,_13,0,0,_9)
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_1,_3,_6,0,_4)
   for _7 in range(0,_4):
    _8=self._shape_p._idxtokey_J(_0[(_3 + _7)])
    _9=0
    _9 = fragments._c_closure_169(_8,_9,self._strides) # src/fusion/SliceConstraint.mbi:319:11-90
    _9 = numpy.int64(_9) # postprocess
    _5[_7] = _9
   self._origin._add_1fx__3J_3DJII(_5,_6,0,0,_4)
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((_0==0) and ((int((_1).shape[0])==1) and ((_1[0]==(self._shape_p._size)) and (_2[0]==1)))):
    _5=numpy.array([self._shape_p._dim_I(_6) for _6 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
    self._origin._dual_1values_J_3I_3JI_3D(self._first,_5,self._strides,_3,_4)
   else:
    _7=int((_1).shape[0])
    _8=(_7==(self._shape_p.nd))
    _9=0
    while ((_9 < _7) and _8):
     _8 = (_2[_9]==self._shape_p._stride_I(_9))
     _9 += 1
    if _8:
     _10=self._first
     _11=_0
     for _12 in range(0,((self._shape_p.nd) - 1)):
      _13=(_11 // _2[_12])
      _11 = (_11 - (_2[_12] * _13))
      _10 = (_10 + (self._shape_p._stride_I(_12) * _13))
     self._origin._dual_1values_J_3I_3JI_3D(_10,_1,self._strides,_3,_4)
    else:
     _14=1
     _14 = fragments._c_closure_170(_1,_14) # src/fusion/SliceConstraint.mbi:263:33-96
     _14 = numpy.int64(_14) # postprocess
     _15=numpy.zeros((_14,), dtype=numpy.dtype(numpy.int64))
     _16=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
     _17=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int64))
     fragments._c_closure_171(_1,_17) # src/fusion/SliceConstraint.mbi:268:49-88
     for _18 in range(0,_14):
      _19=(_0 + _17[0])
      _20=0
      for _21 in range(0,(self._shape_p.nd)):
       _22=(_19 // self._shape_p._stride_I(_21))
       _20 = (_20 + (self._strides[_21] * _22))
       _19 = (_19 - (_22 * self._shape_p._stride_I(_21)))
      _15[_18] = _20
      _23=0
      _16[0] += 1
      _17[0] = (_17[0] + _2[(_7 - 1)])
      while ((_23 < (_7 - 1)) and (_16[_23] >= _1[((_7 - _23) - 1)])):
       _17[_23] = 0
       _17[_23] = (_17[_23] + _2[((_7 - _23) - 1)])
       _16[_23] = 0
       _16[(_23 + 1)] += 1
       _23 += 1
      fragments._c_closure_172(_23,_17) # src/fusion/SliceConstraint.mbi:292:20-55
     self._origin._dual_1values__3JI_3D(_15,_3,_4)
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _4 in range(0,int((_0).shape[0])):
    _5=self._shape_p._idxtokey_J(_0[_4])
    _6=0
    for _7 in range(0,(self._shape_p.nd)):
     _6 = (_6 + (numpy.int64(_5[_7]) * self._strides[_7]))
    _3[_4] = _6
   self._origin._dual_1values__3JI_3D(_3,_1,_2)
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((_0==0) and ((int((_1).shape[0])==1) and ((_1[0]==(self._shape_p._size)) and (_2[0]==1)))):
    _5=numpy.array([self._shape_p._dim_I(_6) for _6 in range(0,(self._shape_p.nd))], dtype=numpy.dtype(numpy.int32))
    self._origin._level_1values_J_3I_3JI_3D(self._first,_5,self._strides,_3,_4)
   else:
    _7=int((_1).shape[0])
    _8=(_7==(self._shape_p.nd))
    _9=0
    while ((_9 < _7) and _8):
     _8 = (_2[_9]==self._shape_p._stride_I(_9))
     _9 += 1
    if _8:
     _10=self._first
     _11=_0
     for _12 in range(0,((self._shape_p.nd) - 1)):
      _13=(_11 // _2[_12])
      _11 = (_11 - (_2[_12] * _13))
      _10 = (_10 + (self._shape_p._stride_I(_12) * _13))
     self._origin._level_1values_J_3I_3JI_3D(_10,_1,self._strides,_3,_4)
    else:
     _14=1
     _14 = fragments._c_closure_173(_1,_14) # src/fusion/SliceConstraint.mbi:161:33-96
     _14 = numpy.int64(_14) # postprocess
     _15=numpy.zeros((_14,), dtype=numpy.dtype(numpy.int64))
     _16=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int32))
     _17=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int64))
     for _18 in range(0,_14):
      _19=(_0 + _17[0])
      _20=0
      for _21 in range(0,(self._shape_p.nd)):
       _22=(_19 // self._shape_p._stride_I(_21))
       _20 = (_20 + (self._strides[_21] * _22))
       _19 = (_19 - (_22 * self._shape_p._stride_I(_21)))
      _15[_18] = _20
      _23=0
      _16[0] += 1
      _17[0] = (_17[0] + _2[(_7 - 1)])
      while ((_23 < (_7 - 1)) and (_16[_23] >= _1[((_7 - _23) - 1)])):
       _17[_23] = 0
       _17[_23] = (_17[_23] + _2[((_7 - _23) - 1)])
       _16[_23] = 0
       _16[(_23 + 1)] += 1
       _23 += 1
      fragments._c_closure_174(_23,_17) # src/fusion/SliceConstraint.mbi:190:20-55
     self._origin._level_1values__3JI_3D(_15,_3,_4)
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _4 in range(0,int((_0).shape[0])):
    _5=self._shape_p._idxtokey_J(_0[_4])
    _6=0
    for _7 in range(0,(self._shape_p.nd)):
     _6 = (_6 + (numpy.int64(_5[_7]) * self._strides[_7]))
    _3[_4] = _6
   self._origin._level_1values__3JI_3D(_3,_1,_2)
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _4 in range(0,int((_0).shape[0])):
    _5=self._shape_p._idxtokey_J(_0[_4])
    _6=0
    for _7 in range(0,(self._shape_p.nd)):
     _6 = (_6 + (numpy.int64(_5[_7]) * self._strides[_7]))
    _3[_4] = _6
   self._origin._toStringArray__3JJ_3S(_3,_1,_2)
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int64((self._shape_p._size))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=self._shape_p._slice__3I_3I(_0,_1)
   _3=self._first
   _3 = fragments._c_closure_175(_0,_3,self._strides) # src/fusion/SliceConstraint.mbi:65:9-66:61
   _3 = numpy.int64(_3) # postprocess
   return (self._slice_1_Lmosek_4fusion_4Set_2J_3J(_2,_3,self._strides))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   _2=self._shape_p._slice_II(_0,_1)
   return (self._slice_1_Lmosek_4fusion_4Set_2J_3J(_2,(_0 + _0),self._strides))
  def _slice_1_alt_Lmosek_4fusion_4Set_2J_3J(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self._slice_1_Lmosek_4fusion_4Set_2J_3J(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice_1_Lmosek_4fusion_4Set_2J_3J(self,_0,_1,_2):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(self._origin,_0,_1,_2))
 return SliceConstraint
mosek_fusion_SliceConstraint=__mk_mosek_fusion_SliceConstraint()
del __mk_mosek_fusion_SliceConstraint
#BEFORE CLASS
def __mk_mosek_fusion_BoundInterfaceConstraint():
 class BoundInterfaceConstraint(mosek_fusion_SliceConstraint):
  __slots__ = ['_BoundInterfaceConstraint__origincon','_BoundInterfaceConstraint__islower']
  def __repr__(self): return 'mosek.fusion.BoundInterfaceConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(origin_,shape_,first_,strides_,islower_):
    o = BoundInterfaceConstraint.__new__(BoundInterfaceConstraint)
    o._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(origin_,shape_,first_,strides_,islower_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(*args):
    if len(args) != 5: return False
    origin_,shape_,first_,strides_,islower_, = args
    return (__arg_match_Lmosek_4fusion_4RangedConstraint_2__(origin_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match_J__(first_) and __arg_match__3J__(strides_) and __arg_match_Z__(islower_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(*args):
    if len(args) != 5: return False
    origin_,shape_,first_,strides_,islower_, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(origin_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match_J__(first_) and __arg_alt_match__3J__(strides_) and __arg_alt_match_Z__(islower_))
  def _ctor_alt_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(self,origin_,shape_,first_,strides_,islower_):
    self._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(origin_,shape_,numpy.int64(first_),numpy.array(strides_,dtype=numpy.dtype(numpy.int64)),islower_)
  def _ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(self,origin_,shape_,first_,strides_,islower_):
   assert strides_ is None or isinstance(strides_,numpy.ndarray)
   mosek_fusion_SliceConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(self,origin_,shape_,first_,strides_)
   self.__origincon = origin_
   self.__islower = islower_
  def _slice_1_alt_Lmosek_4fusion_4Set_2J_3J(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self._slice_1_Lmosek_4fusion_4Set_2J_3J(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice_1_Lmosek_4fusion_4Set_2J_3J(self,_0,_1,_2):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(self.__origincon,_0,_1,_2,self.__islower))
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if self.__islower:
    self.__origincon._dual_1l_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   else:
    self.__origincon._dual_1u_J_3I_3JI_3D(_0,_1,_2,_3,_4)
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if self.__islower:
    self.__origincon._dual_1l__3JI_3D(_0,_1,_2)
   else:
    self.__origincon._dual_1u__3JI_3D(_0,_1,_2)
 return BoundInterfaceConstraint
mosek_fusion_BoundInterfaceConstraint=__mk_mosek_fusion_BoundInterfaceConstraint()
del __mk_mosek_fusion_BoundInterfaceConstraint
#BEFORE CLASS
def __mk_mosek_fusion_ModelConstraint():
 class ModelConstraint(mosek_fusion_Constraint):
  __slots__ = ['_ModelConstraint__names_flushed','_nativeindexes','_name','_cache_bfix','_cache']
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_ModelConstraint._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_ModelConstraint._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_ModelConstraint._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_ModelConstraint._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelConstraint.slice(int32,int32)\n\tmosek.fusion.ModelConstraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ModelConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ModelConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.ModelConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = ModelConstraint.__new__(ModelConstraint)
    o._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4ModelConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self._cache = (c._cache)._clone_()
   self._nativeindexes = numpy.array([(c._nativeindexes)[_0] for _0 in range(0,int(((c._nativeindexes)).shape[0]))], dtype=numpy.dtype(numpy.int32))
   self._name = (c._name)
   self._cache_bfix = numpy.array([(c._cache_bfix)[_1] for _1 in range(0,int(((c._cache_bfix)).shape[0]))], dtype=numpy.dtype(numpy.float64))
   self.__names_flushed = (c.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    o = ModelConstraint.__new__(ModelConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 11: return False
    model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match__3I__(nidxs_) and __arg_match__3J__(ptrb) and __arg_match__3I__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barsymmatidx_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 11: return False
    model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match__3I__(nidxs_) and __arg_alt_match__3J__(ptrb) and __arg_alt_match__3I__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barsymmatidx_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,numpy.array(nidxs_,dtype=numpy.dtype(numpy.int32)),numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int32)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsymmatidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
   assert nidxs_ is None or isinstance(nidxs_,numpy.ndarray)
   assert ptrb is None or isinstance(ptrb,numpy.ndarray)
   assert subj is None or isinstance(subj,numpy.ndarray)
   assert cof is None or isinstance(cof,numpy.ndarray)
   assert bfix is None or isinstance(bfix,numpy.ndarray)
   assert barsubi_ is None or isinstance(barsubi_,numpy.ndarray)
   assert barsubj_ is None or isinstance(barsubj_,numpy.ndarray)
   assert barsymmatidx_ is None or isinstance(barsymmatidx_,numpy.ndarray)
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2Lmosek_4fusion_4Set_2(self,model_,shape_)
   self._cache = mosek_fusion_ConstraintCache._ctor__3J_3D_3I_3D_3I_3I_3I(ptrb,cof,subj,bfix,barsubi_,barsubj_,barsymmatidx_)
   self._nativeindexes = nidxs_
   self._name = name_
   if (bfix is not None):
    self._cache_bfix = mosek.fusion.Utils.Tools._arraycopy__3D(bfix)
   else:
    self._cache_bfix = numpy.zeros((int((nidxs_).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__names_flushed = False
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    for _0 in range(0,int((self._nativeindexes).shape[0])):
     self._model._task_1con_1name_IS(self._nativeindexes[_0],("" if ((int(len(self._name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J(_0))._a_S("]")._toString_()))
    self.__names_flushed = True
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=(self._shape_p._size)
   _1=numpy.zeros((_0,), dtype=numpy.dtype(object))
   self._toStringArray__3JJ_3S(mosek.fusion.Utils.Tools._range_J(_0),0,_1)
   _2=mosek.fusion.Utils.StringBuffer()
   _2._a_S("Constraint( ")
   if (int(len(self._name)) > 0):
    _2._a_S("'")._a_S(self._name)._a_S("', ")
   _2._a_S("(")._a_I(self._shape_p._dim_I(0))
   for _3 in range(1,(self._shape_p.nd)):
    _2._a_S(",")._a_I(self._shape_p._dim_I(_3))
   _2._a_S("),")._lf_()
   if (int((_1).shape[0]) > 0):
    _2._a_S("  ")._a_S(_1[0])
    for _4 in range(1,int((_1).shape[0])):
     _2._a_S(",")._lf_()._a_S("  ")._a_S(_1[_4])
   _2._a_S(" )")
   return (_2._toString_())
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   for _3 in range(0,int((_0).shape[0])):
    if ((_0[_3] < 0) or (_0[_3] >= (self._shape_p._size))):
     raise mosek_fusion_IndexError._ctor_S("Constraint index out of bounds")
   if ((int((_0).shape[0]) + _1) > int((_2).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Result array is too small to hold the result")
   _4=mosek.fusion.Utils.StringBuffer()
   _5=0
   _6=self._cache._order_1barentries_()
   _7=0
   for _8 in range(0,int((_0).shape[0])):
    _9=_0[_8]
    _10=self._nativeindexes[_9]
    _11=_5
    while ((_5 < (self._cache.nnz)) and ((self._cache.subi)[_5]==_9)):
     _5 += 1
    _4._clear_()._a_S(self._name)._a_S("[")._a_S(self._shape_p._indexToString_J(_9))._a_S("] : ")
    for _12 in range(_11,_5):
     _13=(self._cache.cof)[_12]
     if (_13 > 0):
      _4._a_S(" + ")._a_D(_13)._a_S(" ")
      self._model._nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2((self._cache.subj)[_12],_4)
     elif (_13 < 0):
      _4._a_S(" - ")._a_D((- _13))._a_S(" ")
      self._model._nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2((self._cache.subj)[_12],_4)
    while ((_7 < _6) and ((self._cache.barsubi)[_7] < _9)):
     _7 += 1
    _14=_7
    while ((_14 < _6) and ((self._cache.barsubi)[_14]==_9)):
     _14 += 1
    while ((_7 < _14) and ((self._cache.barsubi)[_7]==_9)):
     _15=_7
     _16=(self._cache.barsubj)[_7]
     _7 += 1
     while ((_7 < _14) and ((self._cache.barsubj)[_7]==_16)):
      _7 += 1
     _4._a_S(" + < M")._a_I((self._cache.barmatidx)[_15])
     for _17 in range((_15 + 1),_7):
      _4._a_S(" + M")._a_I((self._cache.barmatidx)[_17])
     _4._a_S(" ; ")._a_S((((self._model._vars)[(self._model._natbarvarmap_Var)[(self._cache.barsubj)[_15]]]._name) if ((int(len(((self._model._vars)[(self._model._natbarvarmap_Var)[(self._cache.barsubj)[_15]]]._name))) > 0) ) else "_"))._a_S(" >")
    if (self._cache_bfix is not None):
     if (self._cache_bfix[_9] > 0):
      _4._a_S(" + ")._a_D(self._cache_bfix[_9])
     elif (self._cache_bfix[_9] < 0):
      _4._a_S(" + ")._a_D(self._cache_bfix[_9])
    _4._a_S(" ")
    self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_9,_4)
    _2[(numpy.int64(_8) + _1)] = _4._toString_()
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  def _add_1l_alt__3J_3J_3I_3I_3I_3D_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.int64(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.int32(_t__9)
   _1 = self._add_1l__3J_3J_3I_3I_3I_3D_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1l__3J_3J_3I_3I_3I_3D_3DJII(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   for _10 in range(1,int((_0).shape[0])):
    if (_0[(_10 - 1)] >= _0[_10]):
     raise mosek_fusion_UnimplementedError._ctor_S("Not supported: Non-contiguous index ranges in ModelConstraint.add_l")
   if ((_1[(_8 + _9)] <= _1[_8]) and (_6 is None)):
    return 
   _11=numpy.zeros(((_1[(_8 + _9)] - _1[_8]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_176(_9,_11,_1,_8) # src/fusion/ModelConstraint.mbi:171:9-91
   for _12 in range(0,_9):
    mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_11,_2,None,_1[(_8 + _12)],_1[((_8 + _12) + 1)])
   _13=0
   _14=0
   _14,_13 = fragments._c_closure_177(_9,_14,_13,_1,_8,_2) # src/fusion/ModelConstraint.mbi:178:9-183:24
   _14 = numpy.int32(_14) # postprocess
   _13 = numpy.int32(_13) # postprocess
   if ((_13 > 0) or (_6 is not None)):
    _15=numpy.zeros((((self._cache.nrows) + 1),), dtype=numpy.dtype(numpy.int64))
    _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _17=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    _18=None
    if (_6 is not None):
     _18 = numpy.zeros(((self._cache.nrows),), dtype=numpy.dtype(numpy.float64))
     fragments._c_closure_178(_6,_18,_9,_8,_0,_7) # src/fusion/ModelConstraint.mbi:196:13-197:69
    _15[0] = 0
    _19=_8
    for _20 in range(0,(self._cache.nrows)):
     _19 = fragments._c_closure_179(_5,_20,_19,_17,_15,_16,_9,_1,_0,_7,_2) # src/fusion/ModelConstraint.mbi:203:11-221:12
     _19 = numpy.int32(_19) # postprocess
    self._cache._add__3J_3I_3D_3D(_15,_16,_17,_18)
    _21=(self._cache.nrows)
    _22=numpy.int32(self._cache._numUnsorted_())
    _23=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
    _24=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
    _25=numpy.zeros((_22,), dtype=numpy.dtype(numpy.float64))
    _26=self._cache._flush__3I_3I_3D_3D(_23,_24,_25,None)
    fragments._c_closure_180(self._nativeindexes,_23,_26) # src/fusion/ModelConstraint.mbi:235:13-236:50
    self._model._task_1putaijlist__3I_3I_3DJ(_23,_24,_25,_26)
    if (_6 is not None):
     self._add_1fx__3J_3DJII(_0,(self._cache.bfix),_7,_8,_9)
   if (_14 > 0):
    _27=0
    _27 = fragments._c_closure_181(_9,_27,_11,_1,_8,_2) # src/fusion/ModelConstraint.mbi:251:11-265:12
    _27 = numpy.int32(_27) # postprocess
    _28=numpy.zeros((_27,), dtype=numpy.dtype(numpy.int32))
    _29=numpy.zeros((_27,), dtype=numpy.dtype(numpy.int32))
    _30=numpy.zeros((_27,), dtype=numpy.dtype(numpy.int32))
    _31=numpy.zeros((_27,), dtype=numpy.dtype(numpy.int32))
    _32=_1[_8]
    _33=0
    for _34 in range(0,_9):
     _35=(_1[(_8 + _34)] - _32)
     _36=(_1[((_8 + _34) + 1)] - _32)
     if (_2[_11[_35]] < 0):
      while ((_35 < _36) and (_2[_11[_35]] < 0)):
       _29[_33] = numpy.int32(_0[(_8 + _34)])
       _28[_33] = self._nativeindexes[numpy.int32(_0[(_8 + _34)])]
       _30[_33] = ((- _2[_11[_35]]) - 1)
       _37=_35
       _35 = fragments._c_closure_182(_35,_37,_36,_11,_2) # src/fusion/ModelConstraint.mbi:289:19-292:25
       _35 = numpy.int64(_35) # postprocess
       _41=1
       if ((_35 - _37) > 1):
        mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_11,_3,_4,numpy.int64(_37),numpy.int64((_35 - _37)))
        _42=1
        _42 = fragments._c_closure_183(_35,_37,_42,_11,_3,_4) # src/fusion/ModelConstraint.mbi:306:21-309:42
        _42 = numpy.int32(_42) # postprocess
        _38 = numpy.zeros((_42,), dtype=numpy.dtype(numpy.int32))
        _39 = numpy.zeros((_42,), dtype=numpy.dtype(numpy.int32))
        _40 = numpy.zeros((_42,), dtype=numpy.dtype(numpy.float64))
        _38[0] = _3[_11[0]]
        _39[0] = _4[_11[0]]
        _40[0] = _5[_11[0]]
        _43=0
        _43 = fragments._c_closure_184(_40,_38,_39,_5,_35,_37,_43,_11,_3,_4) # src/fusion/ModelConstraint.mbi:319:21-330:22
        _43 = numpy.int32(_43) # postprocess
       else:
        _38 = numpy.array([_3[_11[_37]]], dtype=numpy.dtype(numpy.int32))
        _39 = numpy.array([_4[_11[_37]]], dtype=numpy.dtype(numpy.int32))
        _40 = numpy.array([_5[_11[_37]]], dtype=numpy.dtype(numpy.float64))
       _44=self._model._task_1append_1barmatrix_I_3I_3I_3D(self._model._task_1barvardim_I(_30[_33]),_38,_39,_40)
       _31[_33] = _44
       _33 += 1
    self._cache._add_1bar__3I_3I_3I(_29,_30,_31)
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (int((_0).shape[0])!=int((_1).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching array lengths")
   _2=self._shape_p._slice__3I_3I(_0,_1)
   _3=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _3[((self._shape_p.nd) - 1)] = 1
   _4=((self._shape_p.nd) - 1)
   while (_4 > 0):
    _3[(_4 - 1)] = (_3[_4] * self._shape_p._dim_I(_4))
    _4 = (_4 - 1)
   _5=0
   _5 = fragments._c_closure_185(_0,_5,_3) # src/fusion/ModelConstraint.mbi:113:9-114:56
   _5 = numpy.int64(_5) # postprocess
   return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(self,_2,_5,_3))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   _2=numpy.array([1], dtype=numpy.dtype(numpy.int64))
   return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Set_2J_3J(self,self._shape_p._slice_II(_0,_1),numpy.int64(_0),_2))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   pass
 return ModelConstraint
mosek_fusion_ModelConstraint=__mk_mosek_fusion_ModelConstraint()
del __mk_mosek_fusion_ModelConstraint
#BEFORE CLASS
def __mk_mosek_fusion_LinearPSDConstraint():
 class LinearPSDConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_LinearPSDConstraint__psdvardim','_LinearPSDConstraint__names_flushed','_LinearPSDConstraint__numcones','_LinearPSDConstraint__conesize','_LinearPSDConstraint__coneidx']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_LinearPSDConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.LinearPSDConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = LinearPSDConstraint.__new__(LinearPSDConstraint)
    o._ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearPSDConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__coneidx = (c.__coneidx)
   self.__conesize = (c.__conesize)
   self.__psdvardim = (c.__psdvardim)
   self.__numcones = (c.__numcones)
   self.__names_flushed = (c.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    o = LinearPSDConstraint.__new__(LinearPSDConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 14: return False
    model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match__3I__(nativeidxs_) and __arg_match_I__(conesize_) and __arg_match_I__(firstcone_) and __arg_match_I__(numcone_) and __arg_match__3J__(ptrb) and __arg_match__3I__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barsymmatidx_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 14: return False
    model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_I__(conesize_) and __arg_alt_match_I__(firstcone_) and __arg_alt_match_I__(numcone_) and __arg_alt_match__3J__(ptrb) and __arg_alt_match__3I__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barsymmatidx_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int32(conesize_),numpy.int32(firstcone_),numpy.int32(numcone_),numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int32)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsymmatidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
   assert nativeidxs_ is None or isinstance(nativeidxs_,numpy.ndarray)
   assert ptrb is None or isinstance(ptrb,numpy.ndarray)
   assert subj is None or isinstance(subj,numpy.ndarray)
   assert cof is None or isinstance(cof,numpy.ndarray)
   assert bfix is None or isinstance(bfix,numpy.ndarray)
   assert barsubi_ is None or isinstance(barsubi_,numpy.ndarray)
   assert barsubj_ is None or isinstance(barsubj_,numpy.ndarray)
   assert barsymmatidx_ is None or isinstance(barsymmatidx_,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_)
   self.__coneidx = firstcone_
   self.__conesize = conesize_
   self.__numcones = numcone_
   _0=self._shape_p._dim_I(0)
   _1=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _0))) - 1) / 2))
   if (((_1 * (_1 + 1)) // 2)!=_0):
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for semidefinite constraint")
   self.__psdvardim = _1
   self.__names_flushed = False
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _2=self._shape_p._idxtokey_J(_0)
   _1._a_S(" : element (")._a_I(_2[0])
   for _3 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(_2[_3])
   _1._a_S(") in a positive semi-definite cone of size (")._a_I(self._shape_p._dim_I(0))
   for _4 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(self._shape_p._dim_I(_4))
   _1._a_S(")")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=(self._shape_p._size)
   _1=numpy.zeros((_0,), dtype=numpy.dtype(object))
   self._toStringArray__3JJ_3SZ(numpy.array([_2 for _2 in range(0,_0)], dtype=numpy.dtype(numpy.int64)),0,_1,False)
   _3=mosek.fusion.Utils.StringBuffer()
   _3._a_S("LinearPSDConstraint( (")._a_I(self._shape_p._dim_I(0))
   for _4 in range(1,(self._shape_p.nd)):
    _3._a_S(",")._a_I(self._shape_p._dim_I(_4))
   _3._a_S("),")._lf_()
   _3._a_S("  ")._a_S(_1[0])
   for _5 in range(1,int((_1).shape[0])):
    _3._a_S(",")._lf_()._a_S("  ")._a_S(_1[_5])
   _3._a_S(" )")
   return (_3._toString_())
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   self._toStringArray__3JJ_3SZ(_0,_1,_2,True)
  def _toStringArray_alt__3JJ_3SZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _3=_t__3
   _1 = self._toStringArray__3JJ_3SZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3SZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   for _4 in range(0,int((_0).shape[0])):
    if ((_0[_4] < 0) or (_0[_4] >= (self._shape_p._size))):
     raise mosek_fusion_IndexError._ctor_S("Constraint index out of bounds")
   if ((int((_0).shape[0]) + _1) > int((_2).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Result array is too small to hold the result")
   _5=mosek.fusion.Utils.StringBuffer()
   _6=self._cache._order_1barentries_()
   _7=0
   for _8 in range(0,int((_0).shape[0])):
    _9=_0[_8]
    _10=(_9 // self.__conesize)
    _11=(_9 % self.__conesize)
    _12=(_9 + self.__coneidx)
    _5._clear_()._a_S(self._name)._a_S("[")._a_J(_10)._a_S(",")._a_J(_11)._a_S("] : ")
    _13=self._nativeindexes[_9]
    _14=0
    while ((_14 < int(((self._cache.subi)).shape[0])) and ((self._cache.subi)[_14] < _12)):
     _14 += 1
    _15=_14
    while ((_14 < int(((self._cache.subi)).shape[0])) and ((self._cache.subi)[_14]==_12)):
     _14 += 1
    _16=0
    while ((_16 < _6) and ((self._cache.barsubi)[_16] < _12)):
     _16 += 1
    _17=_16
    while ((_16 < _6) and ((self._cache.barsubi)[_16]==_12)):
     _16 += 1
    for _18 in range(_15,_14):
     _19=(self._cache.cof)[_18]
     if (_19 > 0):
      _5._a_S(" + ")._a_D(_19)._a_S(" ")
     elif (_19 < 0):
      _5._a_S(" - ")._a_D((- _19))._a_S(" ")
     else:
      _5._a_S(" + 0.0 ")
     self._model._nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2((self._cache.subj)[_18],_5)
    _20=_16
    _16 = _17
    while ((_16 < _20) and ((self._cache.barsubi)[_16]==_12)):
     _21=_16
     _22=(self._cache.barsubj)[_16]
     _16 += 1
     while ((_16 < _20) and ((self._cache.barsubj)[_16]==_22)):
      _16 += 1
     _5._a_S(" + < M")._a_I((self._cache.barmatidx)[_21])
     for _23 in range((_21 + 1),_16):
      _5._a_S(" + M")._a_I((self._cache.barmatidx)[_23])
     _5._a_S(" ; ")._a_S((((self._model._vars)[(self._model._natbarvarmap_Var)[(self._cache.barsubj)[_21]]]._name) if ((int(len(((self._model._vars)[(self._model._natbarvarmap_Var)[(self._cache.barsubj)[_21]]]._name))) > 0) ) else "_"))._a_S(" >")
    if (self._cache_bfix is not None):
     if (self._cache_bfix[_12] > 0):
      _5._a_S(" + ")._a_D(self._cache_bfix[_12])
     elif (self._cache_bfix[_12] < 0):
      _5._a_S(" + ")._a_D(self._cache_bfix[_12])
    if _3:
     _5._a_S(" ")
     self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_9,_5)
    _2[(numpy.int64(_8) + _1)] = _5._toString_()
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    _0=mosek.fusion.Utils.StringBuffer()
    if (self.__numcones > 1):
     _1=0
     for _2 in range(0,self.__numcones):
      for _3 in range(0,self.__conesize):
       self._model._task_1con_1name_IS(self._nativeindexes[_1],_0._clear_()._a_S(self._name)._a_S("[")._a_I(_2)._a_S(",")._a_I(_3)._a_S("]")._toString_())
       _1 += 1
    else:
     _4=0
     for _5 in range(0,self.__conesize):
      self._model._task_1con_1name_IS(self._nativeindexes[_4],_0._clear_()._a_S(self._name)._a_S("[")._a_I(_5)._a_S("]")._toString_())
      _4 += 1
    for _6 in range(0,self.__numcones):
     self._model._task_1barvar_1name_IS((self.__coneidx + _6),_0._clear_()._a_S(self._name)._a_S("[")._a_I(_6)._a_S("].coneslack")._toString_())
    self.__names_flushed = True
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_186(_6,self._nativeindexes,_4,_3,_0,_2) # src/fusion/LinearPSDConstraint.monty:187:9-188:63
   fragments._c_closure_187(_1,_5,_3,_0,_2) # src/fusion/LinearPSDConstraint.monty:190:9-191:60
   self._model._task_1con_1putboundlist_1fx__3I_3D(_6,_5)
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _6=1
   _6 = fragments._c_closure_188(_1,_6) # src/fusion/LinearPSDConstraint.monty:161:22-66
   _6 = numpy.int32(_6) # postprocess
   _7=self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _8=self.__conesize
   for _9 in range(0,_6):
    _10=((_5._get_() // _8) + self.__coneidx)
    _11=(_5._get_() % _8)
    _4[_9] = _7[self.__coneidx][_11]
    _5._inc_()
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self.__conesize
   fragments._c_closure_189(_3,_4,self.__coneidx,_0,_2) # src/fusion/LinearPSDConstraint.monty:144:9-150:10
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _6=1
   _6 = fragments._c_closure_190(_1,_6) # src/fusion/LinearPSDConstraint.monty:119:22-66
   _6 = numpy.int32(_6) # postprocess
   _7=self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _8=self.__conesize
   for _9 in range(0,_6):
    _10=((_5._get_() // _8) + self.__coneidx)
    _11=(_5._get_() % _8)
    _4[_9] = _7[self.__coneidx][_11]
    _5._inc_()
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self.__psdvardim
   fragments._c_closure_191(_3,_4,self.__coneidx,_0,_2) # src/fusion/LinearPSDConstraint.monty:101:9-107:10
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearPSDConstraint._ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearPSDConstraint
mosek_fusion_LinearPSDConstraint=__mk_mosek_fusion_LinearPSDConstraint()
del __mk_mosek_fusion_LinearPSDConstraint
#BEFORE CLASS
def __mk_mosek_fusion_PSDConstraint():
 class PSDConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_PSDConstraint__names_flushed','_PSDConstraint__numcones','_PSDConstraint__conesize','_PSDConstraint__coneidx']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_PSDConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_PSDConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.PSDConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = PSDConstraint.__new__(PSDConstraint)
    o._ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4PSDConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__coneidx = (c.__coneidx)
   self.__conesize = (c.__conesize)
   self.__numcones = (c.__numcones)
   self.__names_flushed = (c.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    o = PSDConstraint.__new__(PSDConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 14: return False
    model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match__3I__(nativeidxs_) and __arg_match_I__(conesize_) and __arg_match_I__(firstcone_) and __arg_match_I__(numcone_) and __arg_match__3J__(ptrb) and __arg_match__3I__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barsymmatidx_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 14: return False
    model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_I__(conesize_) and __arg_alt_match_I__(firstcone_) and __arg_alt_match_I__(numcone_) and __arg_alt_match__3J__(ptrb) and __arg_alt_match__3I__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barsymmatidx_))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int32(conesize_),numpy.int32(firstcone_),numpy.int32(numcone_),numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int32)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsymmatidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3IIII_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_):
   assert nativeidxs_ is None or isinstance(nativeidxs_,numpy.ndarray)
   assert ptrb is None or isinstance(ptrb,numpy.ndarray)
   assert subj is None or isinstance(subj,numpy.ndarray)
   assert cof is None or isinstance(cof,numpy.ndarray)
   assert bfix is None or isinstance(bfix,numpy.ndarray)
   assert barsubi_ is None or isinstance(barsubi_,numpy.ndarray)
   assert barsubj_ is None or isinstance(barsubj_,numpy.ndarray)
   assert barsymmatidx_ is None or isinstance(barsymmatidx_,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,ptrb,subj,cof,bfix,barsubi_,barsubj_,barsymmatidx_)
   self.__coneidx = firstcone_
   self.__conesize = conesize_
   self.__numcones = numcone_
   self.__names_flushed = False
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _2=self._shape_p._idxtokey_J(_0)
   _1._a_S(" : element (")._a_I(_2[0])
   for _3 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(_2[_3])
   _1._a_S(") in a positive semi-definite cone of size (")._a_I(self._shape_p._dim_I(0))
   for _4 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(self._shape_p._dim_I(_4))
   _1._a_S(")")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=(self._shape_p._size)
   _1=numpy.zeros((_0,), dtype=numpy.dtype(object))
   self._toStringArray__3JJ_3SZ(numpy.array([_2 for _2 in range(0,_0)], dtype=numpy.dtype(numpy.int64)),0,_1,False)
   _3=mosek.fusion.Utils.StringBuffer()
   _3._a_S("PSDConstraint( (")._a_I(self._shape_p._dim_I(0))
   for _4 in range(1,(self._shape_p.nd)):
    _3._a_S(",")._a_I(self._shape_p._dim_I(_4))
   _3._a_S("),")._lf_()
   _3._a_S("  ")._a_S(_1[0])
   for _5 in range(1,int((_1).shape[0])):
    _3._a_S(",")._lf_()._a_S("  ")._a_S(_1[_5])
   _3._a_S(" )")
   return (_3._toString_())
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   self._toStringArray__3JJ_3SZ(_0,_1,_2,True)
  def _toStringArray_alt__3JJ_3SZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _3=_t__3
   _1 = self._toStringArray__3JJ_3SZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3SZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   for _4 in range(0,int((_0).shape[0])):
    if ((_0[_4] < 0) or (_0[_4] >= (self._shape_p._size))):
     raise mosek_fusion_IndexError._ctor_S("Constraint index out of bounds")
   if ((int((_0).shape[0]) + _1) > int((_2).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Result array is too small to hold the result")
   _5=mosek.fusion.Utils.StringBuffer()
   _6=self._cache._order_1barentries_()
   _7=0
   for _8 in range(0,int((_0).shape[0])):
    _9=_0[_8]
    _10=(_9 // (self.__conesize * self.__conesize))
    _11=(_9 % (self.__conesize * self.__conesize))
    _12=(_11 // self.__conesize)
    _13=(_11 % self.__conesize)
    _14=((((_12 * (_12 + 1)) // 2) + _13) if ((_12 >= _13) ) else (((_13 * (_13 + 1)) // 2) + _12))
    _15=(_14 + (((_10 * self.__conesize) * (self.__conesize + 1)) // 2))
    _5._clear_()._a_S(self._name)._a_S("[")._a_J(_10)._a_S(",")._a_J(_12)._a_S(",")._a_J(_13)._a_S("] : ")
    _16=self._nativeindexes[_15]
    _17=0
    while ((_17 < int(((self._cache.subi)).shape[0])) and ((self._cache.subi)[_17] < _15)):
     _17 += 1
    _18=_17
    while ((_17 < int(((self._cache.subi)).shape[0])) and ((self._cache.subi)[_17]==_15)):
     _17 += 1
    _19=0
    while ((_19 < _6) and ((self._cache.barsubi)[_19] < _15)):
     _19 += 1
    _20=_19
    while ((_19 < _6) and ((self._cache.barsubi)[_19]==_15)):
     _19 += 1
    for _21 in range(_18,_17):
     _22=(self._cache.cof)[_21]
     if (_22 > 0):
      _5._a_S(" + ")._a_D(_22)._a_S(" ")
     elif (_22 < 0):
      _5._a_S(" - ")._a_D((- _22))._a_S(" ")
     else:
      _5._a_S(" + 0.0 ")
     self._model._nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2((self._cache.subj)[_21],_5)
    _23=_19
    _19 = _20
    while ((_19 < _23) and ((self._cache.barsubi)[_19]==_15)):
     _24=_19
     _25=(self._cache.barsubj)[_19]
     _19 += 1
     while ((_19 < _23) and ((self._cache.barsubj)[_19]==_25)):
      _19 += 1
     _5._a_S(" + < M")._a_I((self._cache.barmatidx)[_24])
     for _26 in range((_24 + 1),_19):
      _5._a_S(" + M")._a_I((self._cache.barmatidx)[_26])
     _5._a_S(" ; ")._a_S((((self._model._vars)[(self._model._natbarvarmap_Var)[(self._cache.barsubj)[_24]]]._name) if ((int(len(((self._model._vars)[(self._model._natbarvarmap_Var)[(self._cache.barsubj)[_24]]]._name))) > 0) ) else "_"))._a_S(" >")
    if (self._cache_bfix is not None):
     if (self._cache_bfix[_15] > 0):
      _5._a_S(" + ")._a_D(self._cache_bfix[_15])
     elif (self._cache_bfix[_15] < 0):
      _5._a_S(" + ")._a_D(self._cache_bfix[_15])
    if _3:
     _5._a_S(" ")
     self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_9,_5)
    _2[(numpy.int64(_8) + _1)] = _5._toString_()
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    _0=mosek.fusion.Utils.StringBuffer()
    if (self.__numcones > 1):
     _1=0
     for _2 in range(0,self.__numcones):
      for _3 in range(0,self.__conesize):
       for _4 in range(0,(_3 + 1)):
        self._model._task_1con_1name_IS(self._nativeindexes[_1],_0._clear_()._a_S(self._name)._a_S("[")._a_I(_2)._a_S(",")._a_I(_3)._a_S(",")._a_I(_4)._a_S("]")._toString_())
        _1 += 1
    else:
     _5=0
     for _6 in range(0,self.__conesize):
      for _7 in range(0,(_6 + 1)):
       self._model._task_1con_1name_IS(self._nativeindexes[_5],_0._clear_()._a_S(self._name)._a_S("[")._a_I(_6)._a_S(",")._a_I(_7)._a_S("]")._toString_())
       _5 += 1
    for _8 in range(0,self.__numcones):
     self._model._task_1barvar_1name_IS((self.__coneidx + _8),_0._clear_()._a_S(self._name)._a_S("[")._a_I(_8)._a_S("].coneslack")._toString_())
    self.__names_flushed = True
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_192(_6,self._nativeindexes,_4,_3,_0,_2) # src/fusion/SemidefiniteConstraint.mbi:233:9-234:63
   fragments._c_closure_193(_1,_5,_3,_0,_2) # src/fusion/SemidefiniteConstraint.mbi:236:9-237:60
   self._model._task_1con_1putboundlist_1fx__3I_3D(_6,_5)
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _9=self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _10=(self.__conesize * self.__conesize)
   fragments._c_closure_194(_6,_8,_0) # src/fusion/SemidefiniteConstraint.mbi:191:9-42
   _5 = fragments._c_closure_195(_6,_1,_5) # src/fusion/SemidefiniteConstraint.mbi:192:9-51
   _5 = numpy.int64(_5) # postprocess
   for _11 in range(0,_5):
    _12=(_8[0] // _10)
    _13=(_8[0] - (_12 * _10))
    _14=(_13 // self.__conesize)
    _15=(_13 - (_14 * self.__conesize))
    if (_15 > _14):
     _4[_11] = _9[(numpy.int64(self.__coneidx) + _12)][(((_14 * self.__conesize) + _15) - ((_14 * (_14 + 1)) // 2))]
    else:
     _4[_11] = _9[(numpy.int64(self.__coneidx) + _12)][(((_15 * self.__conesize) + _14) - ((_15 * (_15 + 1)) // 2))]
    _7[0] += 1
    _8[0] = (_8[0] + _2[(_6 - 1)])
    _16=0
    _16 = 0
    while ((_16 < (_6 - 1)) and (_7[_16]==_1[_16])):
     _7[_16] = 0
     _7[(_16 + 1)] += 1
     _8[(_16 + 1)] = (_8[(_16 + 1)] + _2[((_6 - 2) - _16)])
     _16 += 1
    fragments._c_closure_196(_16,_8) # src/fusion/SemidefiniteConstraint.mbi:217:13-218:29
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=(self.__conesize * self.__conesize)
   fragments._c_closure_197(_3,_4,self.__coneidx,self.__conesize,_0,_2) # src/fusion/SemidefiniteConstraint.mbi:162:9-173:10
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _9=self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _10=(self.__conesize * self.__conesize)
   fragments._c_closure_198(_6,_8,_0) # src/fusion/SemidefiniteConstraint.mbi:120:9-42
   _5 = fragments._c_closure_199(_6,_1,_5) # src/fusion/SemidefiniteConstraint.mbi:121:9-51
   _5 = numpy.int64(_5) # postprocess
   for _11 in range(0,_5):
    _12=(_8[0] // _10)
    _13=(_8[0] - (_12 * _10))
    _14=(_13 // self.__conesize)
    _15=(_13 - (_14 * self.__conesize))
    if (_15 > _14):
     _4[_11] = _9[(numpy.int64(self.__coneidx) + _12)][(((_14 * self.__conesize) + _15) - ((_14 * (_14 + 1)) // 2))]
    else:
     _4[_11] = _9[(numpy.int64(self.__coneidx) + _12)][(((_15 * self.__conesize) + _14) - ((_15 * (_15 + 1)) // 2))]
    _7[0] += 1
    _8[0] = (_8[0] + _2[(_6 - 1)])
    _16=0
    _16 = 0
    while ((_16 < (_6 - 1)) and (_7[_16]==_1[_16])):
     _7[_16] = 0
     _7[(_16 + 1)] += 1
     _8[(_16 + 1)] = (_8[(_16 + 1)] + _2[((_6 - 2) - _16)])
     _16 += 1
    fragments._c_closure_200(_16,_8) # src/fusion/SemidefiniteConstraint.mbi:146:13-147:29
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=(self.__conesize * self.__conesize)
   fragments._c_closure_201(_3,_4,self.__coneidx,self.__conesize,_0,_2) # src/fusion/SemidefiniteConstraint.mbi:90:9-101:10
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_PSDConstraint._ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return PSDConstraint
mosek_fusion_PSDConstraint=__mk_mosek_fusion_PSDConstraint()
del __mk_mosek_fusion_PSDConstraint
#BEFORE CLASS
def __mk_mosek_fusion_RangedConstraint():
 class RangedConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_RangedConstraint__idxmap','_RangedConstraint__dom']
  def lowerBoundCon(self,*args):
    if False: pass
    elif mosek_fusion_RangedConstraint._match_lowerBoundCon_(*args): # 
      return self._lowerBoundCon_(*args)
    elif mosek_fusion_RangedConstraint._match_alt_lowerBoundCon_(*args): # 
      return self._lowerBoundCon_alt_(*args)
    else:
      raise ValueError('Invalid argument list lowerBoundCon('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedConstraint.lowerBoundCon()')
  def upperBoundCon(self,*args):
    if False: pass
    elif mosek_fusion_RangedConstraint._match_upperBoundCon_(*args): # 
      return self._upperBoundCon_(*args)
    elif mosek_fusion_RangedConstraint._match_alt_upperBoundCon_(*args): # 
      return self._upperBoundCon_alt_(*args)
    else:
      raise ValueError('Invalid argument list upperBoundCon('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedConstraint.upperBoundCon()')
  def __repr__(self): return 'mosek.fusion.RangedConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = RangedConstraint.__new__(RangedConstraint)
    o._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4RangedConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__dom = (c.__dom)
   self.__idxmap = None
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    o = RangedConstraint.__new__(RangedConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 12: return False
    model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(dom_) and __arg_match__3I__(nidxs_) and __arg_match__3J__(ptrb) and __arg_match__3I__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(barsubi) and __arg_match__3I__(barsubj) and __arg_match__3I__(barmatidx))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 12: return False
    model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(dom_) and __arg_alt_match__3I__(nidxs_) and __arg_alt_match__3J__(ptrb) and __arg_alt_match__3I__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(barsubi) and __arg_alt_match__3I__(barsubj) and __arg_alt_match__3I__(barmatidx))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,shape_,dom_,numpy.array(nidxs_,dtype=numpy.dtype(numpy.int32)),numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int32)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj,dtype=numpy.dtype(numpy.int32)),numpy.array(barmatidx,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2Lmosek_4fusion_4RangeDomain_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,dom_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
   assert nidxs_ is None or isinstance(nidxs_,numpy.ndarray)
   assert ptrb is None or isinstance(ptrb,numpy.ndarray)
   assert subj is None or isinstance(subj,numpy.ndarray)
   assert cof is None or isinstance(cof,numpy.ndarray)
   assert bfix is None or isinstance(bfix,numpy.ndarray)
   assert barsubi is None or isinstance(barsubi,numpy.ndarray)
   assert barsubj is None or isinstance(barsubj,numpy.ndarray)
   assert barmatidx is None or isinstance(barmatidx,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
   self.__dom = dom_
   self.__idxmap = None
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _7=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_202(_7,self._nativeindexes,_4,_3,_0,_2) # src/fusion/RangedConstraint.mbi:375:9-376:63
   for _8 in range(0,int((_5).shape[0])):
    _5[_8] = (self.__dom._get_1lb_1item_J((_0[(_3 + _8)] - _2)) - _1[(_0[(_3 + _8)] - _2)])
    _6[_8] = (self.__dom._get_1ub_1item_J((_0[(_3 + _8)] - _2)) - _1[(_0[(_3 + _8)] - _2)])
   self._model._task_1con_1putboundlist_1ra__3I_3D_3D(_7,_5,_6)
  def _dual_1u_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1suc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_203(_6,_1,_5) # src/fusion/RangedConstraint.mbi:341:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self._nativeindexes is not None):
    for _9 in range(0,_5):
     _4[(_9 + _3)] = (_8[self._nativeindexes[_7._get_()]] + (self._cache.bfix)[_7._get_()])
     _7._inc_()
   else:
    for _10 in range(0,_5):
     if self.__idxmap._hasItem_J(_7._get_()):
      _4[_10] = (_8[self.__idxmap._getItem_J(_7._get_())] + (self._cache.bfix)[_7._get_()])
     else:
      _4[_10] = self.__dom._get_1ub_1item_J(_7._get_())
     _7._inc_()
  def _dual_1u_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1suc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self._nativeindexes is not None):
    for _4 in range(0,int((_0).shape[0])):
     _2[(_1 + _4)] = (_3[self._nativeindexes[_0[_4]]] + (self._cache.bfix)[_0[_4]])
   else:
    for _5 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_5]):
      _2[(_1 + _5)] = (_3[self.__idxmap._getItem_J(_0[_5])] + (self._cache.bfix)[_0[_5]])
     else:
      _2[(_1 + _5)] = self.__dom._get_1ub_1item_J(_0[_5])
  def _dual_1l_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1slc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_204(_6,_1,_5) # src/fusion/RangedConstraint.mbi:285:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self._nativeindexes is not None):
    for _9 in range(0,_5):
     _4[(_9 + _3)] = (_8[self._nativeindexes[_7._get_()]] + (self._cache.bfix)[_7._get_()])
     _7._inc_()
   else:
    for _10 in range(0,_5):
     if self.__idxmap._hasItem_J(_7._get_()):
      _4[_10] = (_8[self.__idxmap._getItem_J(_7._get_())] + (self._cache.bfix)[_7._get_()])
     else:
      _4[_10] = self.__dom._get_1ub_1item_J(_7._get_())
     _7._inc_()
  def _dual_1l_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1slc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self._nativeindexes is not None):
    for _4 in range(0,int((_0).shape[0])):
     _2[(_1 + _4)] = (_3[self._nativeindexes[_0[_4]]] + (self._cache.bfix)[_0[_4]])
   else:
    for _5 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_5]):
      _2[(_1 + _5)] = (_3[self.__idxmap._getItem_J(_0[_5])] + (self._cache.bfix)[_0[_5]])
     else:
      _2[(_1 + _5)] = self.__dom._get_1ub_1item_J(_0[_5])
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1y_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_205(_6,_1,_5) # src/fusion/RangedConstraint.mbi:228:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self._nativeindexes is not None):
    for _9 in range(0,_5):
     _4[(_9 + _3)] = (_8[self._nativeindexes[_7._get_()]] + (self._cache.bfix)[_7._get_()])
     _7._inc_()
   else:
    for _10 in range(0,_5):
     if self.__idxmap._hasItem_J(_7._get_()):
      _4[_10] = (_8[self.__idxmap._getItem_J(_7._get_())] + (self._cache.bfix)[_7._get_()])
     else:
      _4[_10] = self.__dom._get_1ub_1item_J(_7._get_())
     _7._inc_()
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1y_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self._nativeindexes is not None):
    for _4 in range(0,int((_0).shape[0])):
     _2[(_1 + _4)] = (_3[self._nativeindexes[_0[_4]]] + (self._cache.bfix)[_0[_4]])
   else:
    for _5 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_5]):
      _2[(_1 + _5)] = (_3[self.__idxmap._getItem_J(_0[_5])] + (self._cache.bfix)[_0[_5]])
     else:
      _2[(_1 + _5)] = self.__dom._get_1ub_1item_J(_0[_5])
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_206(_6,_1,_5) # src/fusion/RangedConstraint.mbi:173:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self._nativeindexes is not None):
    for _9 in range(0,_5):
     _4[(_9 + _3)] = (_8[self._nativeindexes[_7._get_()]] + (self._cache.bfix)[_7._get_()])
     _7._inc_()
   else:
    for _10 in range(0,_5):
     if self.__idxmap._hasItem_J(_7._get_()):
      _4[_10] = (_8[self.__idxmap._getItem_J(_7._get_())] + (self._cache.bfix)[_7._get_()])
     else:
      _4[_10] = self.__dom._get_1ub_1item_J(_7._get_())
     _7._inc_()
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self._nativeindexes is not None):
    for _4 in range(0,int((_0).shape[0])):
     _2[(_1 + _4)] = (_3[self._nativeindexes[_0[_4]]] + (self._cache.bfix)[_0[_4]])
   else:
    for _5 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_5]):
      _2[(_1 + _5)] = (_3[self.__idxmap._getItem_J(_0[_5])] + (self._cache.bfix)[_0[_5]])
     else:
      _2[(_1 + _5)] = self.__dom._get_1ub_1item_J(_0[_5])
  def _add_1l_alt__3J_3J_3I_3I_3I_3D_3DIII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.int32(_t__9)
   _1 = self._add_1l__3J_3J_3I_3I_3I_3D_3DIII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1l__3J_3J_3I_3I_3I_3D_3DIII(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   self._add_1l__3J_3J_3I_3I_3I_3D_3DIII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   if (_6 is not None):
    _10=((self.__dom._shape)._size)
    _11=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    _12=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    _13=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
    for _14 in range(0,_9):
     _11[_14] = (self.__dom._get_1lb_1item_J(_0[_14]) - (self._cache.bfix)[_14])
     _12[_14] = (self.__dom._get_1ub_1item_J(_0[_14]) - (self._cache.bfix)[_14])
     _13[_14] = self._nativeindexes[_0[_14]]
    self._model._task_1con_1putboundlist_1ra__3I_3D_3D(_13,_11,_12)
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self.__dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
  @staticmethod
  def _match_upperBoundCon_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_upperBoundCon_(*args):
    if len(args) != 0: return False
    return True
  def _upperBoundCon_alt_(self,):
    return self._upperBoundCon_()
  def _upperBoundCon_(self,):
   _0=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _0[((self._shape_p.nd) - 1)] = 1
   _1=((self._shape_p.nd) - 1)
   while (_1 > 0):
    _0[(_1 - 1)] = (_0[_1] * self._shape_p._dim_I(_1))
    _1 -= 1
   return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(self,self._shape_p,0,_0,False))
  @staticmethod
  def _match_lowerBoundCon_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_lowerBoundCon_(*args):
    if len(args) != 0: return False
    return True
  def _lowerBoundCon_alt_(self,):
    return self._lowerBoundCon_()
  def _lowerBoundCon_(self,):
   _0=numpy.zeros(((self._shape_p.nd),), dtype=numpy.dtype(numpy.int64))
   _0[((self._shape_p.nd) - 1)] = 1
   _1=((self._shape_p.nd) - 1)
   while (_1 > 0):
    _0[(_1 - 1)] = (_0[_1] * self._shape_p._dim_I(_1))
    _1 -= 1
   return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Set_2J_3JZ(self,self._shape_p,0,_0,True))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_RangedConstraint._ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return RangedConstraint
mosek_fusion_RangedConstraint=__mk_mosek_fusion_RangedConstraint()
del __mk_mosek_fusion_RangedConstraint
#BEFORE CLASS
def __mk_mosek_fusion_ConicConstraint():
 class ConicConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_ConicConstraint__names_flushed','_ConicConstraint__dom','_ConicConstraint__conesize','_ConicConstraint__last','_ConicConstraint__first','_ConicConstraint__last_slack','_ConicConstraint__first_slack','_ConicConstraint__coneidx']
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_ConicConstraint._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_ConicConstraint._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    elif mosek_fusion_ConicConstraint._match_dual_II(*args): # int32,int32
      return self._dual_II(*args)
    elif mosek_fusion_ConicConstraint._match_alt_dual_II(*args): # int32,int32
      return self._dual_alt_II(*args)
    elif mosek_fusion_ConicConstraint._match_dual__3I_3I(*args): # []int32,[]int32
      return self._dual__3I_3I(*args)
    elif mosek_fusion_ConicConstraint._match_alt_dual__3I_3I(*args): # []int32,[]int32
      return self._dual_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicConstraint.dual()\n\tmosek.fusion.ConicConstraint.dual(int32,int32)\n\tmosek.fusion.ConicConstraint.dual(array(int32,ndim=1),array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ConicConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ConicConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.ConicConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = ConicConstraint.__new__(ConicConstraint)
    o._ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4ConicConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConicConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__first_slack = (c.__first_slack)
   self.__last_slack = (c.__last_slack)
   self.__first = (c.__first)
   self.__last = (c.__last)
   self.__dom = (c.__dom)
   self.__conesize = (c.__conesize)
   self.__coneidx = (c.__coneidx)
   self.__names_flushed = (c.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,dom_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    o = ConicConstraint.__new__(ConicConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,dom_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 17: return False
    model_,name_,dom_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4QConeDomain_2__(dom_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match__3I__(nativeidxs_) and __arg_match_I__(first_slack_) and __arg_match_I__(last_slack_) and __arg_match_I__(conesize_) and __arg_match_I__(firstcone_) and __arg_match_I__(numcone_) and __arg_match__3J__(ptrb) and __arg_match__3I__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(barsubi) and __arg_match__3I__(barsubj) and __arg_match__3I__(barmatidx))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 17: return False
    model_,name_,dom_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(dom_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match__3I__(nativeidxs_) and __arg_alt_match_I__(first_slack_) and __arg_alt_match_I__(last_slack_) and __arg_alt_match_I__(conesize_) and __arg_alt_match_I__(firstcone_) and __arg_alt_match_I__(numcone_) and __arg_alt_match__3J__(ptrb) and __arg_alt_match__3I__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(barsubi) and __arg_alt_match__3I__(barsubj) and __arg_alt_match__3I__(barmatidx))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,dom_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(model_,name_,dom_,shape_,numpy.array(nativeidxs_,dtype=numpy.dtype(numpy.int32)),numpy.int32(first_slack_),numpy.int32(last_slack_),numpy.int32(conesize_),numpy.int32(firstcone_),numpy.int32(numcone_),numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int32)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj,dtype=numpy.dtype(numpy.int32)),numpy.array(barmatidx,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4QConeDomain_2Lmosek_4fusion_4Set_2_3IIIIII_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,dom_,shape_,nativeidxs_,first_slack_,last_slack_,conesize_,firstcone_,numcone_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
   assert nativeidxs_ is None or isinstance(nativeidxs_,numpy.ndarray)
   assert ptrb is None or isinstance(ptrb,numpy.ndarray)
   assert subj is None or isinstance(subj,numpy.ndarray)
   assert cof is None or isinstance(cof,numpy.ndarray)
   assert bfix is None or isinstance(bfix,numpy.ndarray)
   assert barsubi is None or isinstance(barsubi,numpy.ndarray)
   assert barsubj is None or isinstance(barsubj,numpy.ndarray)
   assert barmatidx is None or isinstance(barmatidx,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nativeidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
   self.__first_slack = first_slack_
   self.__last_slack = last_slack_
   self.__first = firstcone_
   self.__last = (firstcone_ + numcone_)
   self.__dom = dom_
   self.__conesize = conesize_
   self.__coneidx = firstcone_
   self.__names_flushed = False
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   mosek_fusion_ModelConstraint._flushNames_(self)
   if ((not self.__names_flushed) and (int(len(self._name)) > 0)):
    for _0 in range(self.__first_slack,self.__last_slack):
     self._model._task_1var_1name_IS(_0,("" if ((int(len(self._name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_S(self._shape_p._getname_J((_0 - self.__first_slack)))._a_S("].coneslack")._toString_()))
    for _1 in range(self.__first,self.__last):
     self._model._task_1cone_1name_IS(_1,("" if ((int(len(self._name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self._name)._a_S("[")._a_I((_1 - self.__first))._a_S("]")._toString_()))
    self.__names_flushed = True
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=(self._shape_p._size)
   _1=numpy.zeros((_0,), dtype=numpy.dtype(object))
   self._toStringArray__3JJ_3S(mosek.fusion.Utils.Tools._range_J(_0),0,_1)
   _2=mosek.fusion.Utils.StringBuffer()
   _2._a_S("ConicConstraint( (")._a_I(self._shape_p._dim_I(0))
   for _3 in range(1,(self._shape_p.nd)):
    _2._a_S(",")._a_I(self._shape_p._dim_I(_3))
   _2._a_S("),")
   if ((self.__dom._key)==mosek.fusion.QConeKey.InQCone):
    _2._a_S(" QuadCone,")._lf_()
   else:
    _2._a_S(" RotatedQuadCone,")._lf_()
   _2._a_S("  ")._a_S(_1[0])
   for _4 in range(1,int((_1).shape[0])):
    _2._a_S(",")._lf_()._a_S("  ")._a_S(_1[_4])
   _2._a_S(" )")
   return (_2._toString_())
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1snx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_207(_6,_1,_5) # src/fusion/ConicConstraint.mbi:261:9-51
   _5 = numpy.int64(_5) # postprocess
   for _9 in range(0,_5):
    _4[(_9 + _3)] = _8[(numpy.int64(self.__first_slack) + _7._get_())]
    _7._inc_()
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1snx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   fragments._c_closure_208(self.__first_slack,_0,_1,_2,_3) # src/fusion/ConicConstraint.mbi:244:9-245:63
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _9=self._model._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_209(_6,_1,_5) # src/fusion/ConicConstraint.mbi:226:9-51
   _5 = numpy.int64(_5) # postprocess
   for _10 in range(0,_5):
    _4[(_10 + _3)] = (_8[(self.__first_slack + _7._get_())] + _9[self._nativeindexes[_7._get_()]])
    _7._inc_()
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _4=self._model._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   fragments._c_closure_210(self.__first_slack,_0,self._nativeindexes,_1,_2,_4,_3) # src/fusion/ConicConstraint.mbi:207:9-208:85
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _5=numpy.array([(- _1[(_0[(_3 + _6)] - _2)]) for _6 in range(0,_4)], dtype=numpy.dtype(numpy.float64))
   _7=numpy.array([self._nativeindexes[(_0[(_3 + _8)] - _2)] for _8 in range(0,_4)], dtype=numpy.dtype(numpy.int32))
   self._model._task_1con_1putboundlist_1fx__3I_3D(_7,_5)
  def _dual_alt__3IIII_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual__3IIII_3D(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual__3IIII_3D(self,_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((_2 - _1) > (int((_4).shape[0]) - _3)):
    raise mosek_fusion_SliceError._ctor_S("Wrong target array length")
   elif ((_2 < _1) or (_2 >= int((_0).shape[0]))):
    raise mosek_fusion_SliceError._ctor_S("Slice indexes out of bounds")
   _5=self._model._getSolution_1snx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   fragments._c_closure_211(_1,self.__first_slack,_0,_2,_3,_5,_4) # src/fusion/ConicConstraint.mbi:171:11-174:12
  def _dual_1values_alt__3I_3II_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3I_3II_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3I_3II_3D(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   if ((int((_0).shape[0])!=1) or (int((_1).shape[0])!=1)):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice dimensions")
   _4=_0[0]
   _5=_1[0]
   if ((_5 - _4) > (int((_3).shape[0]) - _2)):
    raise mosek_fusion_SliceError._ctor_S("Wrong target array length")
   elif ((_5 < _4) or (_5 > (self.__last_slack - self.__first_slack))):
    raise mosek_fusion_SliceError._ctor_S("Slice indexes out of bounds")
   _6 = self._model._getSolution_1snx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   fragments._c_closure_212(_4,self.__first_slack,_5,_2,_6,_3) # src/fusion/ConicConstraint.mbi:147:11-150:12
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self.__dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return ConicConstraint
mosek_fusion_ConicConstraint=__mk_mosek_fusion_ConicConstraint()
del __mk_mosek_fusion_ConicConstraint
#BEFORE CLASS
def __mk_mosek_fusion_LinearConstraint():
 class LinearConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_LinearConstraint__dom','_LinearConstraint__idxmap']
  def __repr__(self): return 'mosek.fusion.LinearConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = LinearConstraint.__new__(LinearConstraint)
    o._ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__dom = (c.__dom)
   self.__idxmap = None
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    o = LinearConstraint.__new__(LinearConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 12: return False
    model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model_) and __arg_match_S__(name_) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(dom_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match__3I__(nidxs_) and __arg_match__3J__(ptrb) and __arg_match__3I__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(barsubi) and __arg_match__3I__(barsubj) and __arg_match__3I__(barmatidx))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 12: return False
    model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model_) and __arg_alt_match_S__(name_) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(dom_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match__3I__(nidxs_) and __arg_alt_match__3J__(ptrb) and __arg_alt_match__3I__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(barsubi) and __arg_alt_match__3I__(barsubj) and __arg_alt_match__3I__(barmatidx))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(model_,name_,dom_,shape_,numpy.array(nidxs_,dtype=numpy.dtype(numpy.int32)),numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int32)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj,dtype=numpy.dtype(numpy.int32)),numpy.array(barmatidx,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4LinearDomain_2Lmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,dom_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx):
   assert nidxs_ is None or isinstance(nidxs_,numpy.ndarray)
   assert ptrb is None or isinstance(ptrb,numpy.ndarray)
   assert subj is None or isinstance(subj,numpy.ndarray)
   assert cof is None or isinstance(cof,numpy.ndarray)
   assert bfix is None or isinstance(bfix,numpy.ndarray)
   assert barsubi is None or isinstance(barsubi,numpy.ndarray)
   assert barsubj is None or isinstance(barsubj,numpy.ndarray)
   assert barmatidx is None or isinstance(barmatidx,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4Set_2_3I_3J_3I_3D_3D_3I_3I_3I(self,model_,name_,shape_,nidxs_,ptrb,subj,cof,bfix,barsubi,barsubj,barmatidx)
   self.__dom = dom_
   self.__idxmap = None
  def _add_1fx_alt__3J_3DJII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int64(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _1 = self._add_1fx__3J_3DJII(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1fx__3J_3DJII(self,_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((self.__dom._key)==mosek.fusion.RelationKey.IsFree):
    pass
   else:
    _5 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
    _6=numpy.array([self._nativeindexes[(_0[(_3 + _7)] - _2)] for _7 in range(0,_4)], dtype=numpy.dtype(numpy.int32))
    _5 = numpy.array([(self.__dom._get_1rhs_1item_J((_0[(_3 + _8)] - _2)) - _1[(_0[(_3 + _8)] - _2)]) for _8 in range(0,_4)], dtype=numpy.dtype(numpy.float64))
    if ((self.__dom._key)==mosek.fusion.RelationKey.EqualsTo):
     self._model._task_1con_1putboundlist_1fx__3I_3D(_6,_5)
    elif ((self.__dom._key)==mosek.fusion.RelationKey.LessThan):
     self._model._task_1con_1putboundlist_1up__3I_3D(_6,_5)
    elif ((self.__dom._key)==mosek.fusion.RelationKey.GreaterThan):
     self._model._task_1con_1putboundlist_1lo__3I_3D(_6,_5)
  def _dual_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1y_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_213(_6,_1,_5) # src/fusion/LinearConstraint.mbi:182:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self._nativeindexes is not None):
    for _9 in range(0,_5):
     _4[(_9 + _3)] = _8[self._nativeindexes[_7._get_()]]
     _7._inc_()
   else:
    for _10 in range(0,_5):
     if self.__idxmap._hasItem_J(_7._get_()):
      _4[_10] = _8[self.__idxmap._getItem_J(_7._get_())]
     else:
      _4[_10] = 0.0
     _7._inc_()
  def _dual_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1y_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self._nativeindexes is not None):
    fragments._c_closure_214(_0,self._nativeindexes,_1,_2,_3) # src/fusion/LinearConstraint.mbi:159:11-160:58
   else:
    for _4 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_4]):
      _2[(_1 + _4)] = _3[self.__idxmap._getItem_J(_0[_4])]
     else:
      _2[(_1 + _4)] = 0.0
  def _level_1values_alt_J_3I_3JI_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values_J_3I_3JI_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values_J_3I_3JI_3D(self,_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=1
   _6=int((_2).shape[0])
   _7=mosek_fusion_IndexCounter._ctor_J_3I_3J(_0,_1,_2)
   _8=self._model._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _5 = fragments._c_closure_215(_6,_1,_5) # src/fusion/LinearConstraint.mbi:117:9-51
   _5 = numpy.int64(_5) # postprocess
   if (self._nativeindexes is not None):
    for _9 in range(0,_5):
     _4[(_9 + _3)] = _8[self._nativeindexes[_7._get_()]]
     _7._inc_()
   else:
    for _10 in range(0,_5):
     if self.__idxmap._hasItem_J(_7._get_()):
      _4[_10] = _8[self.__idxmap._getItem_J(_7._get_())]
     else:
      _4[_10] = 0.0
     _7._inc_()
  def _level_1values_alt__3JI_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._level_1values__3JI_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _level_1values__3JI_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=self._model._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   if (self._nativeindexes is not None):
    fragments._c_closure_216(_0,self._nativeindexes,_1,_2,_3) # src/fusion/LinearConstraint.mbi:87:11-89:59
   else:
    for _4 in range(0,int((_0).shape[0])):
     if self.__idxmap._hasItem_J(_0[_4]):
      _2[(_1 + _4)] = _3[self.__idxmap._getItem_J(_0[_4])]
     else:
      _2[(_1 + _4)] = 0.0
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self.__dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearConstraint._ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearConstraint
mosek_fusion_LinearConstraint=__mk_mosek_fusion_LinearConstraint()
del __mk_mosek_fusion_LinearConstraint
#BEFORE CLASS
def __mk_mosek_fusion_Set():
 class Set(object):
  __slots__ = ['_size','_nd_p','nd']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_IJ(*args): # int32,int64
      self._ctor_init_IJ(*args)
    elif self.__match_alt_ctor_IJ(*args):# int32,int64
      self._ctor_alt_init_IJ(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Set.ctor(int32,int64)')
  @staticmethod
  def make(*args):
    if False: pass
    elif mosek_fusion_Set._match_make__3S(*args): # []string
      return mosek_fusion_Set._make__3S(*args)
    elif mosek_fusion_Set._match_alt_make__3S(*args): # []string
      return mosek_fusion_Set._make_alt__3S(*args)
    elif mosek_fusion_Set._match_make_I(*args): # int32
      return mosek_fusion_Set._make_I(*args)
    elif mosek_fusion_Set._match_alt_make_I(*args): # int32
      return mosek_fusion_Set._make_alt_I(*args)
    elif mosek_fusion_Set._match_make__3I(*args): # []int32
      return mosek_fusion_Set._make__3I(*args)
    elif mosek_fusion_Set._match_alt_make__3I(*args): # []int32
      return mosek_fusion_Set._make_alt__3I(*args)
    elif mosek_fusion_Set._match_make__3Lmosek_4fusion_4Set_2(*args): # []mosek.fusion.Set
      return mosek_fusion_Set._make__3Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Set._match_alt_make__3Lmosek_4fusion_4Set_2(*args): # []mosek.fusion.Set
      return mosek_fusion_Set._make_alt__3Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Set._match_make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Set,mosek.fusion.Set
      return mosek_fusion_Set._make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Set._match_alt_make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Set,mosek.fusion.Set
      return mosek_fusion_Set._make_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Set._match_make_II(*args): # int32,int32
      return mosek_fusion_Set._make_II(*args)
    elif mosek_fusion_Set._match_alt_make_II(*args): # int32,int32
      return mosek_fusion_Set._make_alt_II(*args)
    elif mosek_fusion_Set._match_make_III(*args): # int32,int32,int32
      return mosek_fusion_Set._make_III(*args)
    elif mosek_fusion_Set._match_alt_make_III(*args): # int32,int32,int32
      return mosek_fusion_Set._make_alt_III(*args)
    else:
      raise ValueError('Invalid argument list make('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.make(array(string,ndim=1))\n\tmosek.fusion.Set.make(int32)\n\tmosek.fusion.Set.make(array(int32,ndim=1))\n\tmosek.fusion.Set.make(array(mosek.fusion.Set,ndim=1))\n\tmosek.fusion.Set.make(mosek.fusion.Set,mosek.fusion.Set)\n\tmosek.fusion.Set.make(int32,int32)\n\tmosek.fusion.Set.make(int32,int32,int32)')
  def idxtokey(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_idxtokey_J(*args): # int64
      return self._idxtokey_J(*args)
    elif mosek_fusion_Set._match_alt_idxtokey_J(*args): # int64
      return self._idxtokey_alt_J(*args)
    else:
      raise ValueError('Invalid argument list idxtokey('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.idxtokey(int64)')
  def realnd(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_realnd_(*args): # 
      return self._realnd_(*args)
    elif mosek_fusion_Set._match_alt_realnd_(*args): # 
      return self._realnd_alt_(*args)
    else:
      raise ValueError('Invalid argument list realnd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.realnd()')
  def dim(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_dim_I(*args): # int32
      return self._dim_I(*args)
    elif mosek_fusion_Set._match_alt_dim_I(*args): # int32
      return self._dim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list dim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.dim(int32)')
  def getname(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_getname_J(*args): # int64
      return self._getname_J(*args)
    elif mosek_fusion_Set._match_alt_getname_J(*args): # int64
      return self._getname_alt_J(*args)
    elif mosek_fusion_Set._match_getname__3I(*args): # []int32
      return self._getname__3I(*args)
    elif mosek_fusion_Set._match_alt_getname__3I(*args): # []int32
      return self._getname_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list getname('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.getname(int64)\n\tmosek.fusion.Set.getname(array(int32,ndim=1))')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Set._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Set._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.slice(int32,int32)\n\tmosek.fusion.Set.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def stride(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_stride_I(*args): # int32
      return self._stride_I(*args)
    elif mosek_fusion_Set._match_alt_stride_I(*args): # int32
      return self._stride_alt_I(*args)
    else:
      raise ValueError('Invalid argument list stride('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.stride(int32)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Set._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.toString()')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_Set._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.getSize()')
  @staticmethod
  def scalar(*args):
    if False: pass
    elif mosek_fusion_Set._match_scalar_(*args): # 
      return mosek_fusion_Set._scalar_(*args)
    elif mosek_fusion_Set._match_alt_scalar_(*args): # 
      return mosek_fusion_Set._scalar_alt_(*args)
    else:
      raise ValueError('Invalid argument list scalar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.scalar()')
  def compare(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_compare_Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Set
      return self._compare_Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Set._match_alt_compare_Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Set
      return self._compare_alt_Lmosek_4fusion_4Set_2(*args)
    else:
      raise ValueError('Invalid argument list compare('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.compare(mosek.fusion.Set)')
  def indexToString(self,*args):
    if False: pass
    elif mosek_fusion_Set._match_indexToString_J(*args): # int64
      return self._indexToString_J(*args)
    elif mosek_fusion_Set._match_alt_indexToString_J(*args): # int64
      return self._indexToString_alt_J(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.indexToString(int64)')
  def __repr__(self): return 'mosek.fusion.Set'
  @staticmethod
  def _ctor_IJ(nd_,size_):
    o = Set.__new__(Set)
    o._ctor_init_IJ(nd_,size_)
    return o
  @staticmethod
  def __match_ctor_IJ(*args):
    if len(args) != 2: return False
    nd_,size_, = args
    return (__arg_match_I__(nd_) and __arg_match_J__(size_))
  @staticmethod
  def __match_alt_ctor_IJ(*args):
    if len(args) != 2: return False
    nd_,size_, = args
    return (__arg_alt_match_I__(nd_) and __arg_alt_match_J__(size_))
  def _ctor_alt_init_IJ(self,nd_,size_):
    self._ctor_init_IJ(numpy.int32(nd_),numpy.int64(size_))
  def _ctor_init_IJ(self,nd_,size_):
   object.__init__(self)
   self.nd = nd_
   self._nd_p = nd_
   self._size = size_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("Set(shape=(")._a_I(self._dim_I(0))
   for _1 in range(1,self.nd):
    _0._a_S(",")._a_I(self._dim_I(_1))
   _0._a_S("))")
   return (_0._toString_())
  @staticmethod
  def _match_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _indexToString_alt_J(self,_t__0):
    return self._indexToString_J(numpy.int64(__0))
  def _indexToString_J(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  def _linearidx_alt_III(self,_t__0,_t__1,_t__2):
    return self._linearidx_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _linearidx_III(self,_0,_1,_2):
   return numpy.int64(numpy.int64(((((_0 * self._dim_I(1)) + _1) * self._dim_I(2)) + _2)))
  def _linearidx_alt_II(self,_t__0,_t__1):
    return self._linearidx_II(numpy.int32(__0),numpy.int32(__1))
  def _linearidx_II(self,_0,_1):
   return numpy.int32(((_0 * self._dim_I(1)) + _1))
  def _linearidx_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._linearidx__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _linearidx__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=_0[0]
   for _2 in range(1,int((_0).shape[0])):
    _1 = ((_1 * self._dim_I(_2)) + _0[_2])
   return numpy.int64(_1)
  @staticmethod
  def _match_idxtokey_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_idxtokey_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _idxtokey_alt_J(self,_t__0):
    return self._idxtokey_J(numpy.int64(__0))
  def _idxtokey_J(self,_0):
   _1=numpy.zeros((self._nd_p,), dtype=numpy.dtype(numpy.int32))
   _2=_0
   for _3 in range(0,self._nd_p):
    _1[_3] = numpy.int32((_2 // self._stride_I(_3)))
    _2 = (_2 % self._stride_I(_3))
   return (_1)
  @staticmethod
  def _match_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _getname_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._getname__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getname__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _getname_alt_J(self,_t__0):
    return self._getname_J(numpy.int64(__0))
  def _getname_J(self,_0):
   pass
  @staticmethod
  def _match_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _stride_alt_I(self,_t__0):
    return self._stride_I(numpy.int32(__0))
  def _stride_I(self,_0):
   pass
  @staticmethod
  def _match_dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _dim_alt_I(self,_t__0):
    return self._dim_I(numpy.int32(__0))
  def _dim_I(self,_0):
   pass
  @staticmethod
  def _match_make__3Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Set_2__(_0))
  @staticmethod
  def _match_alt_make__3Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Set_2__(_0))
  @staticmethod
  def _make_alt__3Lmosek_4fusion_4Set_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Set._make__3Lmosek_4fusion_4Set_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3Lmosek_4fusion_4Set_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ProductSet._ctor__3Lmosek_4fusion_4Set_2(_0))
  @staticmethod
  def _match_make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1))
  @staticmethod
  def _match_alt_make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1))
  @staticmethod
  def _make_alt_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(_t__0,_t__1):
    return mosek_fusion_Set._make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(_0,_1)
  @staticmethod
  def _make_Lmosek_4fusion_4Set_2Lmosek_4fusion_4Set_2(_0,_1):
   return (mosek_fusion_ProductSet._ctor__3Lmosek_4fusion_4Set_2(numpy.array([_0,_1], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_make__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_make__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _make_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._make__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_NDSet._ctor__3I(_0))
  @staticmethod
  def _match_make_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_make_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _make_alt_III(_t__0,_t__1,_t__2):
    return mosek_fusion_Set._make_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _make_III(_0,_1,_2):
   return (mosek_fusion_NDSet._ctor__3I(numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_make_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_make_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _make_alt_II(_t__0,_t__1):
    return mosek_fusion_Set._make_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _make_II(_0,_1):
   return (mosek_fusion_NDSet._ctor__3I(numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_make_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_make_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _make_alt_I(_t__0):
    return mosek_fusion_Set._make_I(numpy.int32(__0))
  @staticmethod
  def _make_I(_0):
   return (mosek_fusion_IntSet._ctor_I(_0))
  @staticmethod
  def _match_scalar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_scalar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _scalar_alt_():
    return mosek_fusion_Set._scalar_()
  @staticmethod
  def _scalar_():
   return (mosek.fusion.Set._make_I(1))
  @staticmethod
  def _match_make__3S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3S__(_0))
  @staticmethod
  def _match_alt_make__3S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3S__(_0))
  @staticmethod
  def _make_alt__3S(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Set._make__3S(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3S(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_StringSet._ctor__3S(_0))
  @staticmethod
  def _match_realnd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_realnd_(*args):
    if len(args) != 0: return False
    return True
  def _realnd_alt_(self,):
    return self._realnd_()
  def _realnd_(self,):
   if (self.nd==1):
    return numpy.int32(1)
   else:
    _0=0
    _1=0
    while (_1 < self.nd):
     if (self._dim_I(_1)!=1):
      _0 += 1
     _1 += 1
    if (_0==0):
     _0 += 1
    return numpy.int32(_0)
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   return numpy.int64(self._size)
  @staticmethod
  def _match_compare_Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0))
  @staticmethod
  def _match_alt_compare_Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0))
  def _compare_alt_Lmosek_4fusion_4Set_2(self,_t__0):
    return self._compare_Lmosek_4fusion_4Set_2(_0)
  def _compare_Lmosek_4fusion_4Set_2(self,_0):
   if ((self._size!=(_0._size)) or (self._realnd_()!=_0._realnd_())):
    return (False)
   _1=0
   _2=0
   while ((_1 < self.nd) and (_2 < (_0.nd))):
    if (self._dim_I(_1)==1):
     _1 += 1
    elif (_0._dim_I(_2)==1):
     _2 += 1
    elif (self._dim_I(_1)!=_0._dim_I(_2)):
     return (False)
    else:
     _1 += 1
     _2 += 1
   return (True)
 return Set
mosek_fusion_Set=__mk_mosek_fusion_Set()
del __mk_mosek_fusion_Set
#BEFORE CLASS
def __mk_mosek_fusion_BaseSet():
 class BaseSet(mosek_fusion_Set):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_J(*args): # int64
      self._ctor_init_J(*args)
    elif self.__match_alt_ctor_J(*args):# int64
      self._ctor_alt_init_J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.BaseSet.ctor(int64)')
  def dim(self,*args):
    if False: pass
    elif mosek_fusion_BaseSet._match_dim_I(*args): # int32
      return self._dim_I(*args)
    elif mosek_fusion_BaseSet._match_alt_dim_I(*args): # int32
      return self._dim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list dim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseSet.dim(int32)')
  def __repr__(self): return 'mosek.fusion.BaseSet'
  @staticmethod
  def _ctor_J(size_):
    o = BaseSet.__new__(BaseSet)
    o._ctor_init_J(size_)
    return o
  @staticmethod
  def __match_ctor_J(*args):
    if len(args) != 1: return False
    size_, = args
    return (__arg_match_J__(size_))
  @staticmethod
  def __match_alt_ctor_J(*args):
    if len(args) != 1: return False
    size_, = args
    return (__arg_alt_match_J__(size_))
  def _ctor_alt_init_J(self,size_):
    self._ctor_init_J(numpy.int64(size_))
  def _ctor_init_J(self,size_):
   mosek_fusion_Set._ctor_init_IJ(self,1,size_)
  @staticmethod
  def _match_dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _dim_alt_I(self,_t__0):
    return self._dim_I(numpy.int32(__0))
  def _dim_I(self,_0):
   if (_0 < 0):
    raise mosek_fusion_IndexError._ctor_S("Invalid dimension")
   elif (_0 > 0):
    return numpy.int32(1)
   else:
    return numpy.int32(numpy.int32(self._size))
 return BaseSet
mosek_fusion_BaseSet=__mk_mosek_fusion_BaseSet()
del __mk_mosek_fusion_BaseSet
#BEFORE CLASS
def __mk_mosek_fusion_IntSet():
 class IntSet(mosek_fusion_BaseSet):
  __slots__ = ['_IntSet__last','_IntSet__first']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_I(*args): # int32
      self._ctor_init_I(*args)
    elif self.__match_alt_ctor_I(*args):# int32
      self._ctor_alt_init_I(*args)
    elif self.__match_ctor_II(*args): # int32,int32
      self._ctor_init_II(*args)
    elif self.__match_alt_ctor_II(*args):# int32,int32
      self._ctor_alt_init_II(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IntSet.ctor(int32)\n\tmosek.fusion.IntSet.ctor(int32,int32)')
  def getidx(self,*args):
    if False: pass
    elif mosek_fusion_IntSet._match_getidx_I(*args): # int32
      return self._getidx_I(*args)
    elif mosek_fusion_IntSet._match_alt_getidx_I(*args): # int32
      return self._getidx_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IntSet.getidx(int32)')
  def indexToString(self,*args):
    if False: pass
    elif mosek_fusion_IntSet._match_indexToString_J(*args): # int64
      return self._indexToString_J(*args)
    elif mosek_fusion_IntSet._match_alt_indexToString_J(*args): # int64
      return self._indexToString_alt_J(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IntSet.indexToString(int64)')
  def stride(self,*args):
    if False: pass
    elif mosek_fusion_IntSet._match_stride_I(*args): # int32
      return self._stride_I(*args)
    elif mosek_fusion_IntSet._match_alt_stride_I(*args): # int32
      return self._stride_alt_I(*args)
    else:
      raise ValueError('Invalid argument list stride('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IntSet.stride(int32)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_IntSet._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_IntSet._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_IntSet._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_IntSet._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IntSet.slice(int32,int32)\n\tmosek.fusion.IntSet.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getname(self,*args):
    if False: pass
    elif mosek_fusion_IntSet._match_getname_J(*args): # int64
      return self._getname_J(*args)
    elif mosek_fusion_IntSet._match_alt_getname_J(*args): # int64
      return self._getname_alt_J(*args)
    elif mosek_fusion_IntSet._match_getname__3I(*args): # []int32
      return self._getname__3I(*args)
    elif mosek_fusion_IntSet._match_alt_getname__3I(*args): # []int32
      return self._getname_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list getname('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IntSet.getname(int64)\n\tmosek.fusion.IntSet.getname(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.IntSet'
  @staticmethod
  def _ctor_I(length):
    o = IntSet.__new__(IntSet)
    o._ctor_init_I(length)
    return o
  @staticmethod
  def __match_ctor_I(*args):
    if len(args) != 1: return False
    length, = args
    return (__arg_match_I__(length))
  @staticmethod
  def __match_alt_ctor_I(*args):
    if len(args) != 1: return False
    length, = args
    return (__arg_alt_match_I__(length))
  def _ctor_alt_init_I(self,length):
    self._ctor_init_I(numpy.int32(length))
  def _ctor_init_I(self,length):
   mosek_fusion_BaseSet._ctor_init_J(self,numpy.int64(length))
   self.__first = 0
   self.__last = length
  @staticmethod
  def _ctor_II(first_,last_):
    o = IntSet.__new__(IntSet)
    o._ctor_init_II(first_,last_)
    return o
  @staticmethod
  def __match_ctor_II(*args):
    if len(args) != 2: return False
    first_,last_, = args
    return (__arg_match_I__(first_) and __arg_match_I__(last_))
  @staticmethod
  def __match_alt_ctor_II(*args):
    if len(args) != 2: return False
    first_,last_, = args
    return (__arg_alt_match_I__(first_) and __arg_alt_match_I__(last_))
  def _ctor_alt_init_II(self,first_,last_):
    self._ctor_init_II(numpy.int32(first_),numpy.int32(last_))
  def _ctor_init_II(self,first_,last_):
   mosek_fusion_BaseSet._ctor_init_J(self,numpy.int64((last_ - first_)))
   self.__first = first_
   self.__last = last_
  @staticmethod
  def _match_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _indexToString_alt_J(self,_t__0):
    return self._indexToString_J(numpy.int64(__0))
  def _indexToString_J(self,_0):
   return (mosek.fusion.Utils.StringBuffer()._a_I(numpy.int32(_0))._toString_())
  @staticmethod
  def _match_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _getname_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._getname__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getname__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((_0).shape[0])!=1):
    raise mosek_fusion_IndexError._ctor_S("Invalid key specification")
   return (mosek.fusion.Utils.Tools._stringvalue_I(_0[0]))
  @staticmethod
  def _match_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _getname_alt_J(self,_t__0):
    return self._getname_J(numpy.int64(__0))
  def _getname_J(self,_0):
   return (mosek.fusion.Utils.Tools._stringvalue_J(_0))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int((_0).shape[0])!=1) or (int((_1).shape[0])!=1)):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   return (self._slice_II(_0[0],_1[0]))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if ((_0 < 0) or ((_0 > _1) or (_1 > (self.__last - self.__first)))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   return (mosek_fusion_IntSet._ctor_II((self.__first + _0),(self.__first + _1)))
  @staticmethod
  def _match_getidx_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getidx_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getidx_alt_I(self,_t__0):
    return self._getidx_I(numpy.int32(__0))
  def _getidx_I(self,_0):
   if ((_0 < self.__first) or (_0 > self.__last)):
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   return numpy.int32((_0 - self.__first))
  @staticmethod
  def _match_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _stride_alt_I(self,_t__0):
    return self._stride_I(numpy.int32(__0))
  def _stride_I(self,_0):
   return numpy.int64(1)
 return IntSet
mosek_fusion_IntSet=__mk_mosek_fusion_IntSet()
del __mk_mosek_fusion_IntSet
#BEFORE CLASS
def __mk_mosek_fusion_StringSet():
 class StringSet(mosek_fusion_BaseSet):
  __slots__ = ['_StringSet__keys']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3S(*args): # []string
      self._ctor_init__3S(*args)
    elif self.__match_alt_ctor__3S(*args):# []string
      self._ctor_alt_init__3S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.StringSet.ctor(array(string,ndim=1))')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_StringSet._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_StringSet._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_StringSet._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_StringSet._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.StringSet.slice(int32,int32)\n\tmosek.fusion.StringSet.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getname(self,*args):
    if False: pass
    elif mosek_fusion_StringSet._match_getname_J(*args): # int64
      return self._getname_J(*args)
    elif mosek_fusion_StringSet._match_alt_getname_J(*args): # int64
      return self._getname_alt_J(*args)
    elif mosek_fusion_StringSet._match_getname__3I(*args): # []int32
      return self._getname__3I(*args)
    elif mosek_fusion_StringSet._match_alt_getname__3I(*args): # []int32
      return self._getname_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list getname('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.StringSet.getname(int64)\n\tmosek.fusion.StringSet.getname(array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_StringSet._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_StringSet._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.StringSet.toString()')
  def indexToString(self,*args):
    if False: pass
    elif mosek_fusion_StringSet._match_indexToString_J(*args): # int64
      return self._indexToString_J(*args)
    elif mosek_fusion_StringSet._match_alt_indexToString_J(*args): # int64
      return self._indexToString_alt_J(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.StringSet.indexToString(int64)')
  def stride(self,*args):
    if False: pass
    elif mosek_fusion_StringSet._match_stride_I(*args): # int32
      return self._stride_I(*args)
    elif mosek_fusion_StringSet._match_alt_stride_I(*args): # int32
      return self._stride_alt_I(*args)
    else:
      raise ValueError('Invalid argument list stride('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.StringSet.stride(int32)')
  def __repr__(self): return 'mosek.fusion.StringSet'
  @staticmethod
  def _ctor__3S(ks):
    o = StringSet.__new__(StringSet)
    o._ctor_init__3S(ks)
    return o
  @staticmethod
  def __match_ctor__3S(*args):
    if len(args) != 1: return False
    ks, = args
    return (__arg_match__3S__(ks))
  @staticmethod
  def __match_alt_ctor__3S(*args):
    if len(args) != 1: return False
    ks, = args
    return (__arg_alt_match__3S__(ks))
  def _ctor_alt_init__3S(self,ks):
    self._ctor_init__3S(numpy.array(ks,dtype=numpy.dtype(object)))
  def _ctor_init__3S(self,ks):
   assert ks is None or isinstance(ks,numpy.ndarray)
   mosek_fusion_BaseSet._ctor_init_J(self,numpy.int64(int((ks).shape[0])))
   self.__keys = mosek.fusion.Utils.Tools._arraycopy__3S(ks)
  @staticmethod
  def _match_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _indexToString_alt_J(self,_t__0):
    return self._indexToString_J(numpy.int64(__0))
  def _indexToString_J(self,_0):
   return (self.__keys[_0])
  @staticmethod
  def _match_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _getname_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._getname__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getname__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((_0).shape[0])!=1):
    raise mosek_fusion_IndexError._ctor_S("Invalid key specification")
   return (self.__keys[_0[0]])
  @staticmethod
  def _match_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _getname_alt_J(self,_t__0):
    return self._getname_J(numpy.int64(__0))
  def _getname_J(self,_0):
   return (self.__keys[_0])
  def _slice_1_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice_1__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice_1__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int((_0).shape[0])!=1) or ((int((_1).shape[0])!=1) or ((_0[0] < 0) or ((_0[0] > _1[0]) or (_1[0] >= int((self.__keys).shape[0])))))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   return (self._slice_1_II(_0[0],_1[0]))
  def _slice_1_alt_II(self,_t__0,_t__1):
    return self._slice_1_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_1_II(self,_0,_1):
   if ((_0 < 0) or ((_0 > _1) or (_1 > int((self.__keys).shape[0])))):
    raise mosek_fusion_SliceError._ctor_S("Invalid slice specification")
   return (mosek_fusion_StringSet._ctor__3S(numpy.array([self.__keys[(_2 + _0)] for _2 in range(0,(_1 - _0))], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self._slice_1__3I_3I(_0,_1))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (self._slice_1_II(_0,_1))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("{'")._a_S(self.__keys[0])._a_S("'")
   _1=1
   while (_1 < int((self.__keys).shape[0])):
    _0._a_S(",'")._a_S(self.__keys[_1])._a_S("'")
    _1 += 1
   _0._a_S("}")
   return (_0._toString_())
  @staticmethod
  def _match_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _stride_alt_I(self,_t__0):
    return self._stride_I(numpy.int32(__0))
  def _stride_I(self,_0):
   return numpy.int64(1)
 return StringSet
mosek_fusion_StringSet=__mk_mosek_fusion_StringSet()
del __mk_mosek_fusion_StringSet
#BEFORE CLASS
def __mk_mosek_fusion_NDSet():
 class NDSet(mosek_fusion_Set):
  __slots__ = ['_NDSet__strides','_NDSet__dimdef']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3I(*args): # []int32
      self._ctor_init__3I(*args)
    elif self.__match_alt_ctor__3I(*args):# []int32
      self._ctor_alt_init__3I(*args)
    elif self.__match_ctor_II(*args): # int32,int32
      self._ctor_init_II(*args)
    elif self.__match_alt_ctor_II(*args):# int32,int32
      self._ctor_alt_init_II(*args)
    elif self.__match_ctor_III(*args): # int32,int32,int32
      self._ctor_init_III(*args)
    elif self.__match_alt_ctor_III(*args):# int32,int32,int32
      self._ctor_alt_init_III(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.NDSet.ctor(array(int32,ndim=1))\n\tmosek.fusion.NDSet.ctor(int32,int32)\n\tmosek.fusion.NDSet.ctor(int32,int32,int32)')
  def indexToString(self,*args):
    if False: pass
    elif mosek_fusion_NDSet._match_indexToString_J(*args): # int64
      return self._indexToString_J(*args)
    elif mosek_fusion_NDSet._match_alt_indexToString_J(*args): # int64
      return self._indexToString_alt_J(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSet.indexToString(int64)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_NDSet._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_NDSet._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_NDSet._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_NDSet._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSet.slice(int32,int32)\n\tmosek.fusion.NDSet.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def dim(self,*args):
    if False: pass
    elif mosek_fusion_NDSet._match_dim_I(*args): # int32
      return self._dim_I(*args)
    elif mosek_fusion_NDSet._match_alt_dim_I(*args): # int32
      return self._dim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list dim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSet.dim(int32)')
  def stride(self,*args):
    if False: pass
    elif mosek_fusion_NDSet._match_stride_I(*args): # int32
      return self._stride_I(*args)
    elif mosek_fusion_NDSet._match_alt_stride_I(*args): # int32
      return self._stride_alt_I(*args)
    else:
      raise ValueError('Invalid argument list stride('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSet.stride(int32)')
  def getname(self,*args):
    if False: pass
    elif mosek_fusion_NDSet._match_getname_J(*args): # int64
      return self._getname_J(*args)
    elif mosek_fusion_NDSet._match_alt_getname_J(*args): # int64
      return self._getname_alt_J(*args)
    elif mosek_fusion_NDSet._match_getname__3I(*args): # []int32
      return self._getname__3I(*args)
    elif mosek_fusion_NDSet._match_alt_getname__3I(*args): # []int32
      return self._getname_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list getname('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSet.getname(int64)\n\tmosek.fusion.NDSet.getname(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.NDSet'
  @staticmethod
  def _ctor_III(size0,size1,size2):
    o = NDSet.__new__(NDSet)
    o._ctor_init_III(size0,size1,size2)
    return o
  @staticmethod
  def __match_ctor_III(*args):
    if len(args) != 3: return False
    size0,size1,size2, = args
    return (__arg_match_I__(size0) and __arg_match_I__(size1) and __arg_match_I__(size2))
  @staticmethod
  def __match_alt_ctor_III(*args):
    if len(args) != 3: return False
    size0,size1,size2, = args
    return (__arg_alt_match_I__(size0) and __arg_alt_match_I__(size1) and __arg_alt_match_I__(size2))
  def _ctor_alt_init_III(self,size0,size1,size2):
    self._ctor_init_III(numpy.int32(size0),numpy.int32(size1),numpy.int32(size2))
  def _ctor_init_III(self,size0,size1,size2):
   mosek_fusion_Set._ctor_init_IJ(self,3,numpy.int64(((size0 * size1) * size2)))
   self.__dimdef = numpy.array([size0,size1,size2], dtype=numpy.dtype(numpy.int32))
   self.__strides = numpy.array([numpy.int64((size1 * size2)),numpy.int64(size2),1], dtype=numpy.dtype(numpy.int64))
  @staticmethod
  def _ctor_II(size0,size1):
    o = NDSet.__new__(NDSet)
    o._ctor_init_II(size0,size1)
    return o
  @staticmethod
  def __match_ctor_II(*args):
    if len(args) != 2: return False
    size0,size1, = args
    return (__arg_match_I__(size0) and __arg_match_I__(size1))
  @staticmethod
  def __match_alt_ctor_II(*args):
    if len(args) != 2: return False
    size0,size1, = args
    return (__arg_alt_match_I__(size0) and __arg_alt_match_I__(size1))
  def _ctor_alt_init_II(self,size0,size1):
    self._ctor_init_II(numpy.int32(size0),numpy.int32(size1))
  def _ctor_init_II(self,size0,size1):
   mosek_fusion_Set._ctor_init_IJ(self,2,numpy.int64((size0 * size1)))
   self.__dimdef = numpy.array([size0,size1], dtype=numpy.dtype(numpy.int32))
   self.__strides = numpy.array([numpy.int64(size1),1], dtype=numpy.dtype(numpy.int64))
  @staticmethod
  def _ctor__3I(dims):
    o = NDSet.__new__(NDSet)
    o._ctor_init__3I(dims)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    dims, = args
    return (__arg_match__3I__(dims))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    dims, = args
    return (__arg_alt_match__3I__(dims))
  def _ctor_alt_init__3I(self,dims):
    self._ctor_init__3I(numpy.array(dims,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,dims):
   assert dims is None or isinstance(dims,numpy.ndarray)
   mosek_fusion_Set._ctor_init_IJ(self,int((dims).shape[0]),mosek.fusion.NDSet.__sumdims__3I(dims))
   for _0 in range(0,self.nd):
    if (dims[_0] < 0):
     raise mosek_fusion_SliceError._ctor_S("Negative dimension size")
   self.__dimdef = numpy.array([dims[_1] for _1 in range(0,int((dims).shape[0]))], dtype=numpy.dtype(numpy.int32))
   self.__strides = numpy.zeros((self.nd,), dtype=numpy.dtype(numpy.int64))
   self.__strides[(self.nd - 1)] = 1
   fragments._c_closure_217(self.__dimdef,self.nd,self.__strides) # src/fusion/NDSet.mbi:63:9-64:49
  @staticmethod
  def _match_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _indexToString_alt_J(self,_t__0):
    return self._indexToString_J(numpy.int64(__0))
  def _indexToString_J(self,_0):
   _1=mosek.fusion.Utils.StringBuffer()
   _2=self._idxtokey_J(_0)
   _1._a_I(_2[0])
   for _3 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(_2[_3])
   return (_1._toString_())
  @staticmethod
  def _match_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_getname__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _getname_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._getname__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getname__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.nd!=int((_0).shape[0])):
    raise mosek_fusion_DimensionError._ctor_S("Key dimensions do not match set dimensions.")
   _1=0
   while (_1 < self.nd):
    if ((_0[_1] < 0) or (_0[_1] >= (self.__dimdef[_1] + 1))):
     raise mosek_fusion_IndexError._ctor_S("Key dimensions do not match set dimensions.")
    _1 += 1
   _2=mosek.fusion.Utils.StringBuffer()
   _2._a_I(_0[0])
   for _3 in range(1,self.nd):
    _2._a_S(",")._a_I(_0[_3])
   return (_2._toString_())
  @staticmethod
  def _match_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_getname_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _getname_alt_J(self,_t__0):
    return self._getname_J(numpy.int64(__0))
  def _getname_J(self,_0):
   if (self.nd==1):
    _1=numpy.zeros((self.nd,), dtype=numpy.dtype(numpy.int64))
    _2=_0
    _2 = fragments._c_closure_218(_2,self.nd,_1,self.__strides) # src/fusion/NDSet.mbi:169:11-173:12
    _2 = numpy.int64(_2) # postprocess
    _3=mosek.fusion.Utils.StringBuffer()
    _3._a_J(_0)
    return (_3._toString_())
   else:
    return (self._getname__3I(self._idxtokey_J(_0)))
  @staticmethod
  def _match_dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _dim_alt_I(self,_t__0):
    return self._dim_I(numpy.int32(__0))
  def _dim_I(self,_0):
   return numpy.int32((1 if ((_0 >= self.nd) ) else self.__dimdef[_0]))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((self.nd!=int((_0).shape[0])) or (self.nd!=int((_1).shape[0]))):
    raise mosek_fusion_SliceError._ctor_S("Slice dimensions do not match set dimensions.")
   _2=0
   while (_2 < self.nd):
    if ((_0[_2] < 0) or ((_1[_2] < _0[_2]) or (_1[_2] > self.__dimdef[_2]))):
     raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds.")
    _2 += 1
   _3=numpy.array([(_1[_4] - _0[_4]) for _4 in range(0,self.nd)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_NDSet._ctor__3I(_3))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if (self.nd!=1):
    raise mosek_fusion_SliceError._ctor_S("Slice dimensions do not match set dimensions.")
   elif ((_0 < 0) or ((_1 < _0) or (_1 > self._size))):
    raise mosek_fusion_SliceError._ctor_S("Slice dimensions do not match set dimensions.")
   return (mosek_fusion_IntSet._ctor_II(_0,_1))
  def _selectidxs_alt__3S(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = self._selectidxs__3S(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _selectidxs__3S(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   raise mosek_fusion_IndexError._ctor_S("invalid key type")
  def _linear_1index_1in_1dim_alt_I_3I(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._linear_1index_1in_1dim_I_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _linear_1index_1in_1dim_I_3I(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   raise mosek_fusion_IndexError._ctor_S("invalid key type")
  def _linear_1index_1in_1dim_alt_II(self,_t__0,_t__1):
    return self._linear_1index_1in_1dim_II(numpy.int32(__0),numpy.int32(__1))
  def _linear_1index_1in_1dim_II(self,_0,_1):
   if ((_0 < 0) or (_0 >= int((self.__dimdef).shape[0]))):
    raise mosek_fusion_IndexError._ctor_S("dimension index out of bounds")
   if ((_1 < 0) or (_1 >= self.__dimdef[_0])):
    raise mosek_fusion_IndexError._ctor_S("key out of bounds")
   else:
    return numpy.int32(_1)
  @staticmethod
  def __sumdims_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_NDSet.__sumdims__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __sumdims__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=1
   _1 = fragments._c_closure_219(_0,_1) # src/fusion/NDSet.mbi:32:9-33:26
   _1 = numpy.int64(_1) # postprocess
   return numpy.int64(_1)
  @staticmethod
  def _match_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_stride_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _stride_alt_I(self,_t__0):
    return self._stride_I(numpy.int32(__0))
  def _stride_I(self,_0):
   return numpy.int64(self.__strides[_0])
 return NDSet
mosek_fusion_NDSet=__mk_mosek_fusion_NDSet()
del __mk_mosek_fusion_NDSet
#BEFORE CLASS
def __mk_mosek_fusion_ProductSet():
 class ProductSet(mosek_fusion_NDSet):
  __slots__ = ['_ProductSet__sets']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3Lmosek_4fusion_4Set_2(*args): # []mosek.fusion.Set
      self._ctor_init__3Lmosek_4fusion_4Set_2(*args)
    elif self.__match_alt_ctor__3Lmosek_4fusion_4Set_2(*args):# []mosek.fusion.Set
      self._ctor_alt_init__3Lmosek_4fusion_4Set_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ProductSet.ctor(array(mosek.fusion.Set,ndim=1))')
  def indexToString(self,*args):
    if False: pass
    elif mosek_fusion_ProductSet._match_indexToString_J(*args): # int64
      return self._indexToString_J(*args)
    elif mosek_fusion_ProductSet._match_alt_indexToString_J(*args): # int64
      return self._indexToString_alt_J(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ProductSet.indexToString(int64)')
  def __repr__(self): return 'mosek.fusion.ProductSet'
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Set_2(ss):
    o = ProductSet.__new__(ProductSet)
    o._ctor_init__3Lmosek_4fusion_4Set_2(ss)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    ss, = args
    return (__arg_match__3Lmosek_4fusion_4Set_2__(ss))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    ss, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Set_2__(ss))
  def _ctor_alt_init__3Lmosek_4fusion_4Set_2(self,ss):
    self._ctor_init__3Lmosek_4fusion_4Set_2(numpy.array(ss,dtype=numpy.dtype(object)))
  def _ctor_init__3Lmosek_4fusion_4Set_2(self,ss):
   assert ss is None or isinstance(ss,numpy.ndarray)
   mosek_fusion_NDSet._ctor_init__3I(self,mosek.fusion.ProductSet.__computedims__3Lmosek_4fusion_4Set_2(ss))
   self.__sets = numpy.array([ss[_0] for _0 in range(0,int((ss).shape[0]))], dtype=numpy.dtype(object))
  @staticmethod
  def _match_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_indexToString_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _indexToString_alt_J(self,_t__0):
    return self._indexToString_J(numpy.int64(__0))
  def _indexToString_J(self,_0):
   _1=self._idxtokey_J(_0)
   _2=mosek.fusion.Utils.StringBuffer()
   _3=numpy.array([_1[_4] for _4 in range(0,(self.__sets[0].nd))], dtype=numpy.dtype(numpy.int32))
   _2._a_S(self.__sets[0]._indexToString_J(self.__sets[0]._linearidx__3I(_3)))
   _5=(self.__sets[0].nd)
   for _6 in range(1,int((self.__sets).shape[0])):
    _7=_5
    _5 = (_5 + (self.__sets[_6].nd))
    _8=numpy.array([_1[(_9 + _7)] for _9 in range(0,(_5 - _7))], dtype=numpy.dtype(numpy.int32))
    _2._a_S(",")._a_S(self.__sets[_6]._indexToString_J(self.__sets[_6]._linearidx__3I(_8)))
   return (_2._toString_())
  @staticmethod
  def __computedims_alt__3Lmosek_4fusion_4Set_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_ProductSet.__computedims__3Lmosek_4fusion_4Set_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computedims__3Lmosek_4fusion_4Set_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=0
   for _2 in range(0,int((_0).shape[0])):
    _1 = (_1 + (_0[_2].nd))
   _3=numpy.array([_0[_4]._dim_I(_5) for _4 in range(0,int((_0).shape[0])) for _5 in range(0,(_0[_4].nd))], dtype=numpy.dtype(numpy.int32))
   return (_3)
 return ProductSet
mosek_fusion_ProductSet=__mk_mosek_fusion_ProductSet()
del __mk_mosek_fusion_ProductSet
#BEFORE CLASS
def __mk_mosek_fusion_QConeDomain():
 class QConeDomain(object):
  __slots__ = ['_shape','_int_flag','_axisidx','_key']
  def axis(self,*args):
    if False: pass
    elif mosek_fusion_QConeDomain._match_axis_I(*args): # int32
      return self._axis_I(*args)
    elif mosek_fusion_QConeDomain._match_alt_axis_I(*args): # int32
      return self._axis_alt_I(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.QConeDomain.axis(int32)')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_QConeDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_QConeDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.QConeDomain.integral()')
  def getAxis(self,*args):
    if False: pass
    elif mosek_fusion_QConeDomain._match_getAxis_(*args): # 
      return self._getAxis_(*args)
    elif mosek_fusion_QConeDomain._match_alt_getAxis_(*args): # 
      return self._getAxis_alt_(*args)
    else:
      raise ValueError('Invalid argument list getAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.QConeDomain.getAxis()')
  def __repr__(self): return 'mosek.fusion.QConeDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4QConeKey_2_3II(k,d,a):
    o = QConeDomain.__new__(QConeDomain)
    o._ctor_init_Emosek_4fusion_4QConeKey_2_3II(k,d,a)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4QConeKey_2_3II(*args):
    if len(args) != 3: return False
    k,d,a, = args
    return (__arg_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_match__3I__(d) and __arg_match_I__(a))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4QConeKey_2_3II(*args):
    if len(args) != 3: return False
    k,d,a, = args
    return (__arg_alt_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_alt_match__3I__(d) and __arg_alt_match_I__(a))
  def _ctor_alt_init_Emosek_4fusion_4QConeKey_2_3II(self,k,d,a):
    self._ctor_init_Emosek_4fusion_4QConeKey_2_3II(k,numpy.array(d,dtype=numpy.dtype(numpy.int32)),numpy.int32(a))
  def _ctor_init_Emosek_4fusion_4QConeKey_2_3II(self,k,d,a):
   assert d is None or isinstance(d,numpy.ndarray)
   object.__init__(self)
   self._shape = (mosek.fusion.Set._make__3I(d) if ((d is not None) ) else None)
   self._key = k
   self._axisidx = a
   self._int_flag = False
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if (self._key==mosek.fusion.QConeKey.InQCone):
    if (self._shape is not None):
     _2=self._shape._idxtokey_J(_0)
     _1._a_S(" : element (")._a_I(_2[0])
     for _3 in range(1,int((_2).shape[0])):
      _1._a_S(",")._a_I(_2[_3])
     _1._a_S(") in a quadratic cone of size (")._a_I(self._shape._dim_I(0))
     for _4 in range(1,int((_2).shape[0])):
      _1._a_S(",")._a_I(self._shape._dim_I(_4))
     _1._a_S(")")
    else:
     _1._a_S(" : element in a quadratic cone")
   elif (self._key==mosek.fusion.QConeKey.InRotatedQCone):
    if (self._shape is not None):
     _5=self._shape._idxtokey_J(_0)
     _1._a_S(" : element (")._a_I(_5[0])
     for _6 in range(1,int((_5).shape[0])):
      _1._a_S(",")._a_I(_5[_6])
     _1._a_S(") in a rotated quadratic cone of size (")._a_I(self._shape._dim_I(0))
     for _7 in range(1,int((_5).shape[0])):
      _1._a_S(",")._a_I(self._shape._dim_I(_7))
     _1._a_S(")")
    else:
     _1._a_S(" : element in a rotated quadratic cone")
   return (_1._toString_())
  def _match_1shape_alt_Lmosek_4fusion_4Set_2(self,_t__0):
    return self._match_1shape_Lmosek_4fusion_4Set_2(_0)
  def _match_1shape_Lmosek_4fusion_4Set_2(self,_0):
   return (((self._shape is None) or self._shape._compare_Lmosek_4fusion_4Set_2(_0)))
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._int_flag = True
   return (self)
  @staticmethod
  def _match_getAxis_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getAxis_(*args):
    if len(args) != 0: return False
    return True
  def _getAxis_alt_(self,):
    return self._getAxis_()
  def _getAxis_(self,):
   return numpy.int32(self._axisidx)
  @staticmethod
  def _match_axis_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_axis_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _axis_alt_I(self,_t__0):
    return self._axis_I(numpy.int32(__0))
  def _axis_I(self,_0):
   self._axisidx = _0
   return (self)
 return QConeDomain
mosek_fusion_QConeDomain=__mk_mosek_fusion_QConeDomain()
del __mk_mosek_fusion_QConeDomain
#BEFORE CLASS
def __mk_mosek_fusion_LinPSDDomain():
 class LinPSDDomain(object):
  __slots__ = ['_shape']
  def __repr__(self): return 'mosek.fusion.LinPSDDomain'
  @staticmethod
  def _ctor_():
    o = LinPSDDomain.__new__(LinPSDDomain)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   object.__init__(self)
   self._shape = None
  @staticmethod
  def _ctor_Lmosek_4fusion_4Set_2(shp):
    o = LinPSDDomain.__new__(LinPSDDomain)
    o._ctor_init_Lmosek_4fusion_4Set_2(shp)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    shp, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(shp))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Set_2(*args):
    if len(args) != 1: return False
    shp, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(shp))
  def _ctor_alt_init_Lmosek_4fusion_4Set_2(self,shp):
    self._ctor_init_Lmosek_4fusion_4Set_2(shp)
  def _ctor_init_Lmosek_4fusion_4Set_2(self,shp):
   object.__init__(self)
   self._shape = shp
 return LinPSDDomain
mosek_fusion_LinPSDDomain=__mk_mosek_fusion_LinPSDDomain()
del __mk_mosek_fusion_LinPSDDomain
#BEFORE CLASS
def __mk_mosek_fusion_PSDDomain():
 class PSDDomain(object):
  __slots__ = ['_key','_shape']
  def __repr__(self): return 'mosek.fusion.PSDDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2(k):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2(k)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2(*args):
    if len(args) != 1: return False
    k, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2(*args):
    if len(args) != 1: return False
    k, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2(self,k):
    self._ctor_init_Emosek_4fusion_4PSDKey_2(k)
  def _ctor_init_Emosek_4fusion_4PSDKey_2(self,k):
   object.__init__(self)
   self._shape = None
   self._key = k
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(k,shp):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(k,shp)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    k,shp, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_match_Lmosek_4fusion_4Set_2__(shp))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    k,shp, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shp))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(self,k,shp):
    self._ctor_init_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(k,shp)
  def _ctor_init_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(self,k,shp):
   object.__init__(self)
   self._shape = shp
   self._key = k
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if (self._shape is not None):
    _2=self._shape._idxtokey_J(_0)
    _1._a_S(" : element (")._a_I(_2[0])
    for _3 in range(1,int((_2).shape[0])):
     _1._a_S(",")._a_I(_2[_3])
    _1._a_S(") in a semidefinite cone of size (")._a_I(self._shape._dim_I(0))
    for _4 in range(1,int((_2).shape[0])):
     _1._a_S(",")._a_I(self._shape._dim_I(_4))
    _1._a_S(")")
   else:
    _1._a_S(" : element in a semidefinite cone")
   return (_1._toString_())
 return PSDDomain
mosek_fusion_PSDDomain=__mk_mosek_fusion_PSDDomain()
del __mk_mosek_fusion_PSDDomain
#BEFORE CLASS
def __mk_mosek_fusion_RangeDomain():
 class RangeDomain(object):
  __slots__ = ['_sparse_flag','_cardinal_flag','_RangeDomain__ub','_RangeDomain__lb','_RangeDomain__idxmap','_shape']
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_sparse_(*args): # 
      return self._sparse_(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse_(*args): # 
      return self._sparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.sparse()')
  def symmetric(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_symmetric_(*args): # 
      return self._symmetric_(*args)
    elif mosek_fusion_RangeDomain._match_alt_symmetric_(*args): # 
      return self._symmetric_alt_(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.symmetric()')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_RangeDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.integral()')
  def __repr__(self): return 'mosek.fusion.RangeDomain'
  @staticmethod
  def _ctor__3D_3D_3I_3J(lb_,ub_,dims,inst):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init__3D_3D_3I_3J(lb_,ub_,dims,inst)
    return o
  @staticmethod
  def __match_ctor__3D_3D_3I_3J(*args):
    if len(args) != 4: return False
    lb_,ub_,dims,inst, = args
    return (__arg_match__3D__(lb_) and __arg_match__3D__(ub_) and __arg_match__3I__(dims) and __arg_match__3J__(inst))
  @staticmethod
  def __match_alt_ctor__3D_3D_3I_3J(*args):
    if len(args) != 4: return False
    lb_,ub_,dims,inst, = args
    return (__arg_alt_match__3D__(lb_) and __arg_alt_match__3D__(ub_) and __arg_alt_match__3I__(dims) and __arg_alt_match__3J__(inst))
  def _ctor_alt_init__3D_3D_3I_3J(self,lb_,ub_,dims,inst):
    self._ctor_init__3D_3D_3I_3J(numpy.array(lb_,dtype=numpy.dtype(numpy.float64)),numpy.array(ub_,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(inst,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init__3D_3D_3I_3J(self,lb_,ub_,dims,inst):
   assert lb_ is None or isinstance(lb_,numpy.ndarray)
   assert ub_ is None or isinstance(ub_,numpy.ndarray)
   assert dims is None or isinstance(dims,numpy.ndarray)
   assert inst is None or isinstance(inst,numpy.ndarray)
   object.__init__(self)
   self._cardinal_flag = False
   self._sparse_flag = False
   if (dims is None):
    self._shape = None
   else:
    self._shape = mosek.fusion.Set._make__3I(dims)
   if (inst is not None):
    self.__idxmap = mosek.fusion.Utils.IntMap()
    for _0 in range(0,int((lb_).shape[0])):
     self.__idxmap._setItem_JI(inst[_0],_0)
   else:
    self.__idxmap = None
   self.__ub = ub_
   self.__lb = lb_
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangeDomain_2(other):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4RangeDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other):
   object.__init__(self)
   self._cardinal_flag = (other._cardinal_flag)
   self._sparse_flag = (other._sparse_flag)
   self._shape = (other._shape)
   self.__idxmap = (other.__idxmap)
   self.__ub = (other.__ub)
   self.__lb = (other.__lb)
  @staticmethod
  def _match_symmetric_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_symmetric_(*args):
    if len(args) != 0: return False
    return True
  def _symmetric_alt_(self,):
    return self._symmetric_()
  def _symmetric_(self,):
   return (mosek_fusion_SymmetricRangeDomain._ctor_Lmosek_4fusion_4RangeDomain_2(self))
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   self._sparse_flag = True
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   return (_1._a_S(" in [ ")._a_D(self._get_1lb_1item_J(_0))._a_S(",")._a_D(self._get_1ub_1item_J(_0))._a_S("]")._toString_())
  def _match_1shape_alt_Lmosek_4fusion_4Set_2(self,_t__0):
    return self._match_1shape_Lmosek_4fusion_4Set_2(_0)
  def _match_1shape_Lmosek_4fusion_4Set_2(self,_0):
   if (self._shape is None):
    return (True)
   else:
    return (self._shape._compare_Lmosek_4fusion_4Set_2(_0))
  def _get_1ub_1item_alt_J(self,_t__0):
    return self._get_1ub_1item_J(numpy.int64(__0))
  def _get_1ub_1item_J(self,_0):
   if (self.__idxmap is not None):
    if (self.__ub is None):
     return numpy.float64(0.0)
    else:
     if self.__idxmap._hasItem_J(_0):
      return numpy.float64(self.__ub[self.__idxmap._getItem_J(_0)])
     else:
      return numpy.float64(0.0)
   else:
    if (int((self.__ub).shape[0])==1):
     return numpy.float64(self.__ub[0])
    elif (self.__ub is not None):
     return numpy.float64(self.__ub[_0])
    else:
     return numpy.float64(0.0)
  def _get_1lb_1item_alt_J(self,_t__0):
    return self._get_1lb_1item_J(numpy.int64(__0))
  def _get_1lb_1item_J(self,_0):
   if (self.__idxmap is not None):
    if (self.__lb is None):
     return numpy.float64(0.0)
    elif self.__idxmap._hasItem_J(_0):
     return numpy.float64(self.__lb[self.__idxmap._getItem_J(_0)])
    else:
     return numpy.float64(0.0)
   else:
    if (int((self.__lb).shape[0])==1):
     return numpy.float64(self.__lb[0])
    elif (self.__lb is not None):
     return numpy.float64(self.__lb[_0])
    else:
     return numpy.float64(0.0)
 return RangeDomain
mosek_fusion_RangeDomain=__mk_mosek_fusion_RangeDomain()
del __mk_mosek_fusion_RangeDomain
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricRangeDomain():
 class SymmetricRangeDomain(mosek_fusion_RangeDomain):
  __slots__ = ['_dim']
  def __repr__(self): return 'mosek.fusion.SymmetricRangeDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangeDomain_2(other):
    o = SymmetricRangeDomain.__new__(SymmetricRangeDomain)
    o._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4RangeDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other):
   mosek_fusion_RangeDomain._ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other)
   if ((self._shape is not None) and (((self._shape.nd)!=2) or (self._shape._dim_I(0)!=(other._shape)._dim_I(1)))):
    raise mosek_fusion_DimensionError._ctor_S("Only square domains can be symmetric")
   self._dim = (0 if ((self._shape is None) ) else self._shape._dim_I(0))
 return SymmetricRangeDomain
mosek_fusion_SymmetricRangeDomain=__mk_mosek_fusion_SymmetricRangeDomain()
del __mk_mosek_fusion_SymmetricRangeDomain
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricLinearDomain():
 class SymmetricLinearDomain(object):
  __slots__ = ['_sparse_flag','_cardinal_flag','_key','_shape','_dom','_dim']
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricLinearDomain._match_sparse_(*args): # 
      return self._sparse_(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_alt_sparse_(*args): # 
      return self._sparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricLinearDomain.sparse()')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricLinearDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricLinearDomain.integral()')
  def __repr__(self): return 'mosek.fusion.SymmetricLinearDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearDomain_2(other):
    o = SymmetricLinearDomain.__new__(SymmetricLinearDomain)
    o._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinearDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4LinearDomain_2(self,other):
   object.__init__(self)
   self._dom = other
   self._shape = (other._shape)
   self._key = (other._key)
   self._cardinal_flag = (other._cardinal_flag)
   self._sparse_flag = (other._sparse_flag)
   if ((self._shape is not None) and (((self._shape.nd)!=2) or (self._shape._dim_I(0)!=(other._shape)._dim_I(1)))):
    raise mosek_fusion_DimensionError._ctor_S("Only square domains can be symmetric")
   self._dim = (0 if ((self._shape is None) ) else self._shape._dim_I(0))
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   self._sparse_flag = True
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   return (self._dom._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1))
  def _match_1shape_alt_Lmosek_4fusion_4Set_2(self,_t__0):
    return self._match_1shape_Lmosek_4fusion_4Set_2(_0)
  def _match_1shape_Lmosek_4fusion_4Set_2(self,_0):
   return (self._dom._match_1shape_Lmosek_4fusion_4Set_2(_0))
  def _get_1rhs_1item_alt_J(self,_t__0):
    return self._get_1rhs_1item_J(numpy.int64(__0))
  def _get_1rhs_1item_J(self,_0):
   return numpy.float64(self._dom._get_1rhs_1item_J(_0))
 return SymmetricLinearDomain
mosek_fusion_SymmetricLinearDomain=__mk_mosek_fusion_SymmetricLinearDomain()
del __mk_mosek_fusion_SymmetricLinearDomain
#BEFORE CLASS
def __mk_mosek_fusion_LinearDomain():
 class LinearDomain(object):
  __slots__ = ['_sparse_flag','_cardinal_flag','_key','_LinearDomain__bnd','_LinearDomain__inst','_shape']
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_sparse_(*args): # 
      return self._sparse_(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse_(*args): # 
      return self._sparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.sparse()')
  def symmetric(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_symmetric_(*args): # 
      return self._symmetric_(*args)
    elif mosek_fusion_LinearDomain._match_alt_symmetric_(*args): # 
      return self._symmetric_alt_(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.symmetric()')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_LinearDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.integral()')
  def __repr__(self): return 'mosek.fusion.LinearDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(k,rhs,sp,dims):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Emosek_4fusion_4RelationKey_2_3D_3J_3I(k,rhs,sp,dims)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(*args):
    if len(args) != 4: return False
    k,rhs,sp,dims, = args
    return (__arg_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_match__3D__(rhs) and __arg_match__3J__(sp) and __arg_match__3I__(dims))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(*args):
    if len(args) != 4: return False
    k,rhs,sp,dims, = args
    return (__arg_alt_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_alt_match__3D__(rhs) and __arg_alt_match__3J__(sp) and __arg_alt_match__3I__(dims))
  def _ctor_alt_init_Emosek_4fusion_4RelationKey_2_3D_3J_3I(self,k,rhs,sp,dims):
    self._ctor_init_Emosek_4fusion_4RelationKey_2_3D_3J_3I(k,numpy.array(rhs,dtype=numpy.dtype(numpy.float64)),numpy.array(sp,dtype=numpy.dtype(numpy.int64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4RelationKey_2_3D_3J_3I(self,k,rhs,sp,dims):
   assert rhs is None or isinstance(rhs,numpy.ndarray)
   assert sp is None or isinstance(sp,numpy.ndarray)
   assert dims is None or isinstance(dims,numpy.ndarray)
   object.__init__(self)
   self._shape = (mosek.fusion.Set._make__3I(dims) if ((dims is not None) ) else None)
   self._key = k
   self.__bnd = rhs
   if (sp is not None):
    self.__inst = mosek.fusion.Utils.IntMap()
    for _0 in range(0,int((sp).shape[0])):
     self.__inst._setItem_JI(sp[_0],_0)
   else:
    self.__inst = None
   self._cardinal_flag = False
   self._sparse_flag = False
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearDomain_2(other):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinearDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4LinearDomain_2(self,other):
   object.__init__(self)
   self._shape = (other._shape)
   self.__inst = (other.__inst)
   self.__bnd = (other.__bnd)
   self._key = (other._key)
   self._cardinal_flag = (other._cardinal_flag)
   self._sparse_flag = (other._sparse_flag)
  @staticmethod
  def _match_symmetric_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_symmetric_(*args):
    if len(args) != 0: return False
    return True
  def _symmetric_alt_(self,):
    return self._symmetric_()
  def _symmetric_(self,):
   return (mosek_fusion_SymmetricLinearDomain._ctor_Lmosek_4fusion_4LinearDomain_2(self))
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   self._sparse_flag = True
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if (self._key==mosek.fusion.RelationKey.EqualsTo):
    _1._a_S(" = ")._a_D(self._get_1rhs_1item_J(_0))
   elif (self._key==mosek.fusion.RelationKey.LessThan):
    _1._a_S(" <= ")._a_D(self._get_1rhs_1item_J(_0))
   elif (self._key==mosek.fusion.RelationKey.GreaterThan):
    _1._a_S(" >= ")._a_D(self._get_1rhs_1item_J(_0))
   elif (self._key==mosek.fusion.RelationKey.IsFree):
    _1._a_S(" is unbounded")
   return (_1._toString_())
  def _match_1shape_alt_Lmosek_4fusion_4Set_2(self,_t__0):
    return self._match_1shape_Lmosek_4fusion_4Set_2(_0)
  def _match_1shape_Lmosek_4fusion_4Set_2(self,_0):
   if (self._shape is None):
    return (True)
   else:
    return (self._shape._compare_Lmosek_4fusion_4Set_2(_0))
  def _get_1rhs_1item_alt_J(self,_t__0):
    return self._get_1rhs_1item_J(numpy.int64(__0))
  def _get_1rhs_1item_J(self,_0):
   if (self.__inst is not None):
    if self.__inst._hasItem_J(_0):
     return numpy.float64(self.__bnd[self.__inst._getItem_J(_0)])
    else:
     return numpy.float64(0.0)
   else:
    if self.__scalable_():
     return numpy.float64((self.__bnd[0] if ((self.__bnd is not None) ) else 0.0))
    else:
     return numpy.float64((self.__bnd[_0] if ((self.__bnd is not None) ) else 0.0))
  def __scalable_alt_(self,):
    return self.__scalable_()
  def __scalable_(self,):
   return (((self.__bnd is None) or ((int((self.__bnd).shape[0])==1) and (self.__inst is None))))
 return LinearDomain
mosek_fusion_LinearDomain=__mk_mosek_fusion_LinearDomain()
del __mk_mosek_fusion_LinearDomain
#BEFORE CLASS
def __mk_mosek_fusion_Domain():
 class Domain(object):
  @staticmethod
  def binary(*args):
    if False: pass
    elif mosek_fusion_Domain._match_binary_(*args): # 
      return mosek_fusion_Domain._binary_(*args)
    elif mosek_fusion_Domain._match_alt_binary_(*args): # 
      return mosek_fusion_Domain._binary_alt_(*args)
    elif mosek_fusion_Domain._match_binary__3I(*args): # []int32
      return mosek_fusion_Domain._binary__3I(*args)
    elif mosek_fusion_Domain._match_alt_binary__3I(*args): # []int32
      return mosek_fusion_Domain._binary_alt__3I(*args)
    elif mosek_fusion_Domain._match_binary_I(*args): # int32
      return mosek_fusion_Domain._binary_I(*args)
    elif mosek_fusion_Domain._match_alt_binary_I(*args): # int32
      return mosek_fusion_Domain._binary_alt_I(*args)
    elif mosek_fusion_Domain._match_binary_II(*args): # int32,int32
      return mosek_fusion_Domain._binary_II(*args)
    elif mosek_fusion_Domain._match_alt_binary_II(*args): # int32,int32
      return mosek_fusion_Domain._binary_alt_II(*args)
    else:
      raise ValueError('Invalid argument list binary('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.binary()\n\tmosek.fusion.Domain.binary(array(int32,ndim=1))\n\tmosek.fusion.Domain.binary(int32)\n\tmosek.fusion.Domain.binary(int32,int32)')
  @staticmethod
  def inPSDCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inPSDCone_(*args): # 
      return mosek_fusion_Domain._inPSDCone_(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_(*args): # 
      return mosek_fusion_Domain._inPSDCone_alt_(*args)
    elif mosek_fusion_Domain._match_inPSDCone_I(*args): # int32
      return mosek_fusion_Domain._inPSDCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_I(*args): # int32
      return mosek_fusion_Domain._inPSDCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inPSDCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inPSDCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inPSDCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inPSDCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPSDCone()\n\tmosek.fusion.Domain.inPSDCone(int32)\n\tmosek.fusion.Domain.inPSDCone(int32,int32)')
  @staticmethod
  def inRange(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inRange_DLmosek_4fusion_4Matrix_2(*args): # double,mosek.fusion.Matrix
      return mosek_fusion_Domain._inRange_DLmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_inRange_DLmosek_4fusion_4Matrix_2(*args): # double,mosek.fusion.Matrix
      return mosek_fusion_Domain._inRange_alt_DLmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_inRange_Lmosek_4fusion_4Matrix_2D(*args): # mosek.fusion.Matrix,double
      return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2D(*args)
    elif mosek_fusion_Domain._match_alt_inRange_Lmosek_4fusion_4Matrix_2D(*args): # mosek.fusion.Matrix,double
      return mosek_fusion_Domain._inRange_alt_Lmosek_4fusion_4Matrix_2D(*args)
    elif mosek_fusion_Domain._match_inRange_DD(*args): # double,double
      return mosek_fusion_Domain._inRange_DD(*args)
    elif mosek_fusion_Domain._match_alt_inRange_DD(*args): # double,double
      return mosek_fusion_Domain._inRange_alt_DD(*args)
    elif mosek_fusion_Domain._match_inRange__3D_3D(*args): # []double,[]double
      return mosek_fusion_Domain._inRange__3D_3D(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3D_3D(*args): # []double,[]double
      return mosek_fusion_Domain._inRange_alt__3D_3D(*args)
    elif mosek_fusion_Domain._match_inRange__3DD(*args): # []double,double
      return mosek_fusion_Domain._inRange__3DD(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3DD(*args): # []double,double
      return mosek_fusion_Domain._inRange_alt__3DD(*args)
    elif mosek_fusion_Domain._match_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix,mosek.fusion.Matrix
      return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix,mosek.fusion.Matrix
      return mosek_fusion_Domain._inRange_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_inRange_D_3D(*args): # double,[]double
      return mosek_fusion_Domain._inRange_D_3D(*args)
    elif mosek_fusion_Domain._match_alt_inRange_D_3D(*args): # double,[]double
      return mosek_fusion_Domain._inRange_alt_D_3D(*args)
    else:
      raise ValueError('Invalid argument list inRange('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inRange(double,mosek.fusion.Matrix)\n\tmosek.fusion.Domain.inRange(mosek.fusion.Matrix,double)\n\tmosek.fusion.Domain.inRange(double,double)\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),array(double,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),double)\n\tmosek.fusion.Domain.inRange(mosek.fusion.Matrix,mosek.fusion.Matrix)\n\tmosek.fusion.Domain.inRange(double,array(double,ndim=1))')
  @staticmethod
  def equalsTo(*args):
    if False: pass
    elif mosek_fusion_Domain._match_equalsTo__3D(*args): # []double
      return mosek_fusion_Domain._equalsTo__3D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3D(*args): # []double
      return mosek_fusion_Domain._equalsTo_alt__3D(*args)
    elif mosek_fusion_Domain._match_equalsTo_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._equalsTo_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._equalsTo_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_equalsTo__3_5D(*args): # [,]double
      return mosek_fusion_Domain._equalsTo__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3_5D(*args): # [,]double
      return mosek_fusion_Domain._equalsTo_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_equalsTo_D(*args): # double
      return mosek_fusion_Domain._equalsTo_D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_D(*args): # double
      return mosek_fusion_Domain._equalsTo_alt_D(*args)
    elif mosek_fusion_Domain._match_equalsTo_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._equalsTo_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._equalsTo_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_equalsTo__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._equalsTo__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._equalsTo_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_equalsTo_DI(*args): # double,int32
      return mosek_fusion_Domain._equalsTo_DI(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_DI(*args): # double,int32
      return mosek_fusion_Domain._equalsTo_alt_DI(*args)
    elif mosek_fusion_Domain._match_equalsTo_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._equalsTo_DII(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._equalsTo_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list equalsTo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=1))\n\tmosek.fusion.Domain.equalsTo(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=2))\n\tmosek.fusion.Domain.equalsTo(double)\n\tmosek.fusion.Domain.equalsTo(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.equalsTo(double,int32)\n\tmosek.fusion.Domain.equalsTo(double,int32,int32)')
  @staticmethod
  def inQCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inQCone_(*args): # 
      return mosek_fusion_Domain._inQCone_(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_(*args): # 
      return mosek_fusion_Domain._inQCone_alt_(*args)
    elif mosek_fusion_Domain._match_inQCone_I(*args): # int32
      return mosek_fusion_Domain._inQCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_I(*args): # int32
      return mosek_fusion_Domain._inQCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inQCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inQCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inQCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inQCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inQCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inQCone()\n\tmosek.fusion.Domain.inQCone(int32)\n\tmosek.fusion.Domain.inQCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inQCone(int32,int32)')
  @staticmethod
  def inRotatedQCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inRotatedQCone_(*args): # 
      return mosek_fusion_Domain._inRotatedQCone_(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_(*args): # 
      return mosek_fusion_Domain._inRotatedQCone_alt_(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone_I(*args): # int32
      return mosek_fusion_Domain._inRotatedQCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_I(*args): # int32
      return mosek_fusion_Domain._inRotatedQCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inRotatedQCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inRotatedQCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inRotatedQCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inRotatedQCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inRotatedQCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inRotatedQCone()\n\tmosek.fusion.Domain.inRotatedQCone(int32)\n\tmosek.fusion.Domain.inRotatedQCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inRotatedQCone(int32,int32)')
  @staticmethod
  def greaterThan(*args):
    if False: pass
    elif mosek_fusion_Domain._match_greaterThan__3D(*args): # []double
      return mosek_fusion_Domain._greaterThan__3D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3D(*args): # []double
      return mosek_fusion_Domain._greaterThan_alt__3D(*args)
    elif mosek_fusion_Domain._match_greaterThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._greaterThan_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._greaterThan_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_greaterThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._greaterThan__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._greaterThan_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_greaterThan_D(*args): # double
      return mosek_fusion_Domain._greaterThan_D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_D(*args): # double
      return mosek_fusion_Domain._greaterThan_alt_D(*args)
    elif mosek_fusion_Domain._match_greaterThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._greaterThan_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._greaterThan_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_greaterThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._greaterThan__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._greaterThan_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_greaterThan_DI(*args): # double,int32
      return mosek_fusion_Domain._greaterThan_DI(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_DI(*args): # double,int32
      return mosek_fusion_Domain._greaterThan_alt_DI(*args)
    elif mosek_fusion_Domain._match_greaterThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._greaterThan_DII(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._greaterThan_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list greaterThan('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=1))\n\tmosek.fusion.Domain.greaterThan(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=2))\n\tmosek.fusion.Domain.greaterThan(double)\n\tmosek.fusion.Domain.greaterThan(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.greaterThan(double,int32)\n\tmosek.fusion.Domain.greaterThan(double,int32,int32)')
  @staticmethod
  def sparse(*args):
    if False: pass
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.sparse(mosek.fusion.LinearDomain)\n\tmosek.fusion.Domain.sparse(mosek.fusion.RangeDomain)')
  @staticmethod
  def lessThan(*args):
    if False: pass
    elif mosek_fusion_Domain._match_lessThan__3D(*args): # []double
      return mosek_fusion_Domain._lessThan__3D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3D(*args): # []double
      return mosek_fusion_Domain._lessThan_alt__3D(*args)
    elif mosek_fusion_Domain._match_lessThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._lessThan_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._lessThan_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_lessThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._lessThan__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._lessThan_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_lessThan_D(*args): # double
      return mosek_fusion_Domain._lessThan_D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_D(*args): # double
      return mosek_fusion_Domain._lessThan_alt_D(*args)
    elif mosek_fusion_Domain._match_lessThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._lessThan_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._lessThan_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_lessThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._lessThan__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._lessThan_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_lessThan_DI(*args): # double,int32
      return mosek_fusion_Domain._lessThan_DI(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_DI(*args): # double,int32
      return mosek_fusion_Domain._lessThan_alt_DI(*args)
    elif mosek_fusion_Domain._match_lessThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._lessThan_DII(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._lessThan_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list lessThan('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.lessThan(array(double,ndim=1))\n\tmosek.fusion.Domain.lessThan(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.lessThan(array(double,ndim=2))\n\tmosek.fusion.Domain.lessThan(double)\n\tmosek.fusion.Domain.lessThan(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.lessThan(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.lessThan(double,int32)\n\tmosek.fusion.Domain.lessThan(double,int32,int32)')
  @staticmethod
  def axis(*args):
    if False: pass
    elif mosek_fusion_Domain._match_axis_Lmosek_4fusion_4QConeDomain_2I(*args): # mosek.fusion.QConeDomain,int32
      return mosek_fusion_Domain._axis_Lmosek_4fusion_4QConeDomain_2I(*args)
    elif mosek_fusion_Domain._match_alt_axis_Lmosek_4fusion_4QConeDomain_2I(*args): # mosek.fusion.QConeDomain,int32
      return mosek_fusion_Domain._axis_alt_Lmosek_4fusion_4QConeDomain_2I(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.axis(mosek.fusion.QConeDomain,int32)')
  @staticmethod
  def integral(*args):
    if False: pass
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.QConeDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4QConeDomain_2(*args): # mosek.fusion.QConeDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4QConeDomain_2(*args)
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.integral(mosek.fusion.QConeDomain)\n\tmosek.fusion.Domain.integral(mosek.fusion.LinearDomain)\n\tmosek.fusion.Domain.integral(mosek.fusion.RangeDomain)')
  @staticmethod
  def unbounded(*args):
    if False: pass
    elif mosek_fusion_Domain._match_unbounded_(*args): # 
      return mosek_fusion_Domain._unbounded_(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_(*args): # 
      return mosek_fusion_Domain._unbounded_alt_(*args)
    elif mosek_fusion_Domain._match_unbounded_I(*args): # int32
      return mosek_fusion_Domain._unbounded_I(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_I(*args): # int32
      return mosek_fusion_Domain._unbounded_alt_I(*args)
    elif mosek_fusion_Domain._match_unbounded__3I(*args): # []int32
      return mosek_fusion_Domain._unbounded__3I(*args)
    elif mosek_fusion_Domain._match_alt_unbounded__3I(*args): # []int32
      return mosek_fusion_Domain._unbounded_alt__3I(*args)
    elif mosek_fusion_Domain._match_unbounded_II(*args): # int32,int32
      return mosek_fusion_Domain._unbounded_II(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_II(*args): # int32,int32
      return mosek_fusion_Domain._unbounded_alt_II(*args)
    else:
      raise ValueError('Invalid argument list unbounded('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.unbounded()\n\tmosek.fusion.Domain.unbounded(int32)\n\tmosek.fusion.Domain.unbounded(array(int32,ndim=1))\n\tmosek.fusion.Domain.unbounded(int32,int32)')
  @staticmethod
  def symmetric(*args):
    if False: pass
    elif mosek_fusion_Domain._match_symmetric_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_symmetric_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._symmetric_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_symmetric_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_symmetric_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._symmetric_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.symmetric(mosek.fusion.LinearDomain)\n\tmosek.fusion.Domain.symmetric(mosek.fusion.RangeDomain)')
  @staticmethod
  def isTrilPSD(*args):
    if False: pass
    elif mosek_fusion_Domain._match_isTrilPSD_(*args): # 
      return mosek_fusion_Domain._isTrilPSD_(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_(*args): # 
      return mosek_fusion_Domain._isTrilPSD_alt_(*args)
    elif mosek_fusion_Domain._match_isTrilPSD_I(*args): # int32
      return mosek_fusion_Domain._isTrilPSD_I(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_I(*args): # int32
      return mosek_fusion_Domain._isTrilPSD_alt_I(*args)
    elif mosek_fusion_Domain._match_isTrilPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isTrilPSD_II(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isTrilPSD_alt_II(*args)
    else:
      raise ValueError('Invalid argument list isTrilPSD('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.isTrilPSD()\n\tmosek.fusion.Domain.isTrilPSD(int32)\n\tmosek.fusion.Domain.isTrilPSD(int32,int32)')
  @staticmethod
  def isLinPSD(*args):
    if False: pass
    elif mosek_fusion_Domain._match_isLinPSD_(*args): # 
      return mosek_fusion_Domain._isLinPSD_(*args)
    elif mosek_fusion_Domain._match_alt_isLinPSD_(*args): # 
      return mosek_fusion_Domain._isLinPSD_alt_(*args)
    elif mosek_fusion_Domain._match_isLinPSD_I(*args): # int32
      return mosek_fusion_Domain._isLinPSD_I(*args)
    elif mosek_fusion_Domain._match_alt_isLinPSD_I(*args): # int32
      return mosek_fusion_Domain._isLinPSD_alt_I(*args)
    elif mosek_fusion_Domain._match_isLinPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isLinPSD_II(*args)
    elif mosek_fusion_Domain._match_alt_isLinPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isLinPSD_alt_II(*args)
    else:
      raise ValueError('Invalid argument list isLinPSD('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.isLinPSD()\n\tmosek.fusion.Domain.isLinPSD(int32)\n\tmosek.fusion.Domain.isLinPSD(int32,int32)')
  def __repr__(self): return 'mosek.fusion.Domain'
  @staticmethod
  def __dimsize_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__dimsize__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __dimsize__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=1
   _1 = fragments._c_closure_220(_0,_1) # src/fusion/domain.mbi:331:73-114
   _1 = numpy.int64(_1) # postprocess
   return numpy.int64(_1)
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(__0,_1)
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if _1._isSparse_():
    _2=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _3=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _1._getDataAsTriplets__3I_3I_3D(_2,_3,_4)
    _5=numpy.array([((_2[_6] * (_1._dimj)) + _3[_6]) for _6 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int64))
    return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,_4,_5,numpy.array([(_1._dimi),(_1._dimj)], dtype=numpy.dtype(numpy.int32))))
   else:
    return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,_1._getDataAsArray_(),None,numpy.array([(_1._dimi),(_1._dimj)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,numpy.array([_1[_2,_3] for _2 in range(0,int((_1).shape[0])) for _3 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.float64)),None,numpy.array([int((_1).shape[0]),int((_1).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2_3D_3I(_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D_3I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D_3I(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,numpy.array([_1[_3] for _3 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),None,numpy.array([_2[_4] for _4 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,numpy.array([_1[_2] for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),None,numpy.array([int((_1).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2D_3I(_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.float64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(_0,_1,_2):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,numpy.array([_1 for _3 in range(0,mosek.fusion.Domain.__dimsize__3I(_2))], dtype=numpy.dtype(numpy.float64)),None,numpy.array([_2[_4] for _4 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2D(_t__0,_t__1):
    return mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D(__0,numpy.float64(__1))
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2D(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(_0,numpy.array([_1], dtype=numpy.dtype(numpy.float64)),None,None))
  @staticmethod
  def __inRange_alt__3D_3D_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__inRange__3D_3D_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __inRange__3D_3D_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (int((_0).shape[0])!=int((_1).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of upper and lower bounds.")
   for _3 in range(0,int((_1).shape[0])):
    if (_0[_3] > _1[_3]):
     raise mosek_fusion_DomainError._ctor_S("Invalid range specified")
   if ((_2 is not None) and (mosek.fusion.Domain.__dimsize__3I(_2)!=int((_0).shape[0]))):
    raise mosek_fusion_LengthError._ctor_S("Mismatching dimensions.")
   return (mosek_fusion_RangeDomain._ctor__3D_3D_3I_3J(_0,_1,_2,None))
  @staticmethod
  def _match_symmetric_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_symmetric_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _symmetric_alt_Lmosek_4fusion_4RangeDomain_2(_t__0):
    return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4RangeDomain_2(_0)
  @staticmethod
  def _symmetric_Lmosek_4fusion_4RangeDomain_2(_0):
   return (_0._symmetric_())
  @staticmethod
  def _match_symmetric_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_symmetric_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _symmetric_alt_Lmosek_4fusion_4LinearDomain_2(_t__0):
    return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4LinearDomain_2(_0)
  @staticmethod
  def _symmetric_Lmosek_4fusion_4LinearDomain_2(_0):
   return (_0._symmetric_())
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4RangeDomain_2(_t__0):
    return mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2(_0)
  @staticmethod
  def _sparse_Lmosek_4fusion_4RangeDomain_2(_0):
   return (_0._sparse_())
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4LinearDomain_2(_t__0):
    return mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2(_0)
  @staticmethod
  def _sparse_Lmosek_4fusion_4LinearDomain_2(_0):
   return (_0._sparse_())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4RangeDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4RangeDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4RangeDomain_2(_0):
   return (_0._integral_())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4LinearDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4LinearDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4LinearDomain_2(_0):
   return (_0._integral_())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4QConeDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4QConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4QConeDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4QConeDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4QConeDomain_2(_0):
   return (_0._integral_())
  @staticmethod
  def _match_axis_Lmosek_4fusion_4QConeDomain_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4QConeDomain_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_axis_Lmosek_4fusion_4QConeDomain_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _axis_alt_Lmosek_4fusion_4QConeDomain_2I(_t__0,_t__1):
    return mosek_fusion_Domain._axis_Lmosek_4fusion_4QConeDomain_2I(_0,numpy.int32(__1))
  @staticmethod
  def _axis_Lmosek_4fusion_4QConeDomain_2I(_0,_1):
   return (_0._axis_I(_1))
  @staticmethod
  def _match_inRotatedQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inRotatedQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inRotatedQCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRotatedQCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRotatedQCone__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InRotatedQCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)),(int((_0).shape[0]) - 1)))
  @staticmethod
  def _match_inRotatedQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inRotatedQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inRotatedQCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inRotatedQCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inRotatedQCone_II(_0,_1):
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InRotatedQCone,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32)),1))
  @staticmethod
  def _match_inRotatedQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inRotatedQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inRotatedQCone_alt_I(_t__0):
    return mosek_fusion_Domain._inRotatedQCone_I(numpy.int32(__0))
  @staticmethod
  def _inRotatedQCone_I(_0):
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InRotatedQCone,numpy.array([_0], dtype=numpy.dtype(numpy.int32)),0))
  @staticmethod
  def _match_inRotatedQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inRotatedQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inRotatedQCone_alt_():
    return mosek_fusion_Domain._inRotatedQCone_()
  @staticmethod
  def _inRotatedQCone_():
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InRotatedQCone,None,0))
  @staticmethod
  def _match_inQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inQCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inQCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inQCone__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InQCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)),(int((_0).shape[0]) - 1)))
  @staticmethod
  def _match_inQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inQCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inQCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inQCone_II(_0,_1):
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InQCone,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32)),1))
  @staticmethod
  def _match_inQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inQCone_alt_I(_t__0):
    return mosek_fusion_Domain._inQCone_I(numpy.int32(__0))
  @staticmethod
  def _inQCone_I(_0):
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InQCone,numpy.array([_0], dtype=numpy.dtype(numpy.int32)),0))
  @staticmethod
  def _match_inQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inQCone_alt_():
    return mosek_fusion_Domain._inQCone_()
  @staticmethod
  def _inQCone_():
   return (mosek_fusion_QConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3II(mosek.fusion.QConeKey.InQCone,None,0))
  @staticmethod
  def _match_isLinPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_isLinPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _isLinPSD_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._isLinPSD_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _isLinPSD_II(_0,_1):
   return (mosek_fusion_LinPSDDomain._ctor_Lmosek_4fusion_4Set_2(mosek_fusion_NDSet._ctor_II(_1,((_0 * (_0 + 1)) // 2))))
  @staticmethod
  def _match_isLinPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_isLinPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _isLinPSD_alt_I(_t__0):
    return mosek_fusion_Domain._isLinPSD_I(numpy.int32(__0))
  @staticmethod
  def _isLinPSD_I(_0):
   return (mosek_fusion_LinPSDDomain._ctor_Lmosek_4fusion_4Set_2(mosek_fusion_IntSet._ctor_I(((_0 * (_0 + 1)) // 2))))
  @staticmethod
  def _match_isLinPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isLinPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _isLinPSD_alt_():
    return mosek_fusion_Domain._isLinPSD_()
  @staticmethod
  def _isLinPSD_():
   return (mosek_fusion_LinPSDDomain._ctor_())
  @staticmethod
  def _match_isTrilPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_isTrilPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _isTrilPSD_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._isTrilPSD_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _isTrilPSD_II(_0,_1):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(mosek.fusion.PSDKey.IsTrilPSD,mosek_fusion_NDSet._ctor_III(_1,_0,_0)))
  @staticmethod
  def _match_isTrilPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_isTrilPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _isTrilPSD_alt_I(_t__0):
    return mosek_fusion_Domain._isTrilPSD_I(numpy.int32(__0))
  @staticmethod
  def _isTrilPSD_I(_0):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(mosek.fusion.PSDKey.IsTrilPSD,mosek_fusion_NDSet._ctor_II(_0,_0)))
  @staticmethod
  def _match_isTrilPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isTrilPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _isTrilPSD_alt_():
    return mosek_fusion_Domain._isTrilPSD_()
  @staticmethod
  def _isTrilPSD_():
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2(mosek.fusion.PSDKey.IsTrilPSD))
  @staticmethod
  def _match_inPSDCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inPSDCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inPSDCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inPSDCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inPSDCone_II(_0,_1):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(mosek.fusion.PSDKey.IsSymPSD,mosek_fusion_NDSet._ctor_III(_1,_0,_0)))
  @staticmethod
  def _match_inPSDCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inPSDCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inPSDCone_alt_I(_t__0):
    return mosek_fusion_Domain._inPSDCone_I(numpy.int32(__0))
  @staticmethod
  def _inPSDCone_I(_0):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2Lmosek_4fusion_4Set_2(mosek.fusion.PSDKey.IsSymPSD,mosek_fusion_NDSet._ctor_II(_0,_0)))
  @staticmethod
  def _match_inPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inPSDCone_alt_():
    return mosek_fusion_Domain._inPSDCone_()
  @staticmethod
  def _inPSDCone_():
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2(mosek.fusion.PSDKey.IsSymPSD))
  @staticmethod
  def _match_binary_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_binary_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _binary_alt_():
    return mosek_fusion_Domain._binary_()
  @staticmethod
  def _binary_():
   return (mosek.fusion.Domain._inRange_DD(0.0,1.0)._integral_())
  @staticmethod
  def _match_binary__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_binary__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _binary_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._binary__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binary__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(numpy.array([0.0 for _1 in range(0,mosek.fusion.Domain.__dimsize__3I(_0))], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0 for _2 in range(0,mosek.fusion.Domain.__dimsize__3I(_0))], dtype=numpy.dtype(numpy.float64)),_0)._integral_())
  @staticmethod
  def _match_binary_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_binary_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _binary_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._binary_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _binary_II(_0,_1):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(numpy.array([0.0 for _2 in range(0,(_1 * _0))], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0 for _3 in range(0,(_1 * _0))], dtype=numpy.dtype(numpy.float64)),numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32)))._integral_())
  @staticmethod
  def _match_binary_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_binary_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _binary_alt_I(_t__0):
    return mosek_fusion_Domain._binary_I(numpy.int32(__0))
  @staticmethod
  def _binary_I(_0):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(numpy.array([0.0 for _1 in range(0,_0)], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0 for _2 in range(0,_0)], dtype=numpy.dtype(numpy.float64)),numpy.array([_0], dtype=numpy.dtype(numpy.int32)))._integral_())
  @staticmethod
  def _match_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _inRange_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(_0._getDataAsArray_(),_1._getDataAsArray_(),numpy.array([(_0._dimi),(_0._dimj)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_Lmosek_4fusion_4Matrix_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_inRange_Lmosek_4fusion_4Matrix_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _inRange_alt_Lmosek_4fusion_4Matrix_2D(_t__0,_t__1):
    return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2D(_0,numpy.float64(__1))
  @staticmethod
  def _inRange_Lmosek_4fusion_4Matrix_2D(_0,_1):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(_0._getDataAsArray_(),numpy.array([_1 for _2 in range(0,((_0._dimi) * (_0._dimj)))], dtype=numpy.dtype(numpy.float64)),numpy.array([(_0._dimi),(_0._dimj)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_DLmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_inRange_DLmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _inRange_alt_DLmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Domain._inRange_DLmosek_4fusion_4Matrix_2(numpy.float64(__0),_1)
  @staticmethod
  def _inRange_DLmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(numpy.array([_0 for _2 in range(0,((_1._dimi) * (_1._dimj)))], dtype=numpy.dtype(numpy.float64)),_1._getDataAsArray_(),numpy.array([(_1._dimi),(_1._dimj)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange__3D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_inRange__3D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _inRange_alt__3D_3D(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inRange__3D_3D(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3D_3D(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(_0,_1,numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange__3DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_inRange__3DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _inRange_alt__3DD(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.float64(_t__1)
   _1 = mosek_fusion_Domain._inRange__3DD(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3DD(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(_0,numpy.array([_1 for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_inRange_D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _inRange_alt_D_3D(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inRange_D_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange_D_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(numpy.array([_0 for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),_1,numpy.array([int((_1).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_inRange_DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _inRange_alt_DD(_t__0,_t__1):
    return mosek_fusion_Domain._inRange_DD(numpy.float64(__0),numpy.float64(__1))
  @staticmethod
  def _inRange_DD(_0,_1):
   return (mosek.fusion.Domain.__inRange__3D_3D_3I(numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _greaterThan_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._greaterThan_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _greaterThan_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.GreaterThan,_0))
  @staticmethod
  def _match_greaterThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_greaterThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _greaterThan_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._greaterThan__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan__3D_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D(mosek.fusion.RelationKey.GreaterThan,_0))
  @staticmethod
  def _match_greaterThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_greaterThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _greaterThan_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._greaterThan__3_5D(_0)
   return _1
  @staticmethod
  def _greaterThan__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3_5D(mosek.fusion.RelationKey.GreaterThan,_0))
  @staticmethod
  def _match_greaterThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_greaterThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _greaterThan_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._greaterThan__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D(mosek.fusion.RelationKey.GreaterThan,_0))
  @staticmethod
  def _match_greaterThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_greaterThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _greaterThan_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._greaterThan_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan_D_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.GreaterThan,_0,_1))
  @staticmethod
  def _match_greaterThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_greaterThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _greaterThan_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._greaterThan_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _greaterThan_DII(_0,_1,_2):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.GreaterThan,_0,numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_greaterThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _greaterThan_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._greaterThan_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _greaterThan_DI(_0,_1):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.GreaterThan,_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_greaterThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _greaterThan_alt_D(_t__0):
    return mosek_fusion_Domain._greaterThan_D(numpy.float64(__0))
  @staticmethod
  def _greaterThan_D(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D(mosek.fusion.RelationKey.GreaterThan,_0))
  @staticmethod
  def _match_lessThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_lessThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _lessThan_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._lessThan_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _lessThan_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.LessThan,_0))
  @staticmethod
  def _match_lessThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_lessThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _lessThan_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._lessThan__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan__3D_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D_3I(mosek.fusion.RelationKey.LessThan,_0,_1))
  @staticmethod
  def _match_lessThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_lessThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _lessThan_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._lessThan__3_5D(_0)
   return _1
  @staticmethod
  def _lessThan__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3_5D(mosek.fusion.RelationKey.LessThan,_0))
  @staticmethod
  def _match_lessThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_lessThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _lessThan_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._lessThan__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D(mosek.fusion.RelationKey.LessThan,_0))
  @staticmethod
  def _match_lessThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_lessThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _lessThan_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._lessThan_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan_D_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.LessThan,_0,_1))
  @staticmethod
  def _match_lessThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_lessThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _lessThan_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._lessThan_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _lessThan_DII(_0,_1,_2):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.LessThan,_0,numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_lessThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _lessThan_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._lessThan_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _lessThan_DI(_0,_1):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.LessThan,_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_lessThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _lessThan_alt_D(_t__0):
    return mosek_fusion_Domain._lessThan_D(numpy.float64(__0))
  @staticmethod
  def _lessThan_D(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D(mosek.fusion.RelationKey.LessThan,_0))
  @staticmethod
  def _match_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _equalsTo_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._equalsTo_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _equalsTo_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.EqualsTo,_0))
  @staticmethod
  def _match_equalsTo__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_equalsTo__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _equalsTo_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._equalsTo__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo__3D_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D_3I(mosek.fusion.RelationKey.EqualsTo,_0,_1))
  @staticmethod
  def _match_equalsTo__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_equalsTo__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _equalsTo_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._equalsTo__3_5D(_0)
   return _1
  @staticmethod
  def _equalsTo__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3_5D(mosek.fusion.RelationKey.EqualsTo,_0))
  @staticmethod
  def _match_equalsTo__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_equalsTo__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _equalsTo_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._equalsTo__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2_3D(mosek.fusion.RelationKey.EqualsTo,_0))
  @staticmethod
  def _match_equalsTo_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_equalsTo_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _equalsTo_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._equalsTo_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo_D_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.EqualsTo,_0,_1))
  @staticmethod
  def _match_equalsTo_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_equalsTo_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _equalsTo_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._equalsTo_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _equalsTo_DII(_0,_1,_2):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.EqualsTo,_0,numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_equalsTo_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _equalsTo_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._equalsTo_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _equalsTo_DI(_0,_1):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D_3I(mosek.fusion.RelationKey.EqualsTo,_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_equalsTo_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _equalsTo_alt_D(_t__0):
    return mosek_fusion_Domain._equalsTo_D(numpy.float64(__0))
  @staticmethod
  def _equalsTo_D(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2D(mosek.fusion.RelationKey.EqualsTo,_0))
  @staticmethod
  def _match_unbounded__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_unbounded__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _unbounded_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._unbounded__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _unbounded__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(mosek.fusion.RelationKey.IsFree,None,None,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_unbounded_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _unbounded_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._unbounded_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _unbounded_II(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(mosek.fusion.RelationKey.IsFree,None,None,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_unbounded_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _unbounded_alt_I(_t__0):
    return mosek_fusion_Domain._unbounded_I(numpy.int32(__0))
  @staticmethod
  def _unbounded_I(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(mosek.fusion.RelationKey.IsFree,None,None,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_unbounded_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _unbounded_alt_():
    return mosek_fusion_Domain._unbounded_()
  @staticmethod
  def _unbounded_():
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2_3D_3J_3I(mosek.fusion.RelationKey.IsFree,None,None,None))
 return Domain
mosek_fusion_Domain=__mk_mosek_fusion_Domain()
del __mk_mosek_fusion_Domain
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricExpr():
 class SymmetricExpr(object):
  __slots__ = ['_SymmetricExpr__xs','_SymmetricExpr__b','_SymmetricExpr__Ms','_SymmetricExpr__n']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricExpr._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SymmetricExpr._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricExpr.toString()')
  def __repr__(self): return 'mosek.fusion.SymmetricExpr'
  @staticmethod
  def _ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(n,Ms,xs,b):
    o = SymmetricExpr.__new__(SymmetricExpr)
    o._ctor_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(n,Ms,xs,b)
    return o
  @staticmethod
  def __match_ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 4: return False
    n,Ms,xs,b, = args
    return (__arg_match_I__(n) and __arg_match__3Lmosek_4fusion_4SymmetricMatrix_2__(Ms) and __arg_match__3Lmosek_4fusion_4Variable_2__(xs) and __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(b))
  @staticmethod
  def __match_alt_ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 4: return False
    n,Ms,xs,b, = args
    return (__arg_alt_match_I__(n) and __arg_alt_match__3Lmosek_4fusion_4SymmetricMatrix_2__(Ms) and __arg_alt_match__3Lmosek_4fusion_4Variable_2__(xs) and __arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(b))
  def _ctor_alt_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(self,n,Ms,xs,b):
    self._ctor_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(numpy.int32(n),numpy.array(Ms,dtype=numpy.dtype(object)),numpy.array(xs,dtype=numpy.dtype(object)),b)
  def _ctor_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(self,n,Ms,xs,b):
   assert Ms is None or isinstance(Ms,numpy.ndarray)
   assert xs is None or isinstance(xs,numpy.ndarray)
   object.__init__(self)
   (self.__n) = n
   (self.__Ms) = Ms
   (self.__xs) = xs
   (self.__b) = b
  @staticmethod
  def _add_alt_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricMatrix_2(_t__0,_t__1):
    return mosek_fusion_SymmetricExpr._add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricMatrix_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricMatrix_2(_0,_1):
   if ((_0.__n)!=_1._getdim_()):
    raise mosek_fusion_DimensionError._ctor_S("Dimension does not match")
   return (mosek_fusion_SymmetricExpr._ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2((_0.__n),(_0.__Ms),(_0.__xs),((_0.__b)._add_Lmosek_4fusion_4SymmetricMatrix_2(_1) if (((_0.__b) is not None) ) else _1)))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4SymmetricExpr_2D(_t__0,_t__1):
    return mosek_fusion_SymmetricExpr._mul_Lmosek_4fusion_4SymmetricExpr_2D(_0,numpy.float64(__1))
  @staticmethod
  def _mul_Lmosek_4fusion_4SymmetricExpr_2D(_0,_1):
   return (mosek_fusion_SymmetricExpr._ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2((_0.__n),numpy.array([(_0.__Ms)[_2]._mul_D(_1) for _2 in range(0,int(((_0.__Ms)).shape[0]))], dtype=numpy.dtype(object)),(_0.__xs),((_0.__b)._mul_D(_1) if (((_0.__b) is not None) ) else None)))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricExpr_2(_t__0,_t__1):
    return mosek_fusion_SymmetricExpr._add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricExpr_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricExpr_2(_0,_1):
   if ((_0.__n)!=(_1.__n)):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
   _2=numpy.zeros(((int(((_0.__Ms)).shape[0]) + int(((_1.__Ms)).shape[0])),), dtype=numpy.dtype(object))
   _3=numpy.zeros(((int(((_0.__xs)).shape[0]) + int(((_1.__xs)).shape[0])),), dtype=numpy.dtype(object))
   _4=int(((_0.__Ms)).shape[0])
   for _5 in range(0,int(((_0.__Ms)).shape[0])):
    _2[_5] = (_0.__Ms)[_5]
   for _6 in range(0,int(((_1.__Ms)).shape[0])):
    _2[(_6 + _4)] = (_1.__Ms)[_6]
   _7=int(((_0.__xs)).shape[0])
   for _8 in range(0,int(((_0.__xs)).shape[0])):
    _3[_8] = (_0.__xs)[_8]
   for _9 in range(0,int(((_1.__xs)).shape[0])):
    _3[(_9 + _7)] = (_1.__xs)[_9]
   _10=(None if ((((_0.__b) is None) and ((_1.__b) is None)) ) else ((_0.__b)._add_Lmosek_4fusion_4SymmetricMatrix_2((_1.__b)) if ((((_0.__b) is not None) and ((_1.__b) is not None)) ) else ((_0.__b) if (((_0.__b) is not None) ) else (_1.__b))))
   return (mosek_fusion_SymmetricExpr._ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2((_0.__n),_2,_3,_10))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SymmetricExpr( (")._a_I(self.__n)._a_S(",")._a_I(self.__n)._a_S(") )")
   return (_0._toString_())
 return SymmetricExpr
mosek_fusion_SymmetricExpr=__mk_mosek_fusion_SymmetricExpr()
del __mk_mosek_fusion_SymmetricExpr
#BEFORE CLASS
def __mk_mosek_fusion_Expr():
 class Expr(mosek_fusion_Expression,object):
  __slots__ = ['_Expr__varsb','_Expr__inst','_Expr__cof_v','_Expr__x','_Expr__subj','_Expr__ptrb','_Expr__bfix','_Expr__shape_p','_Expr__model']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(*args): # []int64,[]mosek.fusion.Variable,[]int64,[]double,[]double,mosek.fusion.Set,[]int64
      self._ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(*args)
    elif self.__match_alt_ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(*args):# []int64,[]mosek.fusion.Variable,[]int64,[]double,[]double,mosek.fusion.Set,[]int64
      self._ctor_alt_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Expr.ctor(array(int64,ndim=1),array(mosek.fusion.Variable,ndim=1),array(int64,ndim=1),array(double,ndim=1),array(double,ndim=1),mosek.fusion.Set,array(int64,ndim=1))')
  @staticmethod
  def zeros(*args):
    if False: pass
    elif mosek_fusion_Expr._match_zeros_I(*args): # int32
      return mosek_fusion_Expr._zeros_I(*args)
    elif mosek_fusion_Expr._match_alt_zeros_I(*args): # int32
      return mosek_fusion_Expr._zeros_alt_I(*args)
    else:
      raise ValueError('Invalid argument list zeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.zeros(int32)')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_vstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._vstack__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Variable_2D(*args): # double,mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Variable_2D(*args): # double,mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_vstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Expression,mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Expression,mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DDD(*args): # double,double,double
      return mosek_fusion_Expr._vstack_DDD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDD(*args): # double,double,double
      return mosek_fusion_Expr._vstack_alt_DDD(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Variable,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Variable,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,mosek.fusion.Variable,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Variable_2DD(*args): # mosek.fusion.Variable,double,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2DD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Variable_2DD(*args): # mosek.fusion.Variable,double,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Variable_2DD(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_DDLmosek_4fusion_4Variable_2(*args): # double,double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDLmosek_4fusion_4Variable_2(*args): # double,double,mosek.fusion.Variable
      return mosek_fusion_Expr._vstack_alt_DDLmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.vstack(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.vstack(double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,double,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Variable,double,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(double,double,mosek.fusion.Variable)')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Expr._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.getShape()')
  @staticmethod
  def add(*args):
    if False: pass
    elif mosek_fusion_Expr._match_add__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._add__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Expr._add__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._add__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._add__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._add_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.add(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.add(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.NDSparseArray,mosek.fusion.Variable)\n\tmosek.fusion.Expr.add(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.add(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.add(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.add(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.add(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Variable)')
  @staticmethod
  def neg(*args):
    if False: pass
    elif mosek_fusion_Expr._match_neg_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._neg_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_neg_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._neg_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_neg_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Expr._neg_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_neg_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Expr._neg_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list neg('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.neg(mosek.fusion.Expression)\n\tmosek.fusion.Expr.neg(mosek.fusion.Variable)')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_stack__3_3Lmosek_4fusion_4Expression_2(*args): # [][]mosek.fusion.Expression
      return mosek_fusion_Expr._stack__3_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack__3_3Lmosek_4fusion_4Expression_2(*args): # [][]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt__3_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_I_3Lmosek_4fusion_4Expression_2(*args): # int32,[]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_I_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_I_3Lmosek_4fusion_4Expression_2(*args): # int32,[]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_I_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Variable_2(*args): # int32,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Variable_2(*args): # int32,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2D(*args): # int32,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2D(*args): # int32,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,double,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,double,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_IDDLmosek_4fusion_4Expression_2(*args): # int32,double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDDLmosek_4fusion_4Expression_2(*args): # int32,double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2D(*args): # int32,double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2D(*args): # int32,double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DD(*args): # int32,mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DD(*args): # int32,mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2DD(*args): # int32,mosek.fusion.Variable,double,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2DD(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2DD(*args): # int32,mosek.fusion.Variable,double,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2DD(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDDLmosek_4fusion_4Variable_2(*args): # int32,double,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDDLmosek_4fusion_4Variable_2(*args): # int32,double,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_IDDLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Variable_2D(*args): # int32,double,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Variable_2D(*args): # int32,double,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Variable,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Variable,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.stack(array(array(mosek.fusion.Expression,ndim=1),ndim=1))\n\tmosek.fusion.Expr.stack(int32,array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,double,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Variable,mosek.fusion.Expression,double)')
  @staticmethod
  def reshape(*args):
    if False: pass
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Expression,mosek.fusion.Set
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(*args): # mosek.fusion.Expression,mosek.fusion.Set
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(*args)
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,mosek.fusion.Set)\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,int32)\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,int32,int32)')
  @staticmethod
  def mulDiag(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    else:
      raise ValueError('Invalid argument list mulDiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,mosek.fusion.Matrix)')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_Expr._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.numNonzeros()')
  @staticmethod
  def repeat(*args):
    if False: pass
    elif mosek_fusion_Expr._match_repeat_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_repeat_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._repeat_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.repeat(mosek.fusion.Expression,int32,int32)')
  @staticmethod
  def dot(*args):
    if False: pass
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_dot__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._dot__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._dot_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_dot__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._dot_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_dot__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    else:
      raise ValueError('Invalid argument list dot('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.dot(mosek.fusion.Variable,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.dot(mosek.fusion.NDSparseArray,mosek.fusion.Variable)\n\tmosek.fusion.Expr.dot(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.dot(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.dot(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.dot(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.dot(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.dot(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=2))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_Expr._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.eval()')
  @staticmethod
  def sub(*args):
    if False: pass
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._sub__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sub__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sub__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list sub('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.sub(mosek.fusion.NDSparseArray,mosek.fusion.Variable)\n\tmosek.fusion.Expr.sub(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.sub(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.sub(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.sub(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.sub(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Variable)')
  @staticmethod
  def sum(*args):
    if False: pass
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list sum('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.sum(mosek.fusion.Variable)\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression)\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression,int32)\n\tmosek.fusion.Expr.sum(mosek.fusion.Variable,int32)\n\tmosek.fusion.Expr.sum(mosek.fusion.Variable,int32,int32)\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression,int32,int32)')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_Expr._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Expr._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_Expr._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.pick(array(int32,ndim=1))\n\tmosek.fusion.Expr.pick(array(int32,ndim=2))')
  def shape(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_shape_(*args): # 
      return self._shape_(*args)
    elif mosek_fusion_Expr._match_alt_shape_(*args): # 
      return self._shape_alt_(*args)
    else:
      raise ValueError('Invalid argument list shape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.shape()')
  @staticmethod
  def outer(*args):
    if False: pass
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_outer__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._outer__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_outer__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._outer_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_outer__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._outer__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_outer__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._outer_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    else:
      raise ValueError('Invalid argument list outer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.outer(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.outer(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.outer(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.outer(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.outer(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.outer(mosek.fusion.Expression,array(double,ndim=1))')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Expr._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.transpose()')
  @staticmethod
  def mul(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mul__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._mul__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mul_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mul_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_alt_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mul__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mul(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mul(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.mul(mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mul(double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mul(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mul(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,double)')
  @staticmethod
  def constTerm(*args):
    if False: pass
    elif mosek_fusion_Expr._match_constTerm__3D(*args): # []double
      return mosek_fusion_Expr._constTerm__3D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3D(*args): # []double
      return mosek_fusion_Expr._constTerm_alt__3D(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_constTerm__3_5D(*args): # [,]double
      return mosek_fusion_Expr._constTerm__3_5D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3_5D(*args): # [,]double
      return mosek_fusion_Expr._constTerm_alt__3_5D(*args)
    elif mosek_fusion_Expr._match_constTerm_D(*args): # double
      return mosek_fusion_Expr._constTerm_D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_D(*args): # double
      return mosek_fusion_Expr._constTerm_alt_D(*args)
    elif mosek_fusion_Expr._match_constTerm_ID(*args): # int32,double
      return mosek_fusion_Expr._constTerm_ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_ID(*args): # int32,double
      return mosek_fusion_Expr._constTerm_alt_ID(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4Set_2D(*args): # mosek.fusion.Set,double
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Set_2D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4Set_2D(*args): # mosek.fusion.Set,double
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4Set_2D(*args)
    else:
      raise ValueError('Invalid argument list constTerm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.constTerm(array(double,ndim=1))\n\tmosek.fusion.Expr.constTerm(mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.constTerm(mosek.fusion.Matrix)\n\tmosek.fusion.Expr.constTerm(array(double,ndim=2))\n\tmosek.fusion.Expr.constTerm(double)\n\tmosek.fusion.Expr.constTerm(int32,double)\n\tmosek.fusion.Expr.constTerm(mosek.fusion.Set,double)')
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_hstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._hstack__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Variable_2D(*args): # double,mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Variable_2D(*args): # double,mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_hstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Expression,mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Expression,mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # double,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Variable,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Variable,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,mosek.fusion.Variable,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Variable_2DD(*args): # mosek.fusion.Variable,double,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2DD(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Variable_2DD(*args): # mosek.fusion.Variable,double,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Variable_2DD(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_DDLmosek_4fusion_4Variable_2(*args): # double,double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DDLmosek_4fusion_4Variable_2(*args): # double,double,mosek.fusion.Variable
      return mosek_fusion_Expr._hstack_alt_DDLmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.hstack(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.hstack(double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Variable,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Variable,double,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(double,double,mosek.fusion.Variable)')
  @staticmethod
  def mulElm(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Variable,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulElm__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulElm__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulElm_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulElm__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    else:
      raise ValueError('Invalid argument list mulElm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Variable,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.mulElm(mosek.fusion.NDSparseArray,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulElm(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulElm(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulElm(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=2))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Expr._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.toString()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Expr._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Expr._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Expr._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.index(int32)\n\tmosek.fusion.Expr.index(array(int32,ndim=1))')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Expr._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.getModel()')
  @staticmethod
  def flatten(*args):
    if False: pass
    elif mosek_fusion_Expr._match_flatten_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._flatten_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_flatten_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._flatten_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list flatten('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.flatten(mosek.fusion.Expression)')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_Expr._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.size()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Expr._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Expr._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Expr._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.slice(int32,int32)\n\tmosek.fusion.Expr.slice(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def ones(*args):
    if False: pass
    elif mosek_fusion_Expr._match_ones_I(*args): # int32
      return mosek_fusion_Expr._ones_I(*args)
    elif mosek_fusion_Expr._match_alt_ones_I(*args): # int32
      return mosek_fusion_Expr._ones_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ones('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.ones(int32)')
  def __repr__(self): return 'mosek.fusion.Expr'
  @staticmethod
  def _ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(ptrb_,v,subj_,cof_,bfix_,shp,inst_):
    o = Expr.__new__(Expr)
    o._ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(ptrb_,v,subj_,cof_,bfix_,shp,inst_)
    return o
  @staticmethod
  def __match_ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(*args):
    if len(args) != 7: return False
    ptrb_,v,subj_,cof_,bfix_,shp,inst_, = args
    return (__arg_match__3J__(ptrb_) and __arg_match__3Lmosek_4fusion_4Variable_2__(v) and __arg_match__3J__(subj_) and __arg_match__3D__(cof_) and __arg_match__3D__(bfix_) and __arg_match_Lmosek_4fusion_4Set_2__(shp) and __arg_match__3J__(inst_))
  @staticmethod
  def __match_alt_ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(*args):
    if len(args) != 7: return False
    ptrb_,v,subj_,cof_,bfix_,shp,inst_, = args
    return (__arg_alt_match__3J__(ptrb_) and __arg_alt_match__3Lmosek_4fusion_4Variable_2__(v) and __arg_alt_match__3J__(subj_) and __arg_alt_match__3D__(cof_) and __arg_alt_match__3D__(bfix_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shp) and __arg_alt_match__3J__(inst_))
  def _ctor_alt_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(self,ptrb_,v,subj_,cof_,bfix_,shp,inst_):
    self._ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(v,dtype=numpy.dtype(object)),numpy.array(subj_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),shp,numpy.array(inst_,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(self,ptrb_,v,subj_,cof_,bfix_,shp,inst_):
   assert ptrb_ is None or isinstance(ptrb_,numpy.ndarray)
   assert v is None or isinstance(v,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   assert bfix_ is None or isinstance(bfix_,numpy.ndarray)
   assert inst_ is None or isinstance(inst_,numpy.ndarray)
   object.__init__(self)
   self.__model = mosek.fusion.Expr.__extractModel__3Lmosek_4fusion_4Variable_2(v)
   self.__shape_p = shp
   self.__x = v
   self.__varsb = numpy.zeros(((int((self.__x).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
   for _0 in range(0,int((self.__x).shape[0])):
    self.__varsb[(_0 + 1)] = (self.__varsb[_0] + (self.__x[_0]._shape_()._size))
   _1=(int((ptrb_).shape[0]) - 1)
   _2=ptrb_[(int((ptrb_).shape[0]) - 1)]
   mosek.fusion.Expr.__validateData__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(ptrb_,v,subj_,cof_,bfix_,self.__shape_p,inst_)
   if (inst_ is not None):
    self.__inst = mosek.fusion.Utils.Tools._arraycopy__3J(inst_)
   else:
    self.__inst = None
   self.__shape_p = (mosek.fusion.Set._make_I((int((ptrb_).shape[0]) - 1)) if ((shp is None) ) else shp)
   self.__subj = numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   self.__cof_v = numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   self.__ptrb = numpy.zeros((int((ptrb_).shape[0]),), dtype=numpy.dtype(numpy.int64))
   self.__bfix = (None if ((bfix_ is None) ) else numpy.zeros((int((bfix_).shape[0]),), dtype=numpy.dtype(numpy.float64)))
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(ptrb_,0,self.__ptrb,0,int((self.__ptrb).shape[0]))
   mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(subj_,0,self.__subj,0,_2)
   mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(cof_,0,self.__cof_v,0,_2)
   if (self.__bfix is not None):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(bfix_,0,self.__bfix,0,int((self.__bfix).shape[0]))
  @staticmethod
  def _ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(ptrb_,v,subj_,cof_,bfix_,shp,inst_,unchecked_):
    o = Expr.__new__(Expr)
    o._ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(ptrb_,v,subj_,cof_,bfix_,shp,inst_,unchecked_)
    return o
  @staticmethod
  def __match_ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(*args):
    if len(args) != 8: return False
    ptrb_,v,subj_,cof_,bfix_,shp,inst_,unchecked_, = args
    return (__arg_match__3J__(ptrb_) and __arg_match__3Lmosek_4fusion_4Variable_2__(v) and __arg_match__3J__(subj_) and __arg_match__3D__(cof_) and __arg_match__3D__(bfix_) and __arg_match_Lmosek_4fusion_4Set_2__(shp) and __arg_match__3J__(inst_) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(*args):
    if len(args) != 8: return False
    ptrb_,v,subj_,cof_,bfix_,shp,inst_,unchecked_, = args
    return (__arg_alt_match__3J__(ptrb_) and __arg_alt_match__3Lmosek_4fusion_4Variable_2__(v) and __arg_alt_match__3J__(subj_) and __arg_alt_match__3D__(cof_) and __arg_alt_match__3D__(bfix_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shp) and __arg_alt_match__3J__(inst_) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(self,ptrb_,v,subj_,cof_,bfix_,shp,inst_,unchecked_):
    self._ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(v,dtype=numpy.dtype(object)),numpy.array(subj_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),shp,numpy.array(inst_,dtype=numpy.dtype(numpy.int64)),numpy.int32(unchecked_))
  def _ctor_init__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(self,ptrb_,v,subj_,cof_,bfix_,shp,inst_,unchecked_):
   assert ptrb_ is None or isinstance(ptrb_,numpy.ndarray)
   assert v is None or isinstance(v,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   assert bfix_ is None or isinstance(bfix_,numpy.ndarray)
   assert inst_ is None or isinstance(inst_,numpy.ndarray)
   object.__init__(self)
   self.__model = mosek.fusion.Expr.__extractModel__3Lmosek_4fusion_4Variable_2(v)
   (self.__shape_p) = shp
   self.__x = v
   self.__ptrb = ptrb_
   self.__subj = subj_
   self.__cof_v = cof_
   if (int((self.__subj).shape[0])!=int((self.__cof_v).shape[0])):
    raise mosek_fusion_SparseFormatError._ctor_S("Mismatching subj and cof")
   self.__varsb = numpy.zeros(((int((self.__x).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
   for _0 in range(0,int((self.__x).shape[0])):
    self.__varsb[(_0 + 1)] = (self.__varsb[_0] + (self.__x[_0]._shape_()._size))
   self.__bfix = bfix_
   self.__shape_p = (mosek_fusion_IntSet._ctor_I((int((ptrb_).shape[0]) - 1)) if ((shp is None) ) else shp)
   self.__inst = inst_
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(e):
    o = Expr.__new__(Expr)
    o._ctor_init_Lmosek_4fusion_4Expression_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,e):
    self._ctor_init_Lmosek_4fusion_4Expression_2(e)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,e):
   object.__init__(self)
   _1=e
   if   isinstance(_1,mosek_fusion_Expr):
    ee=_1
    self.__model = (ee.__model)
    self.__shape_p = (ee.__shape_p)
    self.__ptrb = (ee.__ptrb)
    self.__subj = (ee.__subj)
    self.__x = (ee.__x)
    self.__cof_v = (ee.__cof_v)
    self.__bfix = (ee.__bfix)
    self.__varsb = (ee.__varsb)
    self.__inst = (ee.__inst)
   else:
    ee=_1
    _1=ee._eval_()
    self.__model = e._getModel_()
    self.__shape_p = (_1.shape)
    self.__ptrb = (_1.ptrb)
    self.__subj = (_1.subj)
    self.__x = (_1.x)
    self.__cof_v = (_1.cof)
    self.__bfix = (_1.bfix)
    self.__varsb = numpy.zeros(((int((self.__x).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
    for _2 in range(0,int((self.__x).shape[0])):
     self.__varsb[(_2 + 1)] = (self.__varsb[_2] + (self.__x[_2]._shape_()._size))
    self.__inst = (_1.inst)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("Expr(ndim=(")._a_I(self.__shape_p._dim_I(0))
   for _1 in range(1,(self.__shape_p.nd)):
    _0._a_S(",")._a_I(self.__shape_p._dim_I(_1))
   _0._a_S("),\n     [ ")
   if (int((self.__ptrb).shape[0]) > 1):
    if (self.__inst is None):
     self.__tostr_Lmosek_4fusion_4Utils_4StringBuffer_2I(_0,0)
     for _2 in range(1,(int((self.__ptrb).shape[0]) - 1)):
      _0._a_S(",\n       ")
      self.__tostr_Lmosek_4fusion_4Utils_4StringBuffer_2I(_0,_2)
    else:
     if (int((self.__inst).shape[0]) > 0):
      _0._a_S("(")._a__3I(self.__shape_p._idxtokey_J(self.__inst[0]))._a_S(") -> ")
      self.__tostr_Lmosek_4fusion_4Utils_4StringBuffer_2I(_0,0)
      for _3 in range(1,(int((self.__ptrb).shape[0]) - 1)):
       _0._a_S(",\n       (")._a__3I(self.__shape_p._idxtokey_J(self.__inst[_3]))._a_S(") -> ")
       self.__tostr_Lmosek_4fusion_4Utils_4StringBuffer_2I(_0,_3)
   _0._a_S(" ])")
   return (_0._toString_())
  def __tostr_alt_Lmosek_4fusion_4Utils_4StringBuffer_2I(self,_t__0,_t__1):
    return self.__tostr_Lmosek_4fusion_4Utils_4StringBuffer_2I(_0,numpy.int32(__1))
  def __tostr_Lmosek_4fusion_4Utils_4StringBuffer_2I(self,_0,_1):
   for _2 in range(self.__ptrb[_1],self.__ptrb[(_1 + 1)]):
    _3=self.__subj[_2]
    _4=self.__cof_v[_2]
    if (_4 < 0):
     _5=0
     _5 = fragments._c_closure_221(_3,_5,self.__varsb) # src/fusion/Expr.mbi:5848:13-43
     _5 = numpy.int32(_5) # postprocess
     if ((_4 < (- 1.0)) or (_4 > (- 1.0))):
      _0._a_S(" - ")._a_D((- _4))._a_S(" ")
     else:
      _0._a_S(" - ")._a_S(" ")
     self.__x[_5]._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2((_3 - self.__varsb[_5]),_0)
    else:
     _6=0
     _6 = fragments._c_closure_222(_3,_6,self.__varsb) # src/fusion/Expr.mbi:5859:13-43
     _6 = numpy.int32(_6) # postprocess
     if ((_4 < 1.0) or (_4 > 1.0)):
      _0._a_S(" + ")._a_D(_4)._a_S(" ")
     else:
      _0._a_S(" + ")._a_S(" ")
     self.__x[_6]._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2((_3 - self.__varsb[_6]),_0)
   if (self.__bfix is not None):
    if (self.__bfix[_1] < 0.0):
     _0._a_S(" - ")._a_D((- self.__bfix[_1]))
    else:
     _0._a_S(" + ")._a_D(self.__bfix[_1])
  @staticmethod
  def __varstack_alt__3_3Lmosek_4fusion_4Variable_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Expr.__varstack__3_3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __varstack__3_3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (numpy.array([_0[_1][_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0[_1]).shape[0]))], dtype=numpy.dtype(object)))
  @staticmethod
  def __varstack_alt__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr.__varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (_0 is None):
    return (_1)
   elif (_1 is None):
    return (_0)
   else:
    _2=numpy.zeros(((int((_0).shape[0]) + int((_1).shape[0])),), dtype=numpy.dtype(object))
    for _3 in range(0,int((_0).shape[0])):
     _2[_3] = _0[_3]
    for _4 in range(0,int((_1).shape[0])):
     _2[(_4 + int((_0).shape[0]))] = _1[_4]
    return (_2)
  @staticmethod
  def _match_flatten_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_flatten_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _flatten_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._flatten_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _flatten_Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None):
    raise ValueError("Arguments for flatten may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2I(_0,numpy.int32((_0._shape_()._size))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   if (_0 is None):
    raise ValueError("Arguments for reshape may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,mosek_fusion_NDSet._ctor_II(_1,_2)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2I(_0,numpy.int32(__1))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2I(_0,_1):
   if (_0 is None):
    raise ValueError("Arguments for reshape may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,mosek_fusion_IntSet._ctor_I(_1)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Set_2__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Set_2__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_t__0,_t__1):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,_1)
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for reshape may not be null")
   if ((_1._size)!=(_0._shape_()._size)):
    raise mosek_fusion_DimensionError._ctor_S("New shape has wrong number of elements")
   _3=_0
   if   isinstance(_3,mosek_fusion_Expr):
    e_=_3
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI((e_.__ptrb),(e_.__x),(e_.__subj),(e_.__cof_v),(e_.__bfix),_1,(e_.__inst),1))
   else:
    e_=_3
    _3=_0._eval_()
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI((_3.ptrb),(_3.x),(_3.subj),(_3.cof),(_3.bfix),_1,(_3.inst),1))
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int64((int((self.__ptrb).shape[0]) - 1))
  @staticmethod
  def _match_eval_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_eval_(*args):
    if len(args) != 0: return False
    return True
  def _eval_alt_(self,):
    return self._eval_()
  def _eval_(self,):
   _0=(None if ((self.__bfix is None) ) else mosek.fusion.Utils.Tools._arraycopy__3D(self.__bfix))
   _1=(None if ((self.__inst is None) ) else mosek.fusion.Utils.Tools._arraycopy__3J(self.__inst))
   return (mosek_fusion_FlatExpr._ctor__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(_0,mosek.fusion.Utils.Tools._arraycopy__3J(self.__ptrb),mosek.fusion.Utils.Tools._arraycopy__3J(self.__subj),self.__x,mosek.fusion.Utils.Tools._arraycopy__3D(self.__cof_v),self.__shape_p,self.__inst))
  @staticmethod
  def _match_zeros_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_zeros_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _zeros_alt_I(_t__0):
    return mosek_fusion_Expr._zeros_I(numpy.int32(__0))
  @staticmethod
  def _zeros_I(_0):
   _1=mosek.fusion.Utils.Tools._makevector_JI(0,(1 + _0))
   _2=numpy.zeros((0,), dtype=numpy.dtype(object))
   _3=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _5=mosek.fusion.Utils.Tools._zeros_I(_0)
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_1,_2,_3,_4,_5,None,None,1))
  @staticmethod
  def _match_ones_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ones_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _ones_alt_I(_t__0):
    return mosek_fusion_Expr._ones_I(numpy.int32(__0))
  @staticmethod
  def _ones_I(_0):
   _1=mosek.fusion.Utils.Tools._makevector_JI(0,(1 + _0))
   _2=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _3=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _4=mosek.fusion.Utils.Tools._ones_I(_0)
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_1,numpy.zeros((0,), dtype=numpy.dtype(object)),_2,_3,_4,None,None,1))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4NDSparseArray_2(_t__0):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0)
  @staticmethod
  def _constTerm_Lmosek_4fusion_4NDSparseArray_2(_0):
   _1=mosek.fusion.Set._make__3I((_0._dims))
   _2=numpy.zeros(((int(((_0._inst)).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
   _3=numpy.zeros((0,), dtype=numpy.dtype(object))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _5=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _6=mosek.fusion.Utils.Tools._arraycopy__3D((_0._cof))
   _7=mosek.fusion.Utils.Tools._arraycopy__3J((_0._inst))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_2,_3,_4,_5,_6,_1,_7))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _constTerm_Lmosek_4fusion_4Matrix_2(_0):
   _1=mosek.fusion.Set._make_II(_0._numRows_(),_0._numColumns_())
   _2=numpy.zeros(((_0._numNonzeros_() + 1),), dtype=numpy.dtype(numpy.int64))
   _3=numpy.zeros((0,), dtype=numpy.dtype(object))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _5=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _6=None
   _7=None
   if _0._isSparse_():
    _8=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _9=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _10=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _0._getDataAsTriplets__3I_3I_3D(_8,_9,_10)
    _6 = _10
    _7 = numpy.array([((numpy.int64(_8[_11]) * _0._numColumns_()) + _9[_11]) for _11 in range(0,_0._numNonzeros_())], dtype=numpy.dtype(numpy.int64))
   else:
    _6 = _0._getDataAsArray_()
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_2,_3,_4,_5,_6,_1,_7))
  @staticmethod
  def _match_constTerm_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_constTerm_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _constTerm_alt_D(_t__0):
    return mosek_fusion_Expr._constTerm_D(numpy.float64(__0))
  @staticmethod
  def _constTerm_D(_0):
   _1=numpy.array([0,0], dtype=numpy.dtype(numpy.int64))
   _2=numpy.zeros((0,), dtype=numpy.dtype(object))
   _3=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _5=numpy.array([_0], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_1,_2,_3,_4,_5,None,None,1))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4Set_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Set_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4Set_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Set_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4Set_2D(_t__0,_t__1):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Set_2D(_0,numpy.float64(__1))
  @staticmethod
  def _constTerm_Lmosek_4fusion_4Set_2D(_0,_1):
   _2=mosek.fusion.Utils.Tools._makevector_JI(0,(numpy.int32((_0._size)) + 1))
   _3=numpy.zeros((0,), dtype=numpy.dtype(object))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _5=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _6=mosek.fusion.Utils.Tools._makevector_DI(_1,numpy.int32((_0._size)))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_2,_3,_4,_5,_6,_0,None,1))
  @staticmethod
  def _match_constTerm_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_constTerm_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _constTerm_alt_ID(_t__0,_t__1):
    return mosek_fusion_Expr._constTerm_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _constTerm_ID(_0,_1):
   _2=mosek.fusion.Utils.Tools._makevector_JI(0,(_0 + 1))
   _3=numpy.zeros((0,), dtype=numpy.dtype(object))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _5=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _6=mosek.fusion.Utils.Tools._makevector_DI(_1,_0)
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_2,_3,_4,_5,_6,None,None,1))
  @staticmethod
  def _match_constTerm__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_constTerm__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _constTerm_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._constTerm__3_5D(_0)
   return _1
  @staticmethod
  def _constTerm__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None):
    raise ValueError("Arguments for constTerm may not be null")
   _1=(int((_0).shape[0]) * int((_0).shape[1]))
   _2=mosek.fusion.Utils.Tools._makevector_JI(0,(_1 + 1))
   _3=numpy.zeros((0,), dtype=numpy.dtype(object))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _5=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _6=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
   _7=0
   for _8 in range(0,int((_0).shape[0])):
    for _9 in range(0,int((_0).shape[1])):
     _6[_7] = _0[_8,_9]
     _7 += 1
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_2,_3,_4,_5,_6,mosek.fusion.Set._make_II(int((_0).shape[0]),int((_0).shape[1])),None,1))
  @staticmethod
  def _match_constTerm__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_constTerm__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _constTerm_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._constTerm__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None):
    raise ValueError("Arguments for constTerm may not be null")
   _1=mosek.fusion.Utils.Tools._makevector_JI(0,(int((_0).shape[0]) + 1))
   _2=numpy.zeros((0,), dtype=numpy.dtype(object))
   _3=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
   _5=mosek.fusion.Utils.Tools._arraycopy__3D(_0)
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_1,_2,_3,_4,_5,None,None,1))
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(int((self.__cof_v).shape[0]))
  @staticmethod
  def __sum_1expr_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr.__sum_1expr_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def __sum_1expr_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   if ((_1 < 0) or ((_2 <= _1) or ((_0._shape_().nd) < _2))):
    raise mosek_fusion_DimensionError._ctor_S("The sum-dimension is invalid or out of bounds")
   _3=_0._eval_()
   if (((_3.shape)._size)==0):
    _4=numpy.zeros(((((_3.shape).nd) - (_2 - _1)),), dtype=numpy.dtype(numpy.int32))
    _5=1
    _6=1
    _7=1
    for _8 in range(0,_1):
     _5 *= (_3.shape)._dim_I(_8)
     _4[_8] = (_3.shape)._dim_I(_8)
    for _9 in range(_1,_2):
     _6 *= (_3.shape)._dim_I(_9)
    for _10 in range(_2,((_3.shape).nd)):
     _7 *= (_3.shape)._dim_I(_10)
     _4[(_10 - _2)] = (_3.shape)._dim_I(_10)
    if ((_5==0) or (_7==0)):
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0], dtype=numpy.dtype(numpy.int64)),(_3.x),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),mosek.fusion.Set._make__3I(_4),None))
    else:
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0], dtype=numpy.dtype(numpy.int64)),(_3.x),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),mosek.fusion.Set._make__3I(_4),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))))
   else:
    _11=(_3.inst)
    if (_11 is None):
     _11 = mosek.fusion.Utils.Tools._range_JJ(0,(int(((_3.ptrb)).shape[0]) - 1))
    _12=numpy.zeros((int((_11).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _13=numpy.zeros((int((_11).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _14=1
    _15=1
    _16=1
    for _17 in range(0,_1):
     _14 *= (_3.shape)._dim_I(_17)
    for _18 in range(_1,_2):
     _15 *= (_3.shape)._dim_I(_18)
    for _19 in range(_2,((_3.shape).nd)):
     _16 *= (_3.shape)._dim_I(_19)
    fragments._c_closure_223(_15,_16,_11,_12,_13) # src/fusion/Expr.mbi:5512:13-5517:14
    _20=mosek.fusion.Utils.Tools._range_JJ(0,int((_11).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_20,_12,_13,0,int((_11).shape[0]))
    _21=1
    _21 = fragments._c_closure_224(_12,_21,_20) # src/fusion/Expr.mbi:5526:11-5527:59
    _21 = numpy.int64(_21) # postprocess
    _22=numpy.zeros(((_21 + 1),), dtype=numpy.dtype(numpy.int64))
    _23=numpy.zeros((int(((_3.subj)).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _24=numpy.zeros((int(((_3.cof)).shape[0]),), dtype=numpy.dtype(numpy.float64))
    _25=0
    for _26 in range(0,_21):
     _27=_25
     _28=_12[_20[_25]]
     _25 = fragments._c_closure_225(_25,_28,_12,_20) # src/fusion/Expr.mbi:5538:38-87
     _25 = numpy.int32(_25) # postprocess
     _22[(_26 + 1)] = _22[_26]
     for _29 in range(_27,_25):
      _30=((_3.ptrb)[(_20[_29] + 1)] - (_3.ptrb)[_20[_29]])
      mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_3.subj),(_3.ptrb)[_20[_29]],_23,_22[(_26 + 1)],_30)
      mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_3.cof),(_3.ptrb)[_20[_29]],_24,_22[(_26 + 1)],_30)
      _22[(_26 + 1)] = (_22[(_26 + 1)] + _30)
    _31=None
    if ((_3.bfix) is not None):
     _31 = numpy.zeros((_21,), dtype=numpy.dtype(numpy.float64))
     _32=0
     for _33 in range(0,_21):
      _34=_32
      _35=_12[_20[_32]]
      _32 = fragments._c_closure_226(_32,_35,_12,_20) # src/fusion/Expr.mbi:5559:38-87
      _32 = numpy.int32(_32) # postprocess
      for _36 in range(_34,_32):
       _31[_33] += (_3.bfix)[_20[_36]]
    _38=numpy.zeros(((((_3.shape).nd) - (_2 - _1)),), dtype=numpy.dtype(numpy.int32))
    _39=0
    for _40 in range(0,_1):
     _38[_39] = (_3.shape)._dim_I(_40)
     _39 += 1
    for _41 in range(_2,((_3.shape).nd)):
     _38[_39] = (_3.shape)._dim_I(_41)
     _39 += 1
    _37 = mosek_fusion_NDSet._ctor__3I(_38)
    _42=None
    if (_21 < (_37._size)):
     _42 = numpy.zeros((_21,), dtype=numpy.dtype(numpy.int64))
     _42[0] = _12[_20[0]]
     _43=0
     _43 = fragments._c_closure_227(_43,_12,_21,_20,_42) # src/fusion/Expr.mbi:5580:13-5584:14
     _43 = numpy.int32(_43) # postprocess
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_22,(_3.x),_23,_24,_31,_37,_42))
  @staticmethod
  def __sum_1var_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr.__sum_1var_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def __sum_1var_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   if ((_1 < 0) or ((_2 <= _1) or (_2 > (_0._shape_().nd)))):
    raise mosek_fusion_DimensionError._ctor_S("The sum-dimension is invalid or out of bounds")
   if ((_0._shape_()._size)==0):
    _3=((_0._shape_().nd) - (_2 - _1))
    if (_3 < 1):
     _3 = 1
    _4=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _5=1
    _6=1
    _7=1
    for _8 in range(0,_1):
     _5 *= _0._shape_()._dim_I(_8)
     _4[_8] = _0._shape_()._dim_I(_8)
    for _9 in range(_1,_2):
     _6 *= _0._shape_()._dim_I(_9)
    for _10 in range(_2,(_0._shape_().nd)):
     _7 *= _0._shape_()._dim_I(_10)
     _4[(_10 - _2)] = _0._shape_()._dim_I(_10)
    if ((_1==0) and ((_2==(_0._shape_().nd)) and (_6==0))):
     _4[0] = 1
    if ((_5==0) or (_7==0)):
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(object)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),mosek.fusion.Set._make__3I(_4),None))
    else:
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0,0], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(object)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make__3I(_4),None))
   else:
    _11=((_0._shape_().nd) - (_2 - _1))
    if (_11==0):
     _11 = 1
     _12 = mosek_fusion_IntSet._ctor_I(1)
    else:
     _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
     _14=0
     for _15 in range(0,_1):
      _13[_14] = _0._shape_()._dim_I(_15)
      _14 += 1
     for _16 in range(_2,(_0._shape_().nd)):
      _13[_14] = _0._shape_()._dim_I(_16)
      _14 += 1
     if (_11 > 1):
      _12 = mosek_fusion_NDSet._ctor__3I(_13)
     else:
      _12 = mosek_fusion_IntSet._ctor_I(_13[0])
    _17=1
    for _18 in range(_1,_2):
     _17 *= _0._shape_()._dim_I(_18)
    _19=(mosek.fusion.Utils.Tools._range_JJJ(0,((_0._shape_()._size) + 1),_17) if ((_17 > 0) ) else numpy.array([0], dtype=numpy.dtype(numpy.int64)))
    _20=mosek.fusion.Utils.Tools._ones_I(numpy.int32((_0._shape_()._size)))
    _21=None
    _22=1
    _23=1
    _24=1
    for _25 in range(0,_1):
     _22 *= _0._shape_()._dim_I(_25)
    for _26 in range(_1,_2):
     _23 *= _0._shape_()._dim_I(_26)
    for _27 in range(_2,(_0._shape_().nd)):
     _24 *= _0._shape_()._dim_I(_27)
    _28=numpy.array([((((_29 * _23) * _24) + (_31 * _24)) + _30) for _29 in range(0,_22) for _30 in range(0,_24) for _31 in range(0,_23)], dtype=numpy.dtype(numpy.int64))
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_19,numpy.array([_0], dtype=numpy.dtype(object)),_28,_20,_21,_12,None))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   return (mosek.fusion.Expr.__sum_1expr_Lmosek_4fusion_4Expression_2II(_0,_1,_2))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2I(_0,numpy.int32(__1))
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2I(_0,_1):
   if ((_1 < 0) or ((_0._shape_().nd) <= _1)):
    raise mosek_fusion_DimensionError._ctor_S("The sum-dimension is invalid or out of bounds")
   return (mosek.fusion.Expr.__sum_1expr_Lmosek_4fusion_4Expression_2II(_0,_1,(_1 + 1)))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _sum_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   return (mosek.fusion.Expr.__sum_1var_Lmosek_4fusion_4Variable_2II(_0,_1,_2))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _sum_Lmosek_4fusion_4Variable_2I(_0,_1):
   if (_0 is None):
    raise ValueError("Arguments for sum may not be null")
   return (mosek.fusion.Expr.__sum_1var_Lmosek_4fusion_4Variable_2II(_0,_1,(_1 + 1)))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _sum_Lmosek_4fusion_4Variable_2(_0):
   if (_0 is None):
    raise ValueError("Arguments for sum may not be null")
   return (mosek.fusion.Expr.__sum_1var_Lmosek_4fusion_4Variable_2II(_0,0,(_0._shape_().nd)))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None):
    raise ValueError("Arguments for neg may not be null")
   _1=_0._eval_()
   _2=numpy.array([0,int(((_1.cof)).shape[0])], dtype=numpy.dtype(numpy.int64))
   _3=mosek.fusion.Utils.Tools._arraycopy__3J((_1.subj))
   _4=mosek.fusion.Utils.Tools._arraycopy__3D((_1.cof))
   if ((_1.bfix) is not None):
    _6=0.0
    _7=0
    while (_7 < int(((_1.bfix)).shape[0])):
     _6 = (_6 + (_1.bfix)[_7])
     _7 += 1
    _5 = numpy.array([_6], dtype=numpy.dtype(numpy.float64))
   else:
    _5 = None
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_2,(_1.x),_3,_4,_5,None,None,1))
  @staticmethod
  def _match_neg_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_neg_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _neg_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Expr._neg_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _neg_Lmosek_4fusion_4Variable_2(_0):
   if (_0 is None):
    raise ValueError("Arguments for neg may not be null")
   _1=mosek.fusion.Utils.Tools._range_J(((_0._shape_()._size) + 1))
   _2=mosek.fusion.Utils.Tools._range_J((_0._shape_()._size))
   _3=numpy.array([(- 1.0) for _4 in range(0,(_0._shape_()._size))], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_1,numpy.array([_0], dtype=numpy.dtype(object)),_2,_3,None,_0._shape_(),None,1))
  @staticmethod
  def _match_neg_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_neg_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _neg_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._neg_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _neg_Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None):
    raise ValueError("Arguments for neg may not be null")
   _1=_0._eval_()
   _2=numpy.array([(- (_1.cof)[_3]) for _3 in range(0,int(((_1.cof)).shape[0]))], dtype=numpy.dtype(numpy.float64))
   _4=(None if (((_1.bfix) is None) ) else numpy.array([(- (_1.bfix)[_5]) for _5 in range(0,int(((_1.bfix)).shape[0]))], dtype=numpy.dtype(numpy.float64)))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI((_1.ptrb),(_1.x),(_1.subj),_2,_4,(_1.shape),(_1.inst),1))
  @staticmethod
  def __mul_1_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mul_1_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __mul_1_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   _2=_0
   _3=_1
   if ((_1._shape_().nd) > 2):
    raise mosek_fusion_DimensionError._ctor_S("Expression operand must have 1 or 2 dimensions")
   if (_1._shape_()._dim_I(0)!=(_2._dimj)):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _4=_1._eval_()
   _6=(_4.shape)._dim_I(0)
   _7=1
   _8=1
   if (((_4.shape).nd)==2):
    _7 = (_4.shape)._dim_I(1)
    _8 = 2
    _5 = mosek_fusion_NDSet._ctor_II((_2._dimi),_7)
   else:
    _5 = mosek_fusion_IntSet._ctor_I((_2._dimi))
   _11=_2
   if   isinstance(_11,mosek_fusion_DenseMatrix):
    m=_11
    if ((_4.inst) is None):
     _11=((m._dimi) * _7)
     _12=numpy.zeros(((_11 + 1),), dtype=numpy.dtype(numpy.int64))
     _13=numpy.zeros((((_4.nnz) * (m._dimi)),), dtype=numpy.dtype(numpy.int64))
     _14=numpy.zeros((((_4.nnz) * (m._dimi)),), dtype=numpy.dtype(numpy.float64))
     _15=(None if (((_4.bfix) is None) ) else numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64)))
     _16=1
     _17=0
     while (_17 < (m._dimi)):
      _18=0
      while (_18 < _7):
       _19=_12[(_16 - 1)]
       _20=0
       while (_20 < _6):
        _21=((_20 * _7) + _18)
        _22=((_4.ptrb)[(_21 + 1)] - (_4.ptrb)[_21])
        _23=(m._data)[((_17 * (m._dimj)) + _20)]
        _24=0
        while (_24 < _22):
         _14[(_19 + _24)] = ((_4.cof)[((_4.ptrb)[_21] + _24)] * _23)
         _13[(_19 + _24)] = (_4.subj)[((_4.ptrb)[_21] + _24)]
         _24 += 1
        _19 = (_19 + _22)
        if ((_4.bfix) is not None):
         _15[(_16 - 1)] = (_15[(_16 - 1)] + ((_4.bfix)[_21] * _23))
        _20 += 1
       _12[_16] = _19
       _16 += 1
       _18 += 1
      _17 += 1
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_12,(_4.x),_13,_14,_15,_5,None)
    else:
     _25=int(((_4.inst)).shape[0])
     _26=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int32))
     _27=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int32))
     _28=mosek.fusion.Utils.Tools._range_J(int(((_4.inst)).shape[0]))
     _29=0
     while (_29 < _25):
      _26[_29] = numpy.int32(((_4.inst)[_29] // _7))
      _27[_29] = numpy.int32(((_4.inst)[_29] - _26[_29]))
      _29 += 1
     mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_28,_27,_26,0,_25)
     _30=0
     _30 = fragments._c_closure_228(_27,_25,_30,_28) # src/fusion/Expr.mbi:5006:13-5010:14
     _30 = numpy.int32(_30) # postprocess
     _31=(_30 * (m._dimi))
     _32=numpy.zeros(((_31 + 1),), dtype=numpy.dtype(numpy.int64))
     _33=numpy.zeros((((_4.nnz) * (m._dimi)),), dtype=numpy.dtype(numpy.int64))
     _34=numpy.zeros((((_4.nnz) * (m._dimi)),), dtype=numpy.dtype(numpy.float64))
     _35=(None if (((_4.bfix) is None) ) else numpy.zeros((_31,), dtype=numpy.dtype(numpy.float64)))
     _36=(None if ((_30 >= _7) ) else numpy.zeros((_31,), dtype=numpy.dtype(numpy.int64)))
     _37=0
     _38=0
     while (_38 < (m._dimi)):
      _39=numpy.int64(((m._dimj) * _38))
      _40=0
      while (_40 < _25):
       if ((_40==0) or (_27[_28[_40]] > _27[_28[(_40 - 1)]])):
        _37 += 1
        _32[_37] = _32[(_37 - 1)]
        if (_36 is not None):
         _36[(_37 - 1)] = ((numpy.int64(_38) * _7) + _27[_28[_40]])
       _41=(_4.ptrb)[_28[_40]]
       _42=((_4.ptrb)[(_28[_40] + 1)] - _41)
       _43=(m._data)[(_39 + _26[_28[_40]])]
       _44=0
       while (_44 < _42):
        _33[(_32[_37] + _44)] = (_4.subj)[(_41 + _44)]
        _34[(_32[_37] + _44)] = ((_4.cof)[(_41 + _44)] * _43)
        _44 += 1
       if (_35 is not None):
        _35[(_37 - 1)] = (_35[(_37 - 1)] + ((_4.bfix)[_28[_40]] * _43))
       if (_36 is not None):
        _36[(_37 - 1)] = numpy.int64(_27[_28[_40]])
       _32[_37] = (_32[_37] + _42)
       _40 += 1
      _38 += 1
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_32,(_4.x),_33,_34,_35,_5,_36)
   else:
    m=_11
    _45=m._numNonzeros_()
    _46=numpy.zeros((_45,), dtype=numpy.dtype(numpy.int32))
    _47=numpy.zeros((_45,), dtype=numpy.dtype(numpy.int32))
    _48=numpy.zeros((_45,), dtype=numpy.dtype(numpy.float64))
    m._getDataAsTriplets__3I_3I_3D(_46,_47,_48)
    if ((_4.inst) is None):
     _49=1
     _49 = fragments._c_closure_229(_46,_49,_45) # src/fusion/Expr.mbi:5078:13-85
     _49 = numpy.int64(_49) # postprocess
     _50=(_49 * _7)
     _51=numpy.zeros(((_50 + 1),), dtype=numpy.dtype(numpy.int64))
     _52=0
     _53=_46[0]
     _54=0
     for _55 in range(0,_45):
      if (_53 < _46[_55]):
       _54 = (_54 + _7)
       _53 = _46[_55]
      for _56 in range(0,_7):
       _57=((_47[_55] * _7) + _56)
       _58=((_4.ptrb)[(_57 + 1)] - (_4.ptrb)[_57])
       _52 = (_52 + _58)
       _51[((_54 + _56) + 1)] = (_51[((_54 + _56) + 1)] + _58)
     _59=numpy.zeros((_52,), dtype=numpy.dtype(numpy.int64))
     _60=numpy.zeros((_52,), dtype=numpy.dtype(numpy.float64))
     _61=(None if (((_4.bfix) is None) ) else numpy.zeros((_50,), dtype=numpy.dtype(numpy.float64)))
     fragments._c_closure_230(_50,_51) # src/fusion/Expr.mbi:5109:13-85
     _62=(None if ((_49 >= (m._dimi)) ) else numpy.zeros((_50,), dtype=numpy.dtype(numpy.int64)))
     _63=0
     _64=_46[0]
     _65=0
     while (_65 < _45):
      _66=_48[_65]
      if (_64 < _46[_65]):
       _63 = (_63 + _7)
       _64 = _46[_65]
      _67=0
      while (_67 < _7):
       _68=((_47[_65] * _7) + _67)
       _69=((_4.ptrb)[(_68 + 1)] - (_4.ptrb)[_68])
       _70=0
       while (_70 < _69):
        _60[(_51[(_63 + _67)] + _70)] = ((_4.cof)[((_4.ptrb)[_68] + _70)] * _66)
        _59[(_51[(_63 + _67)] + _70)] = (_4.subj)[((_4.ptrb)[_68] + _70)]
        _70 += 1
       if (_61 is not None):
        _61[(_63 + _67)] = (_61[(_63 + _67)] + ((_4.bfix)[_68] * _66))
       _51[(_63 + _67)] = (_51[(_63 + _67)] + _69)
       if (_62 is not None):
        _62[(_63 + _67)] = numpy.int64(((_46[_65] * _7) + _67))
       _67 += 1
      _65 += 1
     fragments._c_closure_231(_51) # src/fusion/Expr.mbi:5157:13-5158:35
     _51[0] = 0
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_51,(_4.x),_59,_60,_61,_5,_62)
    else:
     _71=_2._numNonzeros_()
     _72=int(((_4.inst)).shape[0])
     _73=numpy.zeros((_72,), dtype=numpy.dtype(numpy.int32))
     _74=numpy.zeros((_72,), dtype=numpy.dtype(numpy.int32))
     _75=mosek.fusion.Utils.Tools._range_J(int(((_4.inst)).shape[0]))
     _76=0
     while (_76 < _72):
      _73[_76] = numpy.int32(((_4.inst)[_76] // _7))
      _74[_76] = numpy.int32(((_4.inst)[_76] - _73[_76]))
      _76 += 1
     mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_75,_74,_73,0,_72)
     _77=0
     _78=0
     _79=0
     while (_79 < _71):
      _80=_79
      _80 = fragments._c_closure_232(_71,_80,_79,_46) # src/fusion/Expr.mbi:5185:50-145
      _80 = numpy.int32(_80) # postprocess
      _81=_46[_79]
      _82=_74[_75[0]]
      _83=0
      while (_83 < _72):
       _84 = fragments._c_closure_233(_74,_72,_75,_84,_83) # src/fusion/Expr.mbi:5196:21-5199:23
       _84 = numpy.int32(_84) # postprocess
       _85=_79
       _86=_83
       _87=_78
       while ((_85 < _80) and (_86 < _84)):
        if (_47[_85] < _73[_75[_86]]):
         _85 += 1
        elif (_47[_85] > _73[_75[_86]]):
         _86 += 1
        else:
         _78 = (_78 + ((_4.ptrb)[(_75[_86] + 1)] - (_4.ptrb)[_75[_86]]))
         _86 += 1
         _85 += 1
       if (_87 < _78):
        _77 += 1
       _83 = _84
      _79 = _80
     _88=numpy.zeros(((_77 + 1),), dtype=numpy.dtype(numpy.int64))
     _89=numpy.zeros((_78,), dtype=numpy.dtype(numpy.int64))
     _90=numpy.zeros((_78,), dtype=numpy.dtype(numpy.float64))
     _91=numpy.zeros((_77,), dtype=numpy.dtype(numpy.int64))
     _92=(None if (((_4.bfix) is None) ) else numpy.zeros((_77,), dtype=numpy.dtype(numpy.float64)))
     _93=0
     _94=0
     _95=0
     _96=0
     while (_96 < _71):
      _97=_96
      _97 = fragments._c_closure_234(_71,_97,_96,_46) # src/fusion/Expr.mbi:5248:50-145
      _97 = numpy.int32(_97) # postprocess
      _98=_46[_96]
      _99=_74[_75[0]]
      _100=0
      while (_100 < _72):
       _101 = fragments._c_closure_235(_74,_72,_75,_101,_100) # src/fusion/Expr.mbi:5256:21-5259:23
       _101 = numpy.int32(_101) # postprocess
       _102=_96
       _103=_100
       _104=_94
       while ((_102 < _97) and (_103 < _101)):
        if (_47[_102] < _73[_75[_103]]):
         _102 += 1
        elif (_47[_102] > _73[_75[_103]]):
         _103 += 1
        else:
         _105=(_4.ptrb)[_75[_103]]
         _106=((_4.ptrb)[(_75[_103] + 1)] - _105)
         mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_4.subj),(_4.ptrb)[_75[_103]],_89,_94,_106)
         _107=0
         while (_107 < _106):
          _90[(_94 + _107)] = ((_4.cof)[(_105 + _107)] * _48[_102])
          _107 += 1
         if (_92 is not None):
          _92[_95] = (_92[_95] + ((_4.bfix)[_75[_103]] * _48[_102]))
         _94 = (_94 + _106)
         _103 += 1
         _102 += 1
       if (_104 < _94):
        _91[_95] = (numpy.int64((_46[_96] * _7)) + _74[_75[_100]])
        _95 += 1
        _88[_95] = _94
       _100 = _101
      _96 = _97
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_88,(_4.x),_89,_90,_92,_5,_91)
   return (_9)
  @staticmethod
  def __sparseMatrixVector_alt__3J_3I_3D_3D_3DI(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.int32(_t__5)
   _1 = mosek_fusion_Expr.__sparseMatrixVector__3J_3I_3D_3D_3DI(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __sparseMatrixVector__3J_3I_3D_3D_3DI(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   fragments._c_closure_236(_2,_0,_1,_3,_5,_4) # src/fusion/Expr.mbi:4886:7-4900:8
  @staticmethod
  def __sparseMatmul_alt__3J_3I_3D_3J_3I_3D_3J_3I_3DII_3I(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10,_t__11):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int64))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.float64))
   _9=numpy.int32(_t__9)
   _10=numpy.int32(_t__10)
   _11=numpy.array(_t__11,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr.__sparseMatmul__3J_3I_3D_3J_3I_3D_3J_3I_3DII_3I(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__11[:] = _11
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __sparseMatmul__3J_3I_3D_3J_3I_3D_3J_3I_3DII_3I(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   assert _8 is None or isinstance(_8,numpy.ndarray)
   assert _11 is None or isinstance(_11,numpy.ndarray)
   _12=0
   _13=0
   _14=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_237(_10,_11,_14) # src/fusion/Expr.mbi:4835:9-4839:10
   _15=0
   while (_15 < _9):
    _13 = _12
    _12 = fragments._c_closure_238(_5,_3,_15,_4,_8,_6,_7,_1,_11,_12,_13,_14) # src/fusion/Expr.mbi:4846:11-4867:12
    _12 = numpy.int32(_12) # postprocess
    mosek.fusion.Utils.Tools._sort__3III(_1,_13,_12)
    fragments._c_closure_239(_2,_1,_12,_13,_14) # src/fusion/Expr.mbi:4870:11-4874:12
    _15 += 1
  @staticmethod
  def __computeNz_alt__3J_3I_3J_3III_3I_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Expr.__computeNz__3J_3I_3J_3III_3I_3J(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeNz__3J_3I_3J_3III_3I_3J(_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   _8=0
   _9=0
   fragments._c_closure_240(_5,_6) # src/fusion/Expr.mbi:4784:10-4787:11
   _9,_8 = fragments._c_closure_241(_0,_1,_2,_3,_7,_6,_9,_8,_4) # src/fusion/Expr.mbi:4789:10-4809:11
   _9 = numpy.int32(_9) # postprocess
   _8 = numpy.int64(_8) # postprocess
   _7[_4] = _8
   return numpy.int64(_8)
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mulDiag may not be null")
   _2=_0
   _3=_1
   if (((_2._shape_().nd)!=2) or (((_3._dimj)!=_2._shape_()._dim_I(0)) or ((_3._dimi)!=_2._shape_()._dim_I(1)))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
   _4=numpy.int64((_3._dimj))
   _6=_3
   if   isinstance(_6,mosek_fusion_DenseMatrix):
    m=_6
    _6=(_4 * (m._dimi))
    _7=mosek.fusion.Utils.Tools._range_JJJ(0,(_4 * (1 + _4)),_4)
    _8=mosek.fusion.Utils.Tools._range_JJ(0,_6)
    _9=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
    _10=0
    _11=0
    while (_11 < (m._dimj)):
     _12=0
     while (_12 < (m._dimi)):
      _9[_10] = (m._data)[((_12 * _4) + _11)]
      _10 += 1
      _12 += 1
     _11 += 1
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_7,numpy.array([_0], dtype=numpy.dtype(object)),_8,_9,None,None,None,1))
   else:
    m=_6
    _13=m._numNonzeros_()
    _14=numpy.zeros(((_4 + 1),), dtype=numpy.dtype(numpy.int64))
    _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
    _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    _17=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _18=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _19=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    m._getDataAsTriplets__3I_3I_3D(_17,_18,_19)
    _20=0
    while (_20 < _13):
     _14[(_18[_20] + 1)] += 1
     _20 += 1
    fragments._c_closure_242(_4,_14) # src/fusion/Expr.mbi:4748:11-77
    _21=0
    while (_21 < _13):
     _22=_14[_18[_21]]
     _16[_22] = _19[_21]
     _15[_22] = numpy.int64(((_18[_21] * (m._dimi)) + _17[_21]))
     _14[_18[_21]] += 1
     _21 += 1
    fragments._c_closure_243(_4,_14) # src/fusion/Expr.mbi:4757:11-63
    _14[0] = 0
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_14,numpy.array([_0], dtype=numpy.dtype(object)),_15,_16,None,None,None,1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mulDiag may not be null")
   _2=_0
   _3=_1
   if (((_3._shape_().nd)!=2) or (((_2._dimj)!=_3._shape_()._dim_I(0)) or ((_2._dimi)!=_3._shape_()._dim_I(1)))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
   _5=_2
   if   isinstance(_5,mosek_fusion_DenseMatrix):
    m=_5
    _5=mosek.fusion.Utils.Tools._range_JJJ(0,numpy.int64(((m._dimj) * (1 + (m._dimi)))),numpy.int64((m._dimj)))
    _6=numpy.zeros((((m._dimi) * (m._dimj)),), dtype=numpy.dtype(numpy.int64))
    _7=numpy.array([(numpy.int64(_8) + ((m._dimi) * _9)) for _8 in range(0,(m._dimi)) for _9 in range(0,(m._dimj))], dtype=numpy.dtype(numpy.int64))
    _10=(m._data)
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_5,numpy.array([_1], dtype=numpy.dtype(object)),_7,_10,None,None,None,1))
   elif isinstance(_5,mosek_fusion_SparseMatrix):
    _11=_5
    _12=numpy.zeros((((_11._dimi) + 1),), dtype=numpy.dtype(numpy.int64))
    _13=numpy.array([numpy.int64((((_11._subj)[_14] * (_11._dimi)) + (_11._subi)[_14])) for _14 in range(0,(_11._nnz))], dtype=numpy.dtype(numpy.int64))
    _15=(_11._val)
    _16=(_11._nnz)
    for _17 in range(0,_16):
     _12[((_11._subi)[_17] + 1)] += 1
    for _18 in range(0,(_11._dimi)):
     _12[(_18 + 1)] = (_12[_18] + _12[(_18 + 1)])
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_12,numpy.array([_1], dtype=numpy.dtype(object)),_13,_15,None,None,None,1))
   else:
    m=_5
    raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type used.")
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mulDiag may not be null")
   _2=_0
   _3=_1
   _5=_2._eval_()
   if (((_5.shape).nd)!=2):
    raise mosek_fusion_DimensionError._ctor_S("Expression operand must have 2 dimensions")
   if (((_5.shape)._dim_I(0)!=(_3._dimj)) or ((_5.shape)._dim_I(1)!=(_3._dimi))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _6=(_5.shape)._dim_I(0)
   _7=(_5.shape)._dim_I(1)
   _9=_3
   if   isinstance(_9,mosek_fusion_DenseMatrix):
    m=_9
    if ((_5.inst) is None):
     _9=numpy.zeros(((_6 + 1),), dtype=numpy.dtype(numpy.int64))
     _10=numpy.zeros(((_5.nnz),), dtype=numpy.dtype(numpy.int64))
     _11=numpy.zeros(((_5.nnz),), dtype=numpy.dtype(numpy.float64))
     _12=(None if (((_5.bfix) is None) ) else numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64)))
     _13=None
     _14=None
     _15=0
     for _16 in range(0,_6):
      _9[(_16 + 1)] = _9[_16]
      for _17 in range(0,_7):
       _18=((_5.ptrb)[(_15 + 1)] - (_5.ptrb)[_15])
       _19=(m._data)[((_17 * _6) + _16)]
       mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_5.subj),(_5.ptrb)[_15],_10,_9[(_16 + 1)],_18)
       for _20 in range(0,_18):
        _11[(_9[(_16 + 1)] + _20)] = (_19 * (_5.cof)[((_5.ptrb)[_15] + _20)])
       if (_12 is not None):
        _12[_16] += (_19 * (_5.bfix)[_15])
       _9[(_16 + 1)] = (_9[(_16 + 1)] + _18)
       _15 += 1
     _4 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_9,(_5.x),_10,_11,_12,_14,_13)
    else:
     _21=0
     _22=(- 1)
     for _23 in range(0,int(((_5.inst)).shape[0])):
      _24=((_5.inst)[_23] // numpy.int64(_7))
      if (_22 < _24):
       _22 = _24
       _21 += 1
     _25=numpy.zeros(((_21 + 1),), dtype=numpy.dtype(numpy.int64))
     _26=numpy.zeros(((_5.nnz),), dtype=numpy.dtype(numpy.int64))
     _27=numpy.zeros(((_5.nnz),), dtype=numpy.dtype(numpy.float64))
     _28=(None if (((_5.bfix) is None) ) else numpy.zeros((_21,), dtype=numpy.dtype(numpy.float64)))
     _29=(None if ((_21 >= _6) ) else numpy.zeros((_21,), dtype=numpy.dtype(numpy.int64)))
     _30=mosek_fusion_IntSet._ctor_I(_6)
     _31=(- 1)
     _32=0
     _33=0
     while (_33 < int(((_5.inst)).shape[0])):
      _34=((_5.inst)[_33] // numpy.int64(_7))
      _35=((_5.inst)[_33] - (_34 * numpy.int64(_7)))
      if (_31 < _34):
       _31 = _34
       if (_29 is not None):
        _29[_32] = _34
       _32 += 1
       _25[_32] = _25[(_32 - 1)]
      _36=((_5.ptrb)[(_33 + 1)] - (_5.ptrb)[_33])
      mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_5.subj),(_5.ptrb)[_33],_26,_25[_32],_36)
      _37=(m._data)[((_35 * _6) + _34)]
      for _38 in range(0,_36):
       _27[(_25[_32] + _38)] = (_37 * (_5.cof)[((_5.ptrb)[_33] + _38)])
      if (_28 is not None):
       _28[(_32 - 1)] += (_37 * (_5.bfix)[_33])
      _25[_32] = (_25[_32] + _36)
      _33 += 1
     _4 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_25,(_5.x),_26,_27,_28,_30,_29)
   else:
    m=_9
    _39=m._numNonzeros_()
    _40=numpy.zeros((_39,), dtype=numpy.dtype(numpy.int32))
    _41=numpy.zeros((_39,), dtype=numpy.dtype(numpy.int32))
    _42=numpy.zeros((_39,), dtype=numpy.dtype(numpy.float64))
    _43=mosek.fusion.Utils.Tools._range_J(numpy.int64(_39))
    m._getDataAsTriplets__3I_3I_3D(_40,_41,_42)
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_43,_41,_40,0,_39)
    if ((_5.inst) is None):
     _44=0
     _45=0
     _46=(- 1)
     _47=0
     while (_47 < _39):
      if (_46 < _41[_43[_47]]):
       _44 += 1
       _46 = _41[_43[_47]]
      _48=((_41[_43[_47]] * (m._dimi)) + _40[_43[_47]])
      _45 = (_45 + ((_5.ptrb)[(_48 + 1)] - (_5.ptrb)[_48]))
      _47 += 1
     _49=numpy.zeros(((_44 + 1),), dtype=numpy.dtype(numpy.int64))
     _50=numpy.zeros((_45,), dtype=numpy.dtype(numpy.int64))
     _51=numpy.zeros((_45,), dtype=numpy.dtype(numpy.float64))
     _52=(None if (((_5.bfix) is None) ) else numpy.zeros((_44,), dtype=numpy.dtype(numpy.float64)))
     _53=(None if ((_44 >= (m._dimj)) ) else numpy.zeros((_44,), dtype=numpy.dtype(numpy.int64)))
     _54=mosek_fusion_IntSet._ctor_I((m._dimj))
     _55=(- 1)
     _56=0
     for _57 in range(0,_39):
      if (_55 < _41[_43[_57]]):
       _55 = _41[_43[_57]]
       if (_53 is not None):
        _53[_56] = _55
       _56 += 1
       _49[_56] = _49[(_56 - 1)]
      _58=((_41[_43[_57]] * (m._dimi)) + _40[_43[_57]])
      _59=((_5.ptrb)[(_58 + 1)] - (_5.ptrb)[_58])
      mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_5.subj),(_5.ptrb)[_58],_50,_49[_56],_59)
      for _60 in range(0,_59):
       _51[(_49[_56] + _60)] = ((_5.cof)[((_5.ptrb)[_58] + _60)] * _42[_43[_57]])
      if (_52 is not None):
       _52[_55] += ((_5.bfix)[_58] * _42[_43[_57]])
      _49[_56] = (_49[_56] + _59)
     _4 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_49,(_5.x),_50,_51,_52,_54,_53)
    else:
     _61=0
     _62=0
     _63=0
     _64=0
     _65=(- 1)
     while ((_63 < int(((_5.inst)).shape[0])) and (_64 < _39)):
      _66=((_5.inst)[_63] // _7)
      _67=((_5.inst)[_63] - (_66 * _7))
      if (_66 < _41[_43[_64]]):
       _63 += 1
      elif (_66 > _41[_43[_64]]):
       _64 += 1
      elif (_67 < _40[_43[_64]]):
       _63 += 1
      elif (_67 > _40[_43[_64]]):
       _64 += 1
      else:
       if (_65 < _66):
        _61 += 1
        _65 = _66
       _62 = (_62 + ((_5.ptrb)[(_63 + 1)] - (_5.ptrb)[_63]))
       _63 += 1
       _64 += 1
     _68=numpy.zeros(((_61 + 1),), dtype=numpy.dtype(numpy.int64))
     _69=numpy.zeros((_62,), dtype=numpy.dtype(numpy.int64))
     _70=numpy.zeros((_62,), dtype=numpy.dtype(numpy.float64))
     _71=(None if (((_5.bfix) is None) ) else numpy.zeros((_61,), dtype=numpy.dtype(numpy.float64)))
     _72=(None if ((_61 >= _6) ) else numpy.zeros((_61,), dtype=numpy.dtype(numpy.int64)))
     _73=mosek_fusion_IntSet._ctor_I(_6)
     _74=0
     _75=0
     _76=(- 1)
     _77=0
     while ((_74 < int(((_5.inst)).shape[0])) and (_75 < _39)):
      _78=((_5.inst)[_74] // numpy.int64(_7))
      _79=((_5.inst)[_74] - (_78 * numpy.int64(_7)))
      if (_78 < _41[_43[_75]]):
       _74 += 1
      elif (_78 > _41[_43[_75]]):
       _75 += 1
      elif (_79 < _40[_43[_75]]):
       _74 += 1
      elif (_79 > _40[_43[_75]]):
       _75 += 1
      else:
       if (_76 < _78):
        if (_72 is not None):
         _72[_77] = _78
        _77 += 1
        _68[_77] = _68[(_77 - 1)]
        _76 = _78
       _80=((_5.ptrb)[(_74 + 1)] - (_5.ptrb)[_74])
       _81=_42[_43[_75]]
       mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ((_5.subj),(_5.ptrb)[_74],_69,_68[_77],_80)
       _82=0
       while (_82 < _80):
        _70[(_68[_77] + _82)] = (_81 * (_5.cof)[((_5.ptrb)[_74] + _82)])
        _82 += 1
       if (_71 is not None):
        _71[(_77 - 1)] = (_71[(_77 - 1)] + (_81 * (_5.bfix)[_74]))
       _68[_77] = (_68[_77] + _80)
       _74 += 1
       _75 += 1
     _4 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_68,(_5.x),_69,_70,_71,_73,_72)
   return (_4)
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mulDiag may not be null")
   _2=_0
   _3=_1
   _5=_3._eval_()
   if (((_5.shape).nd)!=2):
    raise mosek_fusion_DimensionError._ctor_S("Expression operand must have 2 dimensions")
   if (((_5.shape)._dim_I(0)!=(_2._dimj)) or ((_5.shape)._dim_I(1)!=(_2._dimi))):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _6=(_5.shape)._dim_I(0)
   _7=(_5.shape)._dim_I(1)
   if ((_5.inst) is not None):
    _8 = numpy.zeros(((int(((_5.ptrb)).shape[0]) - 1),), dtype=numpy.dtype(numpy.int64))
    _9 = mosek.fusion.Utils.Tools._range_J(int((_8).shape[0]))
    for _10 in range(0,int((_8).shape[0])):
     _11=((_5.inst)[_10] // numpy.int64(_7))
     _12=((_5.inst)[_10] % numpy.int64(_7))
     _8[_10] = ((_12 * _6) + _11)
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_9,_8,None,0,int((_9).shape[0]))
   else:
    _8 = numpy.array([((numpy.int64((_13 % _7)) * _6) + (_13 // _7)) for _13 in range(0,(int(((_5.ptrb)).shape[0]) - 1))], dtype=numpy.dtype(numpy.int64))
    _9 = numpy.array([((numpy.int64((_14 % _6)) * _7) + (_14 // _6)) for _14 in range(0,(int(((_5.ptrb)).shape[0]) - 1))], dtype=numpy.dtype(numpy.int64))
   _16=_2
   if   isinstance(_16,mosek_fusion_DenseMatrix):
    m=_16
    _16=0
    if ((_5.inst) is None):
     _16 = numpy.int64(_7)
    else:
     _17=(- 1)
     for _18 in range(0,int((_8).shape[0])):
      _19=numpy.int32((_8[_9[_18]] // numpy.int64((m._dimj))))
      if (_19 > _17):
       _16 += 1
       _17 = _19
    _20=int(((_5.subj)).shape[0])
    _21=numpy.zeros(((_16 + 1),), dtype=numpy.dtype(numpy.int64))
    _22=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    _23=numpy.zeros((_20,), dtype=numpy.dtype(numpy.float64))
    _24=None
    _25=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int64))
    _26=(- 1)
    _27=0
    for _28 in range(0,int((_8).shape[0])):
     _29=numpy.int32((_8[_9[_28]] // numpy.int64(_6)))
     if (_29 > _26):
      _27 += 1
      _26 = _29
      _21[_27] = _21[(_27 - 1)]
      _25[(_27 - 1)] = numpy.int64(_29)
     _30=((_5.ptrb)[(_9[_28] + 1)] - (_5.ptrb)[_9[_28]])
     for _31 in range(0,_30):
      _22[(_21[_27] + _31)] = (_5.subj)[((_5.ptrb)[_9[_28]] + _31)]
      _23[(_21[_27] + _31)] = ((_5.cof)[((_5.ptrb)[_9[_28]] + _31)] * (m._data)[_8[_9[_28]]])
     _21[_27] = (_21[_27] + _30)
    if ((_5.bfix) is not None):
     _32=(- 1)
     _33=0
     _24 = numpy.zeros((_16,), dtype=numpy.dtype(numpy.float64))
     for _34 in range(0,int((_8).shape[0])):
      _35=numpy.int32((_8[_9[_34]] // numpy.int64((m._dimj))))
      if (_35 > _32):
       _33 += 1
       _32 = _35
      _24[(_33 - 1)] += ((m._data)[_8[_9[_34]]] * (_5.bfix)[_9[_34]])
    _4 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_21,(_5.x),_22,_23,_24,None,(_25 if ((int((_25).shape[0]) < (m._dimi)) ) else None))
   else:
    m=_16
    _36=numpy.zeros((m._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _37=numpy.zeros((m._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _38=numpy.zeros((m._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _39=m._numNonzeros_()
    _40=m._numRows_()
    _41=m._numColumns_()
    m._getDataAsTriplets__3I_3I_3D(_36,_37,_38)
    _42=0
    _43=0
    _44=(- 1)
    _45=0
    _46=0
    while ((_45 < _39) and (_46 < int((_8).shape[0]))):
     _47=((_36[_45] * _41) + _37[_45])
     if (_47 < _8[_9[_46]]):
      _45 += 1
     elif (_47 > _8[_9[_46]]):
      _46 += 1
     else:
      if (_44 < _36[_45]):
       _44 = _36[_45]
       _42 += 1
      _43 = (_43 + ((_5.ptrb)[(_9[_46] + 1)] - (_5.ptrb)[_9[_46]]))
      _46 += 1
      _45 += 1
    _48=numpy.zeros(((_42 + 1),), dtype=numpy.dtype(numpy.int64))
    _49=numpy.zeros((_43,), dtype=numpy.dtype(numpy.int64))
    _50=numpy.zeros((_43,), dtype=numpy.dtype(numpy.float64))
    _51=None
    _52=numpy.zeros((_42,), dtype=numpy.dtype(numpy.int64))
    _53=(- 1)
    _54=0
    _55=0
    _56=0
    while ((_54 < _39) and (_55 < int((_8).shape[0]))):
     _57=((_36[_54] * _41) + _37[_54])
     if (_57 < _8[_9[_55]]):
      _54 += 1
     elif (_57 > _8[_9[_55]]):
      _55 += 1
     else:
      if (_53 < _36[_54]):
       _53 = _36[_54]
       _56 += 1
       _52[(_56 - 1)] = numpy.int64(_53)
       _48[_56] = _48[(_56 - 1)]
      _58=((_5.ptrb)[(_9[_55] + 1)] - (_5.ptrb)[_9[_55]])
      for _59 in range(0,_58):
       _49[(_48[_56] + _59)] = (_5.subj)[((_5.ptrb)[_9[_55]] + _59)]
       _50[_48[(_56 + _59)]] = ((_5.cof)[((_5.ptrb)[_9[_55]] + _59)] * _38[_54])
      _48[_56] = (_48[_56] + _58)
      _55 += 1
      _54 += 1
    if ((_5.bfix) is not None):
     _60=(- 1)
     _61=0
     _62=0
     _63=0
     _51 = numpy.zeros((_42,), dtype=numpy.dtype(numpy.float64))
     while ((_61 < _39) and (_62 < int((_8).shape[0]))):
      _64=((_36[_61] * _41) + _37[_61])
      if (_64 < _8[_9[_62]]):
       _61 += 1
      elif (_64 > _8[_9[_62]]):
       _62 += 1
      else:
       if (_60 < _36[_61]):
        _60 = _36[_61]
        _63 += 1
       _51[(_63 - 1)] = (_51[(_63 - 1)] + ((_5.bfix)[_9[_62]] * _38[_61]))
       _62 += 1
       _61 += 1
    if (int((_52).shape[0])==(m._dimi)):
     _52 = None
    _4 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_48,(_5.x),_49,_50,_51,mosek.fusion.Set._make_I((m._dimi)),_52)
   return (_4)
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,mosek.fusion.Matrix._dense__3_5D(_1)))
  @staticmethod
  def _match_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulDiag_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _mulDiag__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,mosek.fusion.Matrix._dense__3_5D(_1)))
  @staticmethod
  def _match_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulDiag_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _mulDiag__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0._numRows_()!=_1._shape_()._dim_I(0)) or ((_0._numColumns_()!=_1._shape_()._dim_I(1)) or ((_0._numRows_() * _0._numColumns_())!=_1._shape_()._getSize_()))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _2=_0._numNonzeros_()
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
   _6=numpy.array([((_3[_7] * _0._numColumns_()) + _4[_7]) for _7 in range(0,_2)], dtype=numpy.dtype(numpy.int64))
   _8=_1._eval_()
   return (mosek.fusion.Expr.__dotmul_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_6,_5,(_8.ptrb),(_8.subj),(_8.cof),(_8.bfix),(_8.inst),(_8.x),(_8.shape)))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   if ((_0._numRows_()!=_1._shape_()._dim_I(0)) or ((_0._numColumns_()!=_1._shape_()._dim_I(1)) or ((_0._numRows_() * _0._numColumns_())!=_1._shape_()._getSize_()))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _2=_0._numNonzeros_()
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
   _6=numpy.array([((_3[_7] * _0._numColumns_()) + _4[_7]) for _7 in range(0,_2)], dtype=numpy.dtype(numpy.int64))
   return (mosek.fusion.Expr.__dotmul_1__3J_3DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_6,_5,_1,_1._shape_()))
  @staticmethod
  def __mulElm_1_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr.__mulElm_1__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mulElm_1__3DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mulElm may not be null")
   if ((_1._shape_()._dim_I(0)!=int((_0).shape[0])) or (_1._shape_()._getSize_()!=int((_0).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   return (mosek.fusion.Expr.__dotmul_1__3J_3DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(mosek.fusion.Utils.Tools._range_JJ(0,int((_0).shape[0])),_0,_1,_1._shape_()))
  @staticmethod
  def __mulElm_1_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mulElm may not be null")
   if ((_1._shape_()._dim_I(0)!=int((_0).shape[0])) or (_1._shape_()._getSize_()!=int((_0).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _2=_1._eval_()
   return (mosek.fusion.Expr.__dotmul_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(mosek.fusion.Utils.Tools._range_JJ(0,int((_0).shape[0])),_0,(_2.ptrb),(_2.subj),(_2.cof),(_2.bfix),(_2.inst),(_2.x),(_2.shape)))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mulElm may not be null")
   for _2 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_2]!=_1._shape_()._dim_I(_2)):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   for _3 in range(int(((_0._dims)).shape[0]),(_1._shape_().nd)):
    if (1!=_1._shape_()._dim_I(_3)):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   for _4 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_4]!=_1._shape_()._dim_I(_4)):
     raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   _5=_1._eval_()
   return (mosek.fusion.Expr.__dotmul_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2((_0._inst),(_0._cof),(_5.ptrb),(_5.subj),(_5.cof),(_5.bfix),(_5.inst),(_5.x),(_5.shape)))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1):
   if ((_1._shape_().nd)!=int(((_0._dims)).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   for _2 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_2]!=_1._shape_()._dim_I(_2)):
     raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   return (mosek.fusion.Expr.__dotmul_1__3J_3DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2((_0._inst),(_0._cof),_1,_1._shape_()))
  @staticmethod
  def __dotmul_1_alt__3J_3DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _3=_t__3
   _1 = mosek_fusion_Expr.__dotmul_1__3J_3DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __dotmul_1__3J_3DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _4=int((_0).shape[0])
   _5=mosek.fusion.Utils.Tools._range_J((int((_0).shape[0]) + 1))
   _6=mosek.fusion.Utils.Tools._arraycopy__3J(_0)
   _7=mosek.fusion.Utils.Tools._arraycopy__3D(_1)
   _8=None
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_5,numpy.array([_2], dtype=numpy.dtype(object)),_6,_7,_8,_3,_0))
  @staticmethod
  def __dotmul_1_alt__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int64))
   _7=numpy.array(_t__7,dtype=numpy.dtype(object))
   _8=_t__8
   _1 = mosek_fusion_Expr.__dotmul_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __dotmul_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   _9=int((_0).shape[0])
   _10=(_6 if ((_6 is not None) ) else mosek.fusion.Utils.Tools._range_JJ(0,(int((_2).shape[0]) - 1)))
   _11=int((_10).shape[0])
   _12=0
   _13=0
   _13,_12 = fragments._c_closure_244(_10,_11,_2,_0,_9,_13,_12) # src/fusion/Expr.mbi:3902:9-3915:10
   _13 = numpy.int32(_13) # postprocess
   _12 = numpy.int64(_12) # postprocess
   _14=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
   _15=numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64))
   _16=numpy.zeros(((_13 + 1),), dtype=numpy.dtype(numpy.int64))
   _17=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
   _18=(None if ((_5 is None) ) else numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64)))
   fragments._c_closure_245(_18,_15,_5,_4,_10,_11,_2,_3,_17,_0,_9,_1,_16,_14) # src/fusion/Expr.mbi:3923:9-3959:10
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_16,_7,_14,_15,_18,_8,(_17 if ((int((_17).shape[0]) < (_8._size)) ) else None)))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=None
   _3=_1._eval_()
   _4=_0._numRows_()
   _5=_0._numColumns_()
   _6=None
   if ((((_3.shape).nd)==1) and ((_3.shape)._dim_I(0)==1)):
    _2 = mosek.fusion.Expr.__mul_10DExpr_1Matrix__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2((_3.subj),(_3.cof),(_3.bfix),(_3.x),_0)
   else:
    if ((((_3.shape).nd)==1) and ((_3.shape)._dim_I(0)==_5)):
     _8 = 1
     _7 = (_3.shape)._dim_I(0)
     _6 = mosek_fusion_IntSet._ctor_I(_4)
    elif ((((_3.shape).nd)==2) and ((_3.shape)._dim_I(0)==_5)):
     _7 = (_3.shape)._dim_I(0)
     _8 = (_3.shape)._dim_I(1)
     _6 = mosek_fusion_NDSet._ctor_II(_4,_8)
    else:
     raise mosek_fusion_DimensionError._ctor_S("Expression operand must be one- or two-dimensional, and dimensions must match for multiplication")
    if (((_3.inst) is None) and (not _0._isSparse_())):
     _2 = mosek.fusion.Expr.__mul_1DMatrix_12DDExpr__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII((_3.ptrb),(_3.subj),(_3.cof),(_3.bfix),(_3.x),_6,_7,_8,_0._getDataAsArray_(),_4,_5)
    else:
     _9=_0._numNonzeros_()
     _10=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
     _11=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
     _12=numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64))
     _0._getDataAsTriplets__3I_3I_3D(_10,_11,_12)
     _13=(_3.inst)
     if (_13 is None):
      _13 = mosek.fusion.Utils.Tools._range_JJ(0,(int(((_3.ptrb)).shape[0]) - 1))
     _2 = mosek.fusion.Expr.__mul_1SMatrix_12DSExpr__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII((_3.ptrb),(_3.subj),(_3.cof),(_3.bfix),_13,(_3.x),_6,_7,_8,_10,_11,_12,_4,_5)
   return (_2)
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=None
   _3=_0._eval_()
   _4=_1._numRows_()
   _5=_1._numColumns_()
   if ((((_3.shape).nd)==1) and ((_3.shape)._dim_I(0)==1)):
    _2 = mosek.fusion.Expr.__mul_10DExpr_1Matrix__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2((_3.subj),(_3.cof),(_3.bfix),(_3.x),_1)
   else:
    _6=None
    if ((((_3.shape).nd)==1) and ((_3.shape)._dim_I(0)==_4)):
     _7 = 1
     _8 = (_3.shape)._dim_I(0)
     _6 = mosek_fusion_IntSet._ctor_I(_5)
    elif ((((_3.shape).nd)==2) and ((_3.shape)._dim_I(1)==_4)):
     _7 = (_3.shape)._dim_I(0)
     _8 = (_3.shape)._dim_I(1)
     _6 = mosek_fusion_NDSet._ctor_II(_7,_5)
    else:
     raise mosek_fusion_DimensionError._ctor_S("Expression operand must be one- or two-dimensional, and dimensions must match for multiplication")
    if (((_3.inst) is None) and (not _1._isSparse_())):
     _2 = mosek.fusion.Expr.__mul_12DDExpr_1DMatrix__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII((_3.ptrb),(_3.subj),(_3.cof),(_3.bfix),(_3.x),_6,_7,_8,_1._getDataAsArray_(),_4,_5)
    else:
     _9=_1._numNonzeros_()
     _10=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
     _11=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
     _12=numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64))
     _1._getDataAsTriplets__3I_3I_3D(_10,_11,_12)
     _13=(_3.inst)
     if (_13 is None):
      _13 = mosek.fusion.Utils.Tools._range_JJ(0,(int(((_3.ptrb)).shape[0]) - 1))
     _2 = mosek.fusion.Expr.__mul_12DSExpr_1SMatrix__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII((_3.ptrb),(_3.subj),(_3.cof),(_3.bfix),(_3.inst),(_3.x),_6,_7,_8,_10,_11,_12,_4,_5)
   return (_2)
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=None
   _3=int((_1).shape[0])
   _4=1
   _5=_0._eval_()
   if ((((_5.shape).nd)==1) and ((_5.shape)._dim_I(0)==1)):
    _2 = mosek.fusion.Expr.__mul_10DExpr_1Matrix__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2((_5.subj),(_5.cof),(_5.bfix),(_5.x),mosek_fusion_DenseMatrix._ctor_II_3D(int((_1).shape[0]),1,_1))
   else:
    _8=None
    if (((_5.shape).nd)==1):
     _8 = mosek_fusion_IntSet._ctor_I(1)
     _7 = (_5.shape)._dim_I(0)
     _6 = 1
    elif ((_5.shape)._realnd_()==2):
     _8 = mosek_fusion_IntSet._ctor_I((_5.shape)._dim_I(0))
     _6 = (_5.shape)._dim_I(0)
     _7 = (_5.shape)._dim_I(1)
    else:
     raise mosek_fusion_DimensionError._ctor_S("Expression operand must be one- or two-dimensional")
    if (_7!=_3):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
    if ((_5.inst) is None):
     _2 = mosek.fusion.Expr.__mul_12DDExpr_1DMatrix__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII((_5.ptrb),(_5.subj),(_5.cof),(_5.bfix),(_5.x),_8,_6,_7,_1,_3,_4)
    else:
     _2 = mosek.fusion.Expr.__mul_12DSExpr_1SMatrix__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII((_5.ptrb),(_5.subj),(_5.cof),(_5.bfix),(_5.inst),(_5.x),_8,_6,_7,mosek.fusion.Utils.Tools._range_II(0,_3),mosek.fusion.Utils.Tools._makevector_II(0,_3),_1,_3,_4)
   return (_2)
  @staticmethod
  def _match_mul__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mul__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=1
   _3=int((_0).shape[0])
   _4=None
   _5=_1._eval_()
   if ((((_5.shape).nd)==1) and ((_5.shape)._dim_I(0)==1)):
    _4 = mosek.fusion.Expr.__mul_10DExpr_1Matrix__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2((_5.subj),(_5.cof),(_5.bfix),(_5.x),mosek_fusion_DenseMatrix._ctor_II_3D(1,int((_0).shape[0]),_0))
   else:
    _8=None
    if (((_5.shape).nd)==1):
     _7 = 1
     _6 = (_5.shape)._dim_I(0)
     _8 = mosek_fusion_IntSet._ctor_I(1)
    elif (((_5.shape).nd)==2):
     _8 = mosek_fusion_IntSet._ctor_I((_5.shape)._dim_I(1))
     _6 = (_5.shape)._dim_I(0)
     _7 = (_5.shape)._dim_I(1)
    else:
     raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
    if (_6!=_3):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
    if ((_5.inst) is None):
     _4 = mosek.fusion.Expr.__mul_1DMatrix_12DDExpr__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII((_5.ptrb),(_5.subj),(_5.cof),(_5.bfix),(_5.x),_8,_6,_7,_0,_2,_3)
    else:
     _4 = mosek.fusion.Expr.__mul_1SMatrix_12DSExpr__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII((_5.ptrb),(_5.subj),(_5.cof),(_5.bfix),(_5.inst),(_5.x),_8,_6,_7,mosek.fusion.Utils.Tools._makevector_II(0,_3),mosek.fusion.Utils.Tools._range_II(0,_3),_0,_2,_3)
   return (_4)
  @staticmethod
  def _match_mul_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _mul_DLmosek_4fusion_4Expression_2(_0,_1):
   if (_1 is None):
    raise ValueError("Arguments for mul may not be null")
   _2=_1._eval_()
   for _3 in range(0,int(((_2.cof)).shape[0])):
    (_2.cof)[_3] = ((_2.cof)[_3] * _0)
   if ((_2.bfix) is not None):
    for _4 in range(0,int(((_2.bfix)).shape[0])):
     (_2.bfix)[_4] = ((_2.bfix)[_4] * _0)
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI((_2.ptrb),(_2.x),(_2.subj),(_2.cof),(_2.bfix),(_2.shape),(_2.inst),1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2D(_0,_1):
   if (_0 is None):
    raise ValueError("Arguments for mul may not be null")
   return (mosek.fusion.Expr._mul_DLmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def __mul_1SMatrix_12DSExpr_alt__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10,_t__11,_t__12,_t__13):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(object))
   _6=_t__6
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.array(_t__9,dtype=numpy.dtype(numpy.int32))
   _10=numpy.array(_t__10,dtype=numpy.dtype(numpy.int32))
   _11=numpy.array(_t__11,dtype=numpy.dtype(numpy.float64))
   _12=numpy.int32(_t__12)
   _13=numpy.int32(_t__13)
   _1 = mosek_fusion_Expr.__mul_1SMatrix_12DSExpr__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__9[:] = _9
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__10[:] = _10
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__11[:] = _11
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_1SMatrix_12DSExpr__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _9 is None or isinstance(_9,numpy.ndarray)
   assert _10 is None or isinstance(_10,numpy.ndarray)
   assert _11 is None or isinstance(_11,numpy.ndarray)
   _14=None
   _15=numpy.array([numpy.int32((_4[_16] // _8)) for _16 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _17=numpy.array([numpy.int32((_4[_18] % _8)) for _18 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _19=mosek.fusion.Utils.Tools._range_JJ(0,int((_4).shape[0]))
   _20=int((_9).shape[0])
   _21=int((_4).shape[0])
   _22=_12
   _23=_8
   mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_19,_17,_15,0,int((_4).shape[0]))
   _24=0
   _25=0
   _25,_24 = fragments._c_closure_246(_21,_0,_15,_17,_20,_9,_10,_19,_25,_24) # src/fusion/Expr.mbi:3428:9-3463:10
   _25 = numpy.int64(_25) # postprocess
   _24 = numpy.int32(_24) # postprocess
   _26=numpy.zeros((_24,), dtype=numpy.dtype(numpy.int64))
   _27=numpy.zeros(((_24 + 1),), dtype=numpy.dtype(numpy.int64))
   _28=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int64))
   _29=numpy.zeros((_25,), dtype=numpy.dtype(numpy.float64))
   _30=None
   fragments._c_closure_247(_29,_2,_8,_21,_0,_1,_15,_17,_26,_11,_20,_9,_10,_19,_27,_28) # src/fusion/Expr.mbi:3472:9-3518:10
   if (_3 is not None):
    _30 = numpy.zeros((_24,), dtype=numpy.dtype(numpy.float64))
    _31=0
    _31 = fragments._c_closure_248(_30,_31,_3,_21,_15,_17,_11,_20,_9,_10,_19) # src/fusion/Expr.mbi:3526:11-3559:12
    _31 = numpy.int32(_31) # postprocess
   if (int((_26).shape[0])==(_22 * _23)):
    _26 = None
   _14 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_27,_5,_28,_29,_30,_6,_26)
   return (_14)
  @staticmethod
  def __mul_12DSExpr_1SMatrix_alt__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10,_t__11,_t__12,_t__13):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(object))
   _6=_t__6
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _9=numpy.array(_t__9,dtype=numpy.dtype(numpy.int32))
   _10=numpy.array(_t__10,dtype=numpy.dtype(numpy.int32))
   _11=numpy.array(_t__11,dtype=numpy.dtype(numpy.float64))
   _12=numpy.int32(_t__12)
   _13=numpy.int32(_t__13)
   _1 = mosek_fusion_Expr.__mul_12DSExpr_1SMatrix__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__9[:] = _9
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__10[:] = _10
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__11[:] = _11
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_12DSExpr_1SMatrix__3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3I_3I_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _9 is None or isinstance(_9,numpy.ndarray)
   assert _10 is None or isinstance(_10,numpy.ndarray)
   assert _11 is None or isinstance(_11,numpy.ndarray)
   _14=None
   _15=_7
   _16=_13
   _17=int((_11).shape[0])
   _18=int((_4).shape[0])
   _19=mosek.fusion.Utils.Tools._range_JJ(0,int((_9).shape[0]))
   mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_19,_10,_9,0,int((_9).shape[0]))
   _20=0
   _21=0
   _21,_20 = fragments._c_closure_249(_8,_4,_18,_0,_17,_9,_10,_19,_21,_20) # src/fusion/Expr.mbi:3250:9-3283:10
   _21 = numpy.int64(_21) # postprocess
   _20 = numpy.int32(_20) # postprocess
   _22=numpy.zeros(((_20 + 1),), dtype=numpy.dtype(numpy.int64))
   _23=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
   _24=numpy.zeros((_21,), dtype=numpy.dtype(numpy.int64))
   _25=numpy.zeros((_21,), dtype=numpy.dtype(numpy.float64))
   _26=None
   fragments._c_closure_250(_25,_2,_8,_4,_18,_0,_1,_23,_11,_17,_9,_10,_19,_22,_16,_24) # src/fusion/Expr.mbi:3292:9-3338:10
   if (_3 is not None):
    _26 = numpy.zeros((_20,), dtype=numpy.dtype(numpy.float64))
    _27=0
    _27 = fragments._c_closure_251(_26,_27,_3,_8,_4,_18,_11,_17,_9,_10,_19) # src/fusion/Expr.mbi:3345:11-3381:12
    _27 = numpy.int32(_27) # postprocess
   if (int((_23).shape[0])==(_15 * _16)):
    _23 = None
   _14 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_22,_5,_24,_25,_26,_6,_23)
   return (_14)
  @staticmethod
  def __mul_1DMatrix_12DDExpr_alt__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(object))
   _5=_t__5
   _6=numpy.int32(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.float64))
   _9=numpy.int32(_t__9)
   _10=numpy.int32(_t__10)
   _1 = mosek_fusion_Expr.__mul_1DMatrix_12DDExpr__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_1DMatrix_12DDExpr__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _8 is None or isinstance(_8,numpy.ndarray)
   _12=_9
   _13=_7
   _14=(numpy.int64(_12) * numpy.int64(_13))
   _15=numpy.zeros(((_14 + 1),), dtype=numpy.dtype(numpy.int64))
   _16=numpy.zeros(((int((_1).shape[0]) * _9),), dtype=numpy.dtype(numpy.int64))
   _17=numpy.zeros(((int((_1).shape[0]) * _9),), dtype=numpy.dtype(numpy.float64))
   _18=None
   fragments._c_closure_252(_17,_2,_6,_7,_0,_1,_8,_9,_10,_15,_16) # src/fusion/Expr.mbi:3178:9-3197:10
   if (_3 is not None):
    _19=0
    _18 = numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
    _19 = fragments._c_closure_253(_18,_19,_3,_6,_7,_8,_9,_10) # src/fusion/Expr.mbi:3203:11-3209:14
    _19 = numpy.int32(_19) # postprocess
   _11 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_15,_4,_16,_17,_18,_5,None)
   return (_11)
  @staticmethod
  def __mul_12DDExpr_1DMatrix_alt__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(object))
   _5=_t__5
   _6=numpy.int32(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.float64))
   _9=numpy.int32(_t__9)
   _10=numpy.int32(_t__10)
   _1 = mosek_fusion_Expr.__mul_12DDExpr_1DMatrix__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_12DDExpr_1DMatrix__3J_3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Set_2II_3DII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _8 is None or isinstance(_8,numpy.ndarray)
   _12=_6
   _13=_10
   _14=numpy.zeros((((_6 * _10) + 1),), dtype=numpy.dtype(numpy.int64))
   _15=None
   _16=numpy.zeros(((int((_1).shape[0]) * _10),), dtype=numpy.dtype(numpy.int64))
   _17=numpy.zeros(((int((_1).shape[0]) * _10),), dtype=numpy.dtype(numpy.float64))
   _18=None
   fragments._c_closure_254(_17,_2,_7,_0,_1,_8,_9,_10,_14,_12,_13,_16) # src/fusion/Expr.mbi:3107:9-3130:10
   if (_3 is not None):
    _18 = numpy.zeros(((_12 * _13),), dtype=numpy.dtype(numpy.float64))
    _19=0
    _19 = fragments._c_closure_255(_18,_3,_7,_8,_9,_10,_19,_12,_13) # src/fusion/Expr.mbi:3136:11-3143:14
    _19 = numpy.int32(_19) # postprocess
   _11 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_14,_4,_16,_17,_18,_5,_15)
   return (_11)
  @staticmethod
  def __mul_10DExpr_1Matrix_alt__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(object))
   _4=_t__4
   _1 = mosek_fusion_Expr.__mul_10DExpr_1Matrix__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_10DExpr_1Matrix__3J_3D_3D_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _5=None
   _6=_4._numRows_()
   _7=_4._numColumns_()
   _8=_4._numNonzeros_()
   _10=None
   _11=None
   _12=mosek.fusion.Utils.Tools._range_JJJ(0,((_8 * int((_0).shape[0])) + 1),int((_0).shape[0]))
   _13=numpy.zeros(((_8 * int((_0).shape[0])),), dtype=numpy.dtype(numpy.int64))
   _14=numpy.zeros(((_8 * int((_0).shape[0])),), dtype=numpy.dtype(numpy.float64))
   _15=None
   _16=None
   if (not _4._isSparse_()):
    _9 = _4._getDataAsArray_()
   else:
    _10 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
    _11 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
    _9 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
    _16 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    _4._getDataAsTriplets__3I_3I_3D(_10,_11,_9)
    fragments._c_closure_256(_16,_7,_10,_11) # src/fusion/Expr.mbi:3051:11-3052:57
   fragments._c_closure_257(_14,_0,_9,_8,_13) # src/fusion/Expr.mbi:3056:9-3065:10
   if (_2 is not None):
    _15 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_258(_15,_2,_9,_8) # src/fusion/Expr.mbi:3070:11-3071:42
   _5 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_12,_3,_13,_14,_15,mosek_fusion_NDSet._ctor_II(_6,_7),None)
   return (_5)
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mul_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mul may not be null")
   if (int((_1).shape[0])==0):
    _2=numpy.array([0,0], dtype=numpy.dtype(numpy.int64))
    _3=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
    _4=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_2,numpy.array([_0], dtype=numpy.dtype(object)),_3,_4,None,None,None,1))
   else:
    return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,mosek_fusion_DenseMatrix._ctor__3_5D(_1)))
  @staticmethod
  def _match_mul__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mul__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mul_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _mul__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mul may not be null")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(mosek_fusion_DenseMatrix._ctor__3_5D(_0),_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Variable_2D(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2D(_0,numpy.float64(__1))
  @staticmethod
  def _mul_Lmosek_4fusion_4Variable_2D(_0,_1):
   if (_0 is None):
    raise ValueError("Arguments for mul may not be null")
   return (mosek.fusion.Expr._mul_DLmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_mul_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mul_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mul_alt_DLmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_DLmosek_4fusion_4Variable_2(numpy.float64(__0),_1)
  @staticmethod
  def _mul_DLmosek_4fusion_4Variable_2(_0,_1):
   if (_1 is None):
    raise ValueError("Arguments for mul may not be null")
   _2=_0
   _3=_1
   _4=mosek.fusion.Utils.Tools._range_JJ(0,((_3._shape_()._size) + 1))
   _5=mosek.fusion.Utils.Tools._makevector_DI(_2,numpy.int32((_3._shape_()._size)))
   _6=mosek.fusion.Utils.Tools._range_JJ(0,(_3._shape_()._size))
   _7=None
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_4,numpy.array([_1], dtype=numpy.dtype(object)),_6,_5,_7,_3._shape_(),None))
  @staticmethod
  def _match_mul__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mul__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mul_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mul__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul__3DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=_0
   _3=_1
   if (((_3._shape_()._size)==1) or ((_3._shape_().nd)==1)):
    return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Variable_2_3D(_3,_2))
   elif (((_1._shape_().nd)==1) and (_1._shape_()._dim_I(0)==int((_0).shape[0]))):
    return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Variable_2_3D(_1,_0))
   elif ((_3._shape_().nd)==2):
    if (_3._shape_()._dim_I(0)!=int((_2).shape[0])):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
    _4=_3._shape_()._dim_I(0)
    _5=_3._shape_()._dim_I(1)
    _6=numpy.array([_7 for _7 in range(0,((_5 + 1) * _4),_4)], dtype=numpy.dtype(numpy.int64))
    _8=numpy.zeros(((_3._shape_()._size),), dtype=numpy.dtype(numpy.float64))
    for _9 in range(0,_5):
     mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_2,0,_8,(_9 * _4),_4)
    _10=numpy.array([((_12 * _5) + _11) for _11 in range(0,_5) for _12 in range(0,_4)], dtype=numpy.dtype(numpy.int64))
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_6,numpy.array([_3], dtype=numpy.dtype(object)),_10,_8,None,None,None,1))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=_0
   _3=_1
   if ((_2._shape_()._size)==0):
    _4=numpy.array([0,0], dtype=numpy.dtype(numpy.int64))
    _5=numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
    _6=numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_4,numpy.array([_0], dtype=numpy.dtype(object)),_5,_6,None,None,None,1))
   elif ((_2._shape_()._size)==1):
    _7=mosek.fusion.Utils.Tools._range_JJ(0,(int((_3).shape[0]) + 1))
    _8=mosek.fusion.Utils.Tools._makevector_JI(0,int((_3).shape[0]))
    _9=mosek.fusion.Utils.Tools._arraycopy__3D(_3)
    _10=None
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_7,numpy.array([_0], dtype=numpy.dtype(object)),_8,_9,_10,None,None,1))
   elif (((_0._shape_().nd)==1) and (_0._shape_()._dim_I(0)==int((_1).shape[0]))):
    return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Variable_2_3D(_0,_1))
   elif ((_2._shape_().nd)==2):
    if (_2._shape_()._dim_I(1)!=int((_3).shape[0])):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
    _11=numpy.array([_12 for _12 in range(0,((_2._shape_()._size) + _2._shape_()._dim_I(1)),_2._shape_()._dim_I(1))], dtype=numpy.dtype(numpy.int64))
    _13=numpy.array([_14 for _14 in range(0,(_2._shape_()._size))], dtype=numpy.dtype(numpy.int64))
    _15=numpy.zeros(((_2._shape_()._size),), dtype=numpy.dtype(numpy.float64))
    _16=numpy.int64(_2._shape_()._dim_I(1))
    for _17 in range(0,_2._shape_()._dim_I(0)):
     mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_3,0,_15,(_17 * _16),_16)
    _18=None
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_11,numpy.array([_0], dtype=numpy.dtype(object)),_13,_15,_18,None,None,1))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=_0
   _3=_1
   _4=_1._numRows_()
   _5=_1._numColumns_()
   _8=_1._numNonzeros_()
   if (((_0._shape_().nd)==1) and (_0._shape_()._dim_I(0)==1)):
    return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_1,_0))
   else:
    if ((_2._shape_().nd)==1):
     if ((_3._dimi)!=(_2._shape_()._size)):
      raise mosek_fusion_LengthError._ctor_S("Operand shapes do not match.")
     _7 = 1
     _6 = _2._shape_()._dim_I(0)
    elif ((_2._shape_().nd)==2):
     if ((_1._dimi)!=_0._shape_()._dim_I(1)):
      raise mosek_fusion_LengthError._ctor_S("Operand shapes do not match.")
     _7 = _2._shape_()._dim_I(0)
     _6 = _2._shape_()._dim_I(1)
    else:
     raise mosek_fusion_LengthError._ctor_S("Variable must be one- or two-dimensional.")
    _9=_7
    _10=_5
    _11=None
    if ((_0._shape_().nd)==1):
     _11 = mosek_fusion_IntSet._ctor_I(_10)
    else:
     _11 = mosek_fusion_NDSet._ctor_II(_9,_10)
    if (not _1._isSparse_()):
     _12=(numpy.int64(_9) * numpy.int64(_10))
     _13=_1._getDataAsArray_()
     _14=numpy.array([_15 for _15 in range(0,(((numpy.int64(_9) * _10) * _6) + 1),_6)], dtype=numpy.dtype(numpy.int64))
     _16=numpy.array([((numpy.int64(_17) * _6) + _19) for _17 in range(0,_9) for _18 in range(0,_10) for _19 in range(0,_6)], dtype=numpy.dtype(numpy.int64))
     _20=numpy.array([_13[((_23 * _5) + _22)] for _21 in range(0,_9) for _22 in range(0,_10) for _23 in range(0,_6)], dtype=numpy.dtype(numpy.float64))
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_14,numpy.array([_0], dtype=numpy.dtype(object)),_16,_20,None,_11,None))
    elif (_8 > 0):
     _24=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
     _25=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
     _26=numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
     _27=numpy.array([_28 for _28 in range(0,_8)], dtype=numpy.dtype(numpy.int64))
     _1._getDataAsTriplets__3I_3I_3D(_24,_25,_26)
     if (_8 > _5):
      mosek.fusion.Sort._argbucketsort__3J_3IJJII(_27,_25,0,_8,0,_5)
     else:
      mosek.fusion.Sort._argsort__3J_3IJJZ(_27,_25,0,_8,False)
     _29=0
     _29 = fragments._c_closure_259(_29,_8,_25,_27) # src/fusion/Expr.mbi:2819:13-2823:14
     _29 = numpy.int64(_29) # postprocess
     _30=(_29 * numpy.int64(_7))
     _31=numpy.zeros(((_30 + 1),), dtype=numpy.dtype(numpy.int64))
     _32=numpy.zeros((_30,), dtype=numpy.dtype(numpy.int64))
     _33=numpy.zeros(((_8 * _7),), dtype=numpy.dtype(numpy.int64))
     _34=numpy.zeros(((_8 * _7),), dtype=numpy.dtype(numpy.float64))
     fragments._c_closure_260(_34,_32,_26,_8,_24,_25,_27,_31,_9,_10,_33,_6) # src/fusion/Expr.mbi:2831:13-2853:14
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_31,numpy.array([_0], dtype=numpy.dtype(object)),_33,_34,None,_11,_32))
    else:
     return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.array([_0], dtype=numpy.dtype(object)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,_11,numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for mul may not be null")
   _2=_1._shape_()
   _3=_0._numRows_()
   _4=_0._numColumns_()
   if ((_2.nd)==1):
    _5 = _2._dim_I(0)
    _6 = 1
   elif ((_2.nd)==2):
    _5 = _2._dim_I(0)
    _6 = _2._dim_I(1)
   else:
    raise mosek_fusion_LengthError._ctor_S("Operand shapes do not match.")
   _7=_3
   _8=_6
   _10=None
   if (((_1._shape_().nd)==1) and (_1._shape_()._dim_I(0)==1)):
    _10 = mosek_fusion_NDSet._ctor_II(_3,_4)
   elif ((_1._shape_().nd)==1):
    _10 = mosek_fusion_IntSet._ctor_I(_7)
   else:
    _10 = mosek_fusion_NDSet._ctor_II(_7,_8)
   if (((_2.nd)==1) and (_2._dim_I(0)==1)):
    if _0._isSparse_():
     _11=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _12=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _13=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
     _0._getDataAsTriplets__3I_3I_3D(_11,_12,_13)
     _14=numpy.array([((numpy.int64(_11[_15]) * _4) + _12[_15]) for _15 in range(0,int((_12).shape[0]))], dtype=numpy.dtype(numpy.int64))
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(mosek.fusion.Utils.Tools._range_JJ(0,(_0._numNonzeros_() + 1)),numpy.array([_1], dtype=numpy.dtype(object)),mosek.fusion.Utils.Tools._makevector_JI(0,numpy.int32(_0._numNonzeros_())),_13,None,_10,_14)
    else:
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(mosek.fusion.Utils.Tools._range_JJ(0,(_0._numNonzeros_() + 1)),numpy.array([_1], dtype=numpy.dtype(object)),numpy.array([0 for _16 in range(0,_0._numNonzeros_())], dtype=numpy.dtype(numpy.int64)),_0._getDataAsArray_(),None,_10,None)
   elif (_4==_5):
    if _0._isSparse_():
     if (_0._numNonzeros_() > 0):
      _17=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
      _18=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
      _19=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
      _20=int((_19).shape[0])
      _0._getDataAsTriplets__3I_3I_3D(_17,_18,_19)
      _21=(int((_19).shape[0]) * _6)
      _22=0
      _22 = fragments._c_closure_261(_20,_22,_17) # src/fusion/Expr.mbi:2642:15-2648:16
      _22 = numpy.int32(_22) # postprocess
      _23=(_22 * _6)
      _24=numpy.zeros(((_23 + 1),), dtype=numpy.dtype(numpy.int64))
      _25=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int64))
      _26=numpy.zeros((_21,), dtype=numpy.dtype(numpy.int64))
      _27=numpy.zeros((_21,), dtype=numpy.dtype(numpy.float64))
      fragments._c_closure_262(_27,_25,_19,_20,_22,_17,_18,_24,_26,_6) # src/fusion/Expr.mbi:2656:15-2682:16
      if (int((_25).shape[0])==(_7 * _8)):
       _25 = None
      _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_24,numpy.array([_1], dtype=numpy.dtype(object)),_26,_27,None,_10,_25)
     else:
      _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.array([_1], dtype=numpy.dtype(object)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,_10,numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)))
    else:
     _28=((_3 * _4) * _6)
     _29=_0._getDataAsArray_()
     _30=mosek.fusion.Utils.Tools._range_JJJ(0,(_28 + 1),(_4 if ((_4 > 0) ) else 1))
     _31=numpy.zeros((_28,), dtype=numpy.dtype(numpy.int64))
     _32=numpy.zeros((_28,), dtype=numpy.dtype(numpy.float64))
     fragments._c_closure_263(_32,_29,_4,_7,_8,_31,_6) # src/fusion/Expr.mbi:2707:13-2717:14
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_30,numpy.array([_1], dtype=numpy.dtype(object)),_31,_32,None,_10,None)
   else:
    raise mosek_fusion_LengthError._ctor_S("Operand shapes do not match.")
   return (_9)
  @staticmethod
  def __dot_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0._numRows_()!=_1._shape_()._dim_I(0)) or ((_0._numColumns_()!=_1._shape_()._dim_I(1)) or ((_0._numRows_() * _0._numColumns_())!=_1._shape_()._getSize_()))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _2=_0._numNonzeros_()
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
   _6=numpy.array([((_3[_7] * _0._numColumns_()) + _4[_7]) for _7 in range(0,_2)], dtype=numpy.dtype(numpy.int64))
   _8=_1._eval_()
   return (mosek.fusion.Expr.__inner_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2(_6,_5,(_8.ptrb),(_8.subj),(_8.cof),(_8.bfix),(_8.inst),(_8.x)))
  @staticmethod
  def __dot_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def __dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   if ((_0._numRows_()!=_1._shape_()._dim_I(0)) or ((_0._numColumns_()!=_1._shape_()._dim_I(1)) or ((_0._numRows_() * _0._numColumns_())!=_1._shape_()._getSize_()))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _2=_0._numNonzeros_()
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
   _6=numpy.array([((_3[_7] * _0._numColumns_()) + _4[_7]) for _7 in range(0,_2)], dtype=numpy.dtype(numpy.int64))
   return (mosek.fusion.Expr.__inner_1__3J_3DLmosek_4fusion_4Variable_2(_6,_5,_1))
  @staticmethod
  def __dot_1_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr.__dot_1__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __dot_1__3DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((_1 is None) or (_0 is None)):
    raise ValueError("Arguments for dot may not be null")
   if ((_1._shape_()._dim_I(0)!=int((_0).shape[0])) or ((_1._shape_()._size)!=int((_0).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   return (mosek.fusion.Expr.__inner_1__3J_3DLmosek_4fusion_4Variable_2(mosek.fusion.Utils.Tools._range_JJ(0,int((_0).shape[0])),_0,_1))
  @staticmethod
  def __dot_1_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr.__dot_1__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __dot_1__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for dot may not be null")
   if ((_1._shape_()._dim_I(0)!=int((_0).shape[0])) or ((_1._shape_()._size)!=int((_0).shape[0]))):
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _2=_1._eval_()
   return (mosek.fusion.Expr.__inner_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2(mosek.fusion.Utils.Tools._range_JJ(0,int((_0).shape[0])),_0,(_2.ptrb),(_2.subj),(_2.cof),(_2.bfix),(_2.inst),(_2.x)))
  @staticmethod
  def __dot_1_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)):
    raise ValueError("Arguments for dot may not be null")
   for _2 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_2]!=_1._shape_()._dim_I(_2)):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   for _3 in range(int(((_0._dims)).shape[0]),(_1._shape_().nd)):
    if (1!=_1._shape_()._dim_I(_3)):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   for _4 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_4]!=_1._shape_()._dim_I(_4)):
     raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   _5=_1._eval_()
   return (mosek.fusion.Expr.__inner_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2((_0._inst),(_0._cof),(_5.ptrb),(_5.subj),(_5.cof),(_5.bfix),(_5.inst),(_5.x)))
  @staticmethod
  def __dot_1_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr.__dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def __dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1):
   if ((_1._shape_().nd)!=int(((_0._dims)).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   for _2 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_2]!=_1._shape_()._dim_I(_2)):
     raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   return (mosek.fusion.Expr.__inner_1__3J_3DLmosek_4fusion_4Variable_2((_0._inst),(_0._cof),_1))
  @staticmethod
  def __inner_1_alt__3J_3DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = mosek_fusion_Expr.__inner_1__3J_3DLmosek_4fusion_4Variable_2(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __inner_1__3J_3DLmosek_4fusion_4Variable_2(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=int((_0).shape[0])
   _4=numpy.array([0,int((_1).shape[0])], dtype=numpy.dtype(numpy.int64))
   _5=mosek.fusion.Utils.Tools._arraycopy__3J(_0)
   _6=mosek.fusion.Utils.Tools._arraycopy__3D(_1)
   _7=None
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_4,numpy.array([_2], dtype=numpy.dtype(object)),_5,_6,_7,mosek.fusion.Set._scalar_(),None))
  @staticmethod
  def __inner_1_alt__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int64))
   _7=numpy.array(_t__7,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr.__inner_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __inner_1__3J_3D_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   _8=int((_0).shape[0])
   _9=(_6 if ((_6 is not None) ) else mosek.fusion.Utils.Tools._range_JJ(0,(int((_2).shape[0]) - 1)))
   _10=int((_9).shape[0])
   _11=0
   _11 = fragments._c_closure_264(_9,_10,_2,_0,_8,_11) # src/fusion/Expr.mbi:2350:9-2362:10
   _11 = numpy.int64(_11) # postprocess
   _12=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
   _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
   _14=numpy.zeros((1,), dtype=numpy.dtype(numpy.float64))
   _15=numpy.array([0,_11], dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_265(_13,_4,_9,_10,_2,_3,_0,_8,_1,_12) # src/fusion/Expr.mbi:2369:9-2386:10
   fragments._c_closure_266(_14,_5,_9,_10,_0,_8,_1) # src/fusion/Expr.mbi:2388:9-2401:10
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_15,_7,_12,_13,_14,mosek.fusion.Set._scalar_(),None))
  @staticmethod
  def _match_outer__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_outer__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _outer_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._outer__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (((_1._shape_().nd)!=1) or ((_1._shape_().nd)!=1)):
    raise mosek_fusion_DimensionError._ctor_S("Arguments must be one-dimensional")
   if (_1._shape_()._dim_I(0)!=int((_0).shape[0])):
    raise mosek_fusion_DimensionError._ctor_S("Argument lengths do not match")
   _2=_1._eval_()
   return (mosek.fusion.Expr.__outer_1_I_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2_3D_3IIZ((_2.shape)._dim_I(0),(_2.ptrb),(_2.subj),(_2.cof),(_2.bfix),(_2.inst),(_2.x),_0,numpy.array([_3 for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)),int((_0).shape[0]),True))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (((_0._shape_().nd)!=1) or ((_0._shape_().nd)!=1)):
    raise mosek_fusion_DimensionError._ctor_S("Arguments must be one-dimensional")
   _2=_0._eval_()
   return (mosek.fusion.Expr.__outer_1_I_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2_3D_3IIZ((_2.shape)._dim_I(0),(_2.ptrb),(_2.subj),(_2.cof),(_2.bfix),(_2.inst),(_2.x),_1,numpy.array([_3 for _3 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32)),int((_1).shape[0]),False))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   if (not (((_1._shape_().nd)==1) or (((_1._shape_().nd)==2) and (_1._shape_()._dim_I(1)==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   if ((_0._dimj)!=1):
    raise mosek_fusion_DimensionError._ctor_S("Constant matrix must be a column-vector")
   _3=_0
   if   isinstance(_3,mosek_fusion_DenseMatrix):
    m=_3
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_1,_1._shape_()._dim_I(0),(m._data),None,int(((m._data)).shape[0]),True))
   else:
    mx=_3
    _3=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _5=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    mx._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_1,_1._shape_()._dim_I(0),_5,_3,(mx._dimi),True))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if (not (((_0._shape_().nd)==1) or (((_0._shape_().nd)==2) and (_0._shape_()._dim_I(1)==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   if ((_1._dimj)!=1):
    raise mosek_fusion_DimensionError._ctor_S("Constant matrix must be a column-vector")
   _3=_1
   if   isinstance(_3,mosek_fusion_DenseMatrix):
    m=_3
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_0._shape_()._dim_I(0),(m._data),None,int(((m._data)).shape[0]),False))
   else:
    mx=_3
    _3=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _5=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    mx._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_0._shape_()._dim_I(0),_5,_3,(mx._dimi),False))
  @staticmethod
  def _match_outer__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_outer__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _outer_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._outer__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer__3DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (not (((_1._shape_().nd)==1) or (((_1._shape_().nd)==2) and (_1._shape_()._dim_I(1)==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_1,_1._shape_()._dim_I(0),_0,None,int((_0).shape[0]),True))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (not (((_0._shape_().nd)==1) or (((_0._shape_().nd)==2) and (_0._shape_()._dim_I(1)==1)))):
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_0._shape_()._dim_I(0),_1,None,int((_1).shape[0]),False))
  @staticmethod
  def __outer_1_alt_I_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2_3D_3IIZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(object))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.float64))
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.int32))
   _9=numpy.int32(_t__9)
   _10=_t__10
   _1 = mosek_fusion_Expr.__outer_1_I_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2_3D_3IIZ(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __outer_1_I_3J_3J_3D_3D_3J_3Lmosek_4fusion_4Variable_2_3D_3IIZ(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   assert _8 is None or isinstance(_8,numpy.ndarray)
   _11=(mosek.fusion.Set._make_II(_0,_9) if ((not _10) ) else mosek.fusion.Set._make_II(_9,_0))
   _12=(int((_7).shape[0]) * int((_5).shape[0]))
   _13=(int((_7).shape[0]) * int((_2).shape[0]))
   _14=numpy.zeros(((_12 + 1),), dtype=numpy.dtype(numpy.int64))
   _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
   _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
   _17=(numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64)) if ((_4 is not None) ) else None)
   _18=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
   _19=numpy.int32(_14[(int((_14).shape[0]) - 1)])
   if (not _10):
    fragments._c_closure_267(_7,_17,_16,_9,_4,_3,_5,_1,_2,_14,_8,_15) # src/fusion/Expr.mbi:2147:9-2179:10
   else:
    _20=0
    _21=0
    for _22 in range(0,int((_7).shape[0])):
     _23=_7[_22]
     mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(_2,0,_15,_21,_19)
     fragments._c_closure_268(_7,_16,_3,_19,_22,_21) # src/fusion/Expr.mbi:2188:13-63
     _20 = fragments._c_closure_269(_9,_5,_1,_22,_20,_14,_8) # src/fusion/Expr.mbi:2190:13-2197:14
     _20 = numpy.int64(_20) # postprocess
     _21 += _19
    fragments._c_closure_270(_7,_17,_4,_5) # src/fusion/Expr.mbi:2201:11-2212:12
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_14,_6,_15,_16,_17,_11,_18))
  @staticmethod
  def __outer_1_alt_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.int32(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_1,_2,_3,_4,_5):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _6=(mosek.fusion.Set._make_II(_1,_4) if ((not _5) ) else mosek.fusion.Set._make_II(_4,_1))
   _7=numpy.zeros((((int((_2).shape[0]) * _1) + 1),), dtype=numpy.dtype(numpy.int64))
   _8=numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.int64))
   _9=numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.float64))
   _10=None
   _11=(None if ((_4==int((_2).shape[0])) ) else numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.int64)))
   fragments._c_closure_271(_2,_9,_4,_11,_7,_3,_8,_5,_1) # src/fusion/Expr.mbi:2051:9-2104:10
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_7,numpy.array([_0], dtype=numpy.dtype(object)),_8,_9,_10,_6,_11))
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=_0
   if ((self.__shape_p.nd)!=int((_1).shape[1])):
    raise mosek_fusion_DimensionError._ctor_S("Invalid index size")
   for _2 in range(0,int((_1).shape[0])):
    for _3 in range(0,int((_1).shape[1])):
     if ((_1[_2,_3] < 0) or (_1[_2,_3] >= self.__shape_p._dim_I(_3))):
      raise mosek_fusion_IndexError._ctor_S("Index is out of bounds")
   return (self.__pick_1__3J(numpy.array([self.__shape_p._linearidx__3I(numpy.array([_1[_4,_5] for _5 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32))) for _4 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((self.__shape_p.nd)!=1):
    raise mosek_fusion_DimensionError._ctor_S("Method is only valid for one-dimensional expressions")
   for _1 in range(0,int((_0).shape[0])):
    if ((_0[_1] < 0) or (_0[_1] >= self.__shape_p._dim_I(0))):
     raise mosek_fusion_IndexError._ctor_S("Index is out of bounds")
   return (self.__pick_1__3J(numpy.array([_0[_2] for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))))
  def __pick_1_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self.__pick_1__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __pick_1__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((_0).shape[0])==0):
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(numpy.array([0], dtype=numpy.dtype(numpy.int64)),self.__x,numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make_I(0),None))
   if (self.__inst is None):
    _1=0
    _2=numpy.zeros(((int((_0).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
    _1 = fragments._c_closure_272(_0,self.__ptrb,_1,_2) # src/fusion/Expr.mbi:1909:11-1913:12
    _1 = numpy.int64(_1) # postprocess
    _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
    _4=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
    _5=None
    for _6 in range(0,int((_0).shape[0])):
     _7=_2[_6]
     _8=(_2[(_6 + 1)] - _7)
     mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(self.__subj,self.__ptrb[_0[_6]],_3,_7,_8)
     mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self.__cof_v,self.__ptrb[_0[_6]],_4,_7,_8)
    if (self.__bfix is not None):
     _5 = numpy.array([self.__bfix[_0[_9]] for _9 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64))
    _10=None
    _11=mosek.fusion.Set._make_I(int((_0).shape[0]))
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_2,self.__x,_3,_4,_5,_11,_10))
   else:
    _12=numpy.array([_13 for _13 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Sort._argsort__3J_3J(_12,_0)
    _14=0
    _15=0
    _14,_15 = fragments._c_closure_273(_0,self.__inst,_12,self.__ptrb,_14,_15) # src/fusion/Expr.mbi:1942:11-1953:12
    _14 = numpy.int32(_14) # postprocess
    _15 = numpy.int64(_15) # postprocess
    _16=numpy.zeros((_14,), dtype=numpy.dtype(numpy.int64))
    _17=numpy.zeros(((_14 + 1),), dtype=numpy.dtype(numpy.int64))
    _18=numpy.zeros((_15,), dtype=numpy.dtype(numpy.int64))
    _19=numpy.zeros((_15,), dtype=numpy.dtype(numpy.float64))
    _20=None
    _21=mosek.fusion.Set._make_I(int((_0).shape[0]))
    _22=numpy.array([(- 1) for _23 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_274(_0,self.__inst,_12,_22) # src/fusion/Expr.mbi:1963:11-1971:12
    _24=0
    for _25 in range(0,int((_22).shape[0])):
     if (_22[_24] >= 0):
      _26=(self.__ptrb[(_22[_24] + 1)] - self.__ptrb[_22[_25]])
      _17[(_24 + 1)] += (_17[_24] + _26)
      _16[_24] = _25
      mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(self.__subj,self.__ptrb[_22[_25]],_18,_17[_24],_26)
      mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self.__cof_v,self.__ptrb[_22[_25]],_19,_17[_24],_26)
      _24 += 1
    if (self.__bfix is not None):
     _20 = numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
     _27=0
     _27 = fragments._c_closure_275(self.__bfix,_27,_20,_22) # src/fusion/Expr.mbi:1993:13-1998:16
     _27 = numpy.int32(_27) # postprocess
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_17,self.__x,_18,_19,_20,_21,_16))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Expression_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Expr._stack__3_3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Expression_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None):
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    _2=_0[_1]
    if (_2 is None):
     raise ValueError("Arguments for stack may not be null")
    for _3 in range(0,int((_2).shape[0])):
     if (_2[_3] is None):
      raise ValueError("Arguments for stack may not be null")
   _4=numpy.array([mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(_0[_5],1) for _5 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(_4,0))
  @staticmethod
  def _match_vstack_DDD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_DDD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_DDD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DDD(numpy.float64(__0),numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _vstack_DDD(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_DDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_DDLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Variable_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _vstack_DDLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_DDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Expression_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _vstack_DDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _vstack_DLmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_(),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2DD(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_(),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1,_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DD(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_(),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Variable_2(numpy.float64(__0),_1)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2D(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2D(_0,numpy.float64(__1))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2D(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_()], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._vstack__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Expression_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None):
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1] is None):
     raise ValueError("Arguments for vstack may not be null")
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   if ((_0 is None) or ((_1 is None) or (_2 is None))):
    raise ValueError("Arguments e1, e2 and e3 may not be null")
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_(),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DD(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1,_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_(),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2DD(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_(),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _hstack_DLmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_DDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Expression_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _hstack_DDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_DDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_DDLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Variable_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _hstack_DDLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),_1._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2D(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Variable_2D(_0,numpy.float64(__1))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2D(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0._asExpr_(),mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Variable_2(numpy.float64(__0),_1)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1._asExpr_()], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._hstack__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Expression_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None):
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1] is None):
     raise ValueError("Arguments for hstack may not be null")
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(_0,1))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2,_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(numpy.int32(__0),_1,_2,numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2,mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2._asExpr_(),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2._asExpr_(),_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(numpy.int32(__0),_1,_2,numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2._asExpr_(),mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(numpy.int32(__0),_1,numpy.float64(__2),_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(numpy.int32(__0),_1,numpy.float64(__2),_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2),_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DD(numpy.int32(__0),_1,numpy.float64(__2),numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DD(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2),mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2,_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(numpy.int32(__0),_1,_2,numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2,mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2._asExpr_(),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2._asExpr_(),_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(numpy.int32(__0),_1,_2,numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2._asExpr_(),mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(numpy.int32(__0),_1,numpy.float64(__2),_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(numpy.int32(__0),_1,numpy.float64(__2),_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2DLmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2),_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2DD(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2DD(numpy.int32(__0),_1,numpy.float64(__2),numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2DD(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2),mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),_2,_3)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),numpy.float64(__1),_2,_3)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2,_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2D(numpy.int32(__0),numpy.float64(__1),_2,numpy.float64(__3))
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2,mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),_2,_3)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_(),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),numpy.float64(__1),_2,_3)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_(),_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Variable_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Variable_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2D(numpy.int32(__0),numpy.float64(__1),_2,numpy.float64(__3))
  @staticmethod
  def _stack_IDLmosek_4fusion_4Variable_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_(),mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_IDDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_IDDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),numpy.float64(__2),_3)
  @staticmethod
  def _stack_IDDLmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_IDDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_IDDLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Variable_2(numpy.int32(__0),numpy.float64(__1),numpy.float64(__2),_3)
  @staticmethod
  def _stack_IDDLmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2),_3._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),_2._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Variable_2D(numpy.int32(__0),_1,numpy.float64(__2))
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1._asExpr_(),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),_2)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Variable_2(numpy.int32(__0),numpy.float64(__1),_2)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2._asExpr_()], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2D(numpy.int32(__0),_1,numpy.float64(__2))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_I_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_stack_I_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _stack_alt_I_3Lmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._stack_I_3Lmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack_I_3Lmosek_4fusion_4Expression_2(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(_1,_0))
  @staticmethod
  def _stack_1_alt__3Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Expr._stack_1__3Lmosek_4fusion_4Expression_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack_1__3Lmosek_4fusion_4Expression_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((_0).shape[0])==0):
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(object)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make_I(0),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),1))
   if (int((_0).shape[0])==1):
    return (_0[0])
   _2=(_1 + 1)
   for _3 in range(0,int((_0).shape[0])):
    if ((_0[_3]._shape_().nd) > _2):
     _2 = (_0[_3]._shape_().nd)
   _4=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(object))
   _5=_0[0]
   _6=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _7=True
   _8=False
   _9=None
   _10=0
   _11=None
   if ((_5._shape_().nd) < _1):
    raise mosek_fusion_LengthError._ctor_S("Invalid stack dimension")
   for _12 in range(0,int((_4).shape[0])):
    _13=_0[_12]
    for _14 in range(0,(_13._shape_().nd)):
     if ((_1!=_14) and (_5._shape_()._dim_I(_14)!=_13._shape_()._dim_I(_14))):
      raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
    _6[_1] = (_6[_1] + _13._shape_()._dim_I(_1))
    _4[_12] = _0[_12]._eval_()
    _10 = (_10 + int(((_4[_12].x)).shape[0]))
    _7 = (_7 and ((_4[_12].inst) is None))
    _8 = (_8 or ((_4[_12].bfix) is not None))
   _15=numpy.zeros((int((_4).shape[0]),), dtype=numpy.dtype(numpy.int64))
   _11 = numpy.zeros((_10,), dtype=numpy.dtype(object))
   _16=0
   for _17 in range(0,int((_4).shape[0])):
    for _18 in range(0,int(((_4[_17].x)).shape[0])):
     _11[_16] = (_4[_17].x)[_18]
     _16 += 1
   for _19 in range(1,int((_4).shape[0])):
    _15[_19] = _15[(_19 - 1)]
    for _20 in range(0,int(((_4[(_19 - 1)].x)).shape[0])):
     _15[_19] = (_15[_19] + (_4[(_19 - 1)].x)[_20]._size_())
   for _21 in range(0,_2):
    if (_21!=_1):
     _6[_21] = _5._shape_()._dim_I(_21)
   _22=mosek_fusion_NDSet._ctor__3I(_6)
   _23=(_4[0].nnz)
   _24=(int(((_4[0].ptrb)).shape[0]) - 1)
   for _25 in range(1,int((_0).shape[0])):
    _23 = (_23 + (_4[_25].nnz))
    _24 = ((_24 + int(((_4[_25].ptrb)).shape[0])) - 1)
   _26=(None if ((not _8) ) else numpy.zeros((_24,), dtype=numpy.dtype(numpy.float64)))
   _27=_monty.initJaggedArray([(_4[_28].ptrb) for _28 in range(0,int((_4).shape[0]))], 1)
   _29=_monty.initJaggedArray([(_4[_30].subj) for _30 in range(0,int((_4).shape[0]))], 1)
   _31=_monty.initJaggedArray([(_4[_32].cof) for _32 in range(0,int((_4).shape[0]))], 1)
   _33=_monty.initJaggedArray([(_4[_34].bfix) for _34 in range(0,int((_4).shape[0]))], 1)
   _35=_monty.initJaggedArray([(_4[_36].inst) for _36 in range(0,int((_4).shape[0]))], 1)
   _37=numpy.array([(_4[_38].nnz) for _38 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _39=numpy.array([((_4[_40].shape)._size) for _40 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int64))
   if (_1==0):
    _41=numpy.zeros(((_24 + 1),), dtype=numpy.dtype(numpy.int64))
    _42=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int64))
    _43=numpy.zeros((_23,), dtype=numpy.dtype(numpy.float64))
    _44=(None if (_7 ) else numpy.zeros((_24,), dtype=numpy.dtype(numpy.int64)))
    _45=0
    _46=0
    _47=0
    for _48 in range(0,int((_27).shape[0])):
     mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_31[_48],0,_43,_46,_37[_48])
     if (_33[_48] is not None):
      mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_33[_48],0,_26,_45,int((_33[_48]).shape[0]))
     fragments._c_closure_276(_27,_48,_46,_45,_41) # src/fusion/Expr.mbi:1513:13-1514:53
     fragments._c_closure_277(_37,_29,_48,_46,_42,_15) # src/fusion/Expr.mbi:1515:13-1516:53
     _45 = fragments._c_closure_278(_47,_35,_27,_48,_44,_7,_45) # src/fusion/Expr.mbi:1518:13-1534:42
     _45 = numpy.int64(_45) # postprocess
     _47 += _39[_48]
     _46 += _37[_48]
    _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_41,_11,_42,_43,_26,_22,_44)
   else:
    _49=numpy.zeros(((_24 + 1),), dtype=numpy.dtype(numpy.int64))
    _50=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int64))
    _51=numpy.zeros((_23,), dtype=numpy.dtype(numpy.float64))
    _52=None
    _53=0
    _54=0
    _55=0
    _56=1
    _56 = fragments._c_closure_279(_1,_56,_6) # src/fusion/Expr.mbi:1565:11-1566:34
    _56 = numpy.int32(_56) # postprocess
    _57=1
    _57 = fragments._c_closure_280(_57,_1,_6) # src/fusion/Expr.mbi:1568:11-1569:36
    _57 = numpy.int32(_57) # postprocess
    _58=_57
    _57 = (_57 * _6[_1])
    _59=numpy.array([(_58 * (_4[_60].shape)._dim_I(_1)) for _60 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int32))
    _61=numpy.zeros((int((_4).shape[0]),), dtype=numpy.dtype(numpy.int64))
    if _7:
     for _62 in range(0,_56):
      for _63 in range(0,int((_4).shape[0])):
       _64=((_4[_63].ptrb)[(_61[_63] + _59[_63])] - (_4[_63].ptrb)[_61[_63]])
       mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_63].cof),(_4[_63].ptrb)[_61[_63]],_51,_54,_64)
       if ((_4[_63].bfix) is not None):
        mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_63].bfix),_61[_63],_26,_53,numpy.int64(_59[_63]))
       _65=(_4[_63].ptrb)[_61[_63]]
       for _66 in range(0,_64):
        _50[(_54 + _66)] = ((_4[_63].subj)[(_65 + _66)] + _15[_63])
       for _67 in range(0,_59[_63]):
        _49[((_53 + _67) + 1)] = (((_4[_63].ptrb)[((_61[_63] + _67) + 1)] - (_4[_63].ptrb)[(_61[_63] + _67)]) + _49[(_53 + _67)])
       _54 = (_54 + _64)
       _53 = (_53 + _59[_63])
       _55 = (_55 + ((_4[_63].shape)._size))
       _61[_63] = (_61[_63] + _59[_63])
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_49,_11,_50,_51,_26,_22,_52)
    else:
     _68=numpy.zeros((int((_4).shape[0]),), dtype=numpy.dtype(numpy.int64))
     _52 = numpy.zeros((_24,), dtype=numpy.dtype(numpy.int64))
     for _69 in range(0,_56):
      for _70 in range(0,int((_4).shape[0])):
       if (((_4[_70].inst) is None) or ((((_4[_70].shape)._size)==int(((_4[_70].inst)).shape[0])) and (int(((_4[_70].inst)).shape[0]) > 0))):
        _71=((_4[_70].ptrb)[(_61[_70] + _59[_70])] - (_4[_70].ptrb)[_61[_70]])
        mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_70].cof),(_4[_70].ptrb)[_61[_70]],_51,_54,_71)
        if ((_4[_70].bfix) is not None):
         mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_70].bfix),_61[_70],_26,_53,numpy.int64(_59[_70]))
        _72=(_4[_70].ptrb)[_61[_70]]
        for _73 in range(0,_71):
         _50[(_54 + _73)] = ((_4[_70].subj)[(_72 + _73)] + _15[_70])
        for _74 in range(0,_59[_70]):
         _49[((_53 + _74) + 1)] = (((_4[_70].ptrb)[((_61[_70] + _74) + 1)] - (_4[_70].ptrb)[(_61[_70] + _74)]) + _49[_53])
        fragments._c_closure_281(_55,_59,_70,_52,_53) # src/fusion/Expr.mbi:1640:19-1641:44
        _54 = (_54 + _71)
        _53 = (_53 + _59[_70])
        _55 = (_55 + _59[_70])
        _61[_70] = (_61[_70] + _59[_70])
       elif (int(((_4[_70].inst)).shape[0]) > 0):
        _75=0
        _76=0
        while ((_4[_70].inst)[(_61[_70] + _76)] < (_68[_70] + _59[_70])):
         _76 += 1
        _75 = _76
        _77=((_4[_70].ptrb)[(_61[_70] + _75)] - (_4[_70].ptrb)[_61[_70]])
        mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_70].cof),(_4[_70].ptrb)[_61[_70]],_51,_54,_77)
        if ((_4[_70].bfix) is not None):
         mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_70].bfix),_61[_70],_26,_53,_75)
        _78=(_4[_70].ptrb)[_61[_70]]
        for _79 in range(0,_77):
         _50[(_54 + _79)] = ((_4[_70].subj)[(_78 + _79)] + _15[_70])
        for _80 in range(0,_75):
         _49[((_53 + _80) + 1)] = (((_4[_70].ptrb)[((_61[_70] + _80) + 1)] - (_4[_70].ptrb)[(_61[_70] + _80)]) + _49[(_53 + _80)])
        _81=(_59[_70] * _69)
        for _82 in range(0,_75):
         _52[(_53 + _82)] = (((_4[_70].inst)[_82] - _81) + _55)
        _54 += _77
        _53 += _75
        _55 += _59[_70]
        _61[_70] += _75
        _68[_70] += _59[_70]
       else:
        pass
     _9 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_49,_11,_50,_51,_26,_22,_52)
   return (_9)
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   if (_1 <= 0):
    raise mosek_fusion_DimensionError._ctor_S("Cannot repeat Expression 0 or less times")
   return (mosek.fusion.Expr._stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0 for _3 in range(0,_1)], dtype=numpy.dtype(object)),_2))
  @staticmethod
  def _match_add__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_add__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _add_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._add__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3Lmosek_4fusion_4Expression_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((_0).shape[0])==0):
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(object)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make_I(0),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),1))
   _1=None
   if (_0 is None):
    raise ValueError("Argument exps may not be null")
   if ((int((_0).shape[0]) > 0) and (_0[0] is None)):
    raise ValueError("Argument exps may not contain null")
   _2=(_0[0]._shape_()._size)
   _3=(_0[0]._shape_() if ((_0[0]._shape_() is not None) ) else mosek.fusion.Set._make_I(numpy.int32(_2)))
   _4=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(object))
   _5=0
   _6=True
   _7=False
   _8=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   _10=0
   for _11 in range(0,int((_0).shape[0])):
    if (_0[_11] is None):
     raise ValueError("Argument exps may not contain null")
    _4[_11] = _0[_11]._eval_()
    if (not (_4[_11].shape)._compare_Lmosek_4fusion_4Set_2(_3)):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
    if ((_4[_11].bfix) is not None):
     _7 = True
    _5 = (_5 + (_4[_11].nnz))
    _6 = (_6 and ((_4[_11].inst) is None))
    _10 = (_10 + int(((_4[_11].x)).shape[0]))
   _9 = numpy.zeros((_10,), dtype=numpy.dtype(object))
   _12=0
   for _13 in range(0,int((_4).shape[0])):
    for _14 in range(0,int(((_4[_13].x)).shape[0])):
     _9[_12] = (_4[_13].x)[_14]
     _12 += 1
   for _15 in range(1,int((_0).shape[0])):
    _8[_15] = _8[(_15 - 1)]
    for _16 in range(0,int(((_4[(_15 - 1)].x)).shape[0])):
     _8[_15] = (_8[_15] + (_4[(_15 - 1)].x)[_16]._size_())
   if _6:
    _17=numpy.zeros(((_2 + 1),), dtype=numpy.dtype(numpy.int64))
    _18=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    _19=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
    _20=None
    _21=None
    for _22 in range(0,_2):
     _17[(_22 + 1)] = _17[_22]
     for _23 in range(0,int((_4).shape[0])):
      _24=((_4[_23].ptrb)[(_22 + 1)] - (_4[_23].ptrb)[_22])
      mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_23].cof),(_4[_23].ptrb)[_22],_19,_17[(_22 + 1)],_24)
      for _25 in range(0,_24):
       _18[(_17[(_22 + 1)] + _25)] = ((_4[_23].subj)[((_4[_23].ptrb)[_22] + _25)] + _8[_23])
      _17[(_22 + 1)] += _24
    if _7:
     _20 = numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
     for _26 in range(0,_2):
      for _27 in range(0,int((_4).shape[0])):
       if ((_4[_27].bfix) is not None):
        _20[_26] += (_4[_27].bfix)[_26]
    _1 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_17,_9,_18,_19,_20,_3,_21)
   else:
    _28=numpy.zeros((int((_4).shape[0]),), dtype=numpy.dtype(numpy.int32))
    _29=numpy.zeros((int((_4).shape[0]),), dtype=numpy.dtype(numpy.int32))
    _30=numpy.zeros((int((_4).shape[0]),), dtype=numpy.dtype(object))
    for _31 in range(0,int((_4).shape[0])):
     if ((_4[_31].inst) is not None):
      _30[_31] = (_4[_31].inst)
     else:
      _30[_31] = mosek.fusion.Utils.Tools._range_J((int(((_4[_31].ptrb)).shape[0]) - 1))
     _29[_31] = int((_30[_31]).shape[0])
    _32=0
    _33=mosek.fusion.Utils.Tools._range_I(int((_4).shape[0]))
    _34=int((_4).shape[0])
    while (_34 > 0):
     _35=_30[_33[0]][_28[_33[0]]]
     _35 = fragments._c_closure_282(_28,_30,_34,_35,_33) # src/fusion/Expr.mbi:1279:15-119
     _35 = numpy.int64(_35) # postprocess
     _32 += 1
     for _36 in range(0,_34):
      if (_30[_33[_36]][_28[_33[_36]]]==_35):
       _28[_33[_36]] += 1
     _34 = fragments._c_closure_283(_29,_28,_34,_33) # src/fusion/Expr.mbi:1285:15-1294:23
     _34 = numpy.int32(_34) # postprocess
    _37=numpy.zeros((_32,), dtype=numpy.dtype(numpy.int64))
    _38=numpy.zeros(((_32 + 1),), dtype=numpy.dtype(numpy.int64))
    _39=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
    _40=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    _41=None
    fragments._c_closure_284(_28) # src/fusion/Expr.mbi:1305:13-50
    _42=0
    _43=mosek.fusion.Utils.Tools._range_I(int((_4).shape[0]))
    _44=int((_4).shape[0])
    while (_44 > 0):
     _45=_30[_43[0]][_28[_43[0]]]
     _45 = fragments._c_closure_285(_28,_30,_44,_45,_43) # src/fusion/Expr.mbi:1312:15-119
     _45 = numpy.int64(_45) # postprocess
     _37[_42] = _45
     _38[(_42 + 1)] = _38[_42]
     for _46 in range(0,_44):
      if (_30[_43[_46]][_28[_43[_46]]]==_45):
       _47=_43[_46]
       _48=(_4[_47].ptrb)[_28[_47]]
       _49=((_4[_47].ptrb)[(_28[_47] + 1)] - _48)
       mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ((_4[_47].cof),_48,_39,_38[(_42 + 1)],_49)
       for _50 in range(0,_49):
        _40[(_38[(_42 + 1)] + _50)] = ((_4[_47].subj)[(_48 + _50)] + _8[_47])
       _38[(_42 + 1)] = (_38[(_42 + 1)] + _49)
       _28[_47] += 1
     _44 = fragments._c_closure_286(_29,_28,_44,_43) # src/fusion/Expr.mbi:1329:15-1338:23
     _44 = numpy.int32(_44) # postprocess
     _42 += 1
    if _7:
     fragments._c_closure_287(_28) # src/fusion/Expr.mbi:1346:13-50
     _51=0
     _52=0
     for _53 in range(0,int((_4).shape[0])):
      if ((_4[_53].bfix) is not None):
       _52 += 1
     _54=numpy.zeros((_52,), dtype=numpy.dtype(numpy.int64))
     _55=0
     _56=0
     while (_56 < _52):
      if ((_4[_55].bfix) is not None):
       _54[_56] = _55
       _56 += 1
      _55 += 1
     _41 = numpy.zeros((_32,), dtype=numpy.dtype(numpy.float64))
     while (_52 > 0):
      _57=_30[_54[0]][_28[_54[0]]]
      _57 = fragments._c_closure_288(_28,_30,_52,_57,_54) # src/fusion/Expr.mbi:1355:15-119
      _57 = numpy.int64(_57) # postprocess
      for _58 in range(0,_52):
       if (_30[_54[_58]][_28[_54[_58]]]==_57):
        _41[_51] = (_41[_51] + (_4[_54[_58]].bfix)[_28[_54[_58]]])
        _28[_54[_58]] += 1
      _52 = fragments._c_closure_289(_29,_28,_52,_54) # src/fusion/Expr.mbi:1363:15-1372:23
      _52 = numpy.int32(_52) # postprocess
      _51 += 1
    if (_32==(_3._size)):
     _37 = None
    _1 = mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_38,_9,_40,_39,_41,_3,_37)
   return (_1)
  @staticmethod
  def _match_add__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_add__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _add_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._add__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None):
    raise ValueError("Argument vs may not be null")
   if (int((_0).shape[0])==0):
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(numpy.array([0], dtype=numpy.dtype(numpy.int64)),None,numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make_I(0),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),1))
   if ((int((_0).shape[0]) > 0) and (_0[0] is None)):
    raise ValueError("Argument vs may contain null")
   _1=_0[0]._shape_()
   _2=(_1.nd)
   _3=(_1._size)
   _4=(_1._size)
   for _5 in range(1,int((_0).shape[0])):
    if (_0[_5] is None):
     raise ValueError("Argument vs may not contain null")
    elif (not _1._compare_Lmosek_4fusion_4Set_2(_0[_5]._shape_())):
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _6=(_3 * int((_0).shape[0]))
   _7=mosek.fusion.Utils.Tools._range_JJJ(0,(_6 + int((_0).shape[0])),int((_0).shape[0]))
   _8=numpy.array([(_9 + (_10 * _3)) for _9 in range(0,_3) for _10 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))
   _11=numpy.array([1 for _12 in range(0,_6)], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_7,_0,_8,_11,None,_1,None,1))
  @staticmethod
  def __add_1_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,numpy.float64(__1),_2,numpy.float64(__3))
  @staticmethod
  def __add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   if ((_0._getModel_() is not None) and ((_2._getModel_() is not None) and (_0._getModel_() is not _2._getModel_()))):
    _4=mosek.fusion.Utils.StringBuffer()
    _5=(_0._getModel_()._getName_() if ((int(len(_0._getModel_()._getName_())) > 0) ) else "?")
    _6=(_2._getModel_()._getName_() if ((int(len(_2._getModel_()._getName_())) > 0) ) else "?")
    _4._a_S("Operands belong to different models: '")._a_S(_5)._a_S("' and '")._a_S(_6)._a_S("'")
    raise mosek_fusion_ModelError._ctor_S(_4._toString_())
   _7=((_0._shape_().nd) if (((_0._shape_().nd) >= (_2._shape_().nd)) ) else (_2._shape_().nd))
   for _8 in range(0,_7):
    if (_0._shape_()._dim_I(_8)!=_2._shape_()._dim_I(_8)):
     raise mosek_fusion_DimensionError._ctor_S("Dimensions mismatch")
   _9=_0._eval_()
   _10=_2._eval_()
   _11=(((_9.inst) is not None) and ((_10.inst) is not None))
   _12=(_9.shape)
   _13=(_9.inst)
   _14=(_10.inst)
   if (_13 is None):
    _13 = mosek.fusion.Utils.Tools._range_J((_12._size))
   if (_14 is None):
    _14 = mosek.fusion.Utils.Tools._range_J((_12._size))
   _15=0
   _15 = fragments._c_closure_290(_13,_14,_15) # src/fusion/Expr.mbi:979:9-989:10
   _15 = numpy.int32(_15) # postprocess
   _16=numpy.zeros((_15,), dtype=numpy.dtype(numpy.int64))
   _17=0
   for _18 in range(0,int(((_9.x)).shape[0])):
    _17 = (_17 + (_9.x)[_18]._size_())
   _19=numpy.zeros(((_15 + 1),), dtype=numpy.dtype(numpy.int64))
   _20=numpy.zeros(((int(((_9.subj)).shape[0]) + int(((_10.subj)).shape[0])),), dtype=numpy.dtype(numpy.int64))
   _21=numpy.zeros(((int(((_9.subj)).shape[0]) + int(((_10.subj)).shape[0])),), dtype=numpy.dtype(numpy.float64))
   _22=mosek.fusion.Expr.__varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2((_9.x),(_10.x))
   _23=(None if ((((_9.bfix) is None) and ((_10.bfix) is None)) ) else numpy.zeros((_15,), dtype=numpy.dtype(numpy.float64)))
   _24=(_9.ptrb)
   _25=(_9.subj)
   _26=(_9.cof)
   _27=(_9.bfix)
   _28=(_10.ptrb)
   _29=(_10.subj)
   _30=(_10.cof)
   _31=(_10.bfix)
   _32=0
   _33=0
   _34=0
   _35=0
   while ((_32 < int((_13).shape[0])) and (_33 < int((_14).shape[0]))):
    if (_13[_32] < _14[_33]):
     _36=(_24[(_32 + 1)] - _24[_32])
     mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(_25,_24[_32],_20,_35,_36)
     fragments._c_closure_291(_21,_26,_24,_32,_1,_36,_35) # src/fusion/Expr.mbi:1022:17-79
     _35 = (_35 + _36)
     _16[_34] = _13[_32]
     _19[(_34 + 1)] = (_19[_34] + _36)
     _32 += 1
     _34 += 1
    elif (_13[_32] > _14[_33]):
     _34,_33,_35 = fragments._c_closure_292(_21,_30,_28,_29,_34,_33,_16,_14,_3,_35,_19,_20,_17) # src/fusion/Expr.mbi:1029:15-1037:16
     _34 = numpy.int32(_34) # postprocess
     _33 = numpy.int32(_33) # postprocess
     _35 = numpy.int64(_35) # postprocess
    else:
     _37=(_24[(_32 + 1)] - _24[_32])
     mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(_25,_24[_32],_20,_35,_37)
     fragments._c_closure_293(_21,_26,_24,_32,_1,_37,_35) # src/fusion/Expr.mbi:1042:17-81
     _35 = (_35 + _37)
     _38=(_28[(_33 + 1)] - _28[_33])
     fragments._c_closure_294(_28,_29,_33,_38,_35,_20,_17) # src/fusion/Expr.mbi:1046:17-87
     fragments._c_closure_295(_21,_30,_28,_33,_3,_38,_35) # src/fusion/Expr.mbi:1047:17-81
     _35 = (_35 + _38)
     _16[_34] = _13[_32]
     _19[(_34 + 1)] = ((_19[_34] + _37) + _38)
     _32 += 1
     _33 += 1
     _34 += 1
   while (_32 < int((_13).shape[0])):
    _39=(_24[(_32 + 1)] - _24[_32])
    mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(_25,_24[_32],_20,_35,_39)
    fragments._c_closure_296(_21,_26,_24,_32,_1,_39,_35) # src/fusion/Expr.mbi:1058:15-77
    _35 = (_35 + _39)
    _16[_34] = _13[_32]
    _19[(_34 + 1)] = (_19[_34] + _39)
    _32 += 1
    _34 += 1
   _34,_33,_35 = fragments._c_closure_297(_21,_30,_28,_29,_34,_33,_16,_14,_3,_35,_19,_20,_17) # src/fusion/Expr.mbi:1064:13-1073:14
   _34 = numpy.int32(_34) # postprocess
   _33 = numpy.int32(_33) # postprocess
   _35 = numpy.int64(_35) # postprocess
   fragments._c_closure_298(_23,_27,_31,_13,_14,_1,_3) # src/fusion/Expr.mbi:1076:13-1108:14
   return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_19,_22,_20,_21,_23,_12,(None if ((int((_16).shape[0])==(_12._size)) ) else _16)))
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   _0=self
   if ((_0._shape_().nd) > 2):
    raise mosek_fusion_DimensionError._ctor_S("Wrong dimensions for transpose")
   if ((_0._shape_().nd)==1):
    return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,mosek.fusion.Set._make_II(1,_0._shape_()._dim_I(0))))
   elif (_0._shape_()._dim_I(0)==1):
    return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,mosek.fusion.Set._make_II(1,_0._shape_()._dim_I(1))))
   elif (_0._shape_()._dim_I(1)==1):
    return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Set_2(_0,mosek.fusion.Set._make_I(_0._shape_()._dim_I(0))))
   _1=_0._eval_()
   _2=(_1.inst)
   _3=(_1.bfix)
   _4=(_1.ptrb)
   _5=(_1.subj)
   _6=(_1.cof)
   if ((_1.inst) is not None):
    _7=(_1.shape)._dim_I(0)
    _8=(_1.shape)._dim_I(1)
    _9=int(((_1.inst)).shape[0])
    _10=int(((_1.subj)).shape[0])
    _11=(None if (((_1.bfix) is None) ) else numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64)))
    _12=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
    _13=numpy.zeros(((_9 + 1),), dtype=numpy.dtype(numpy.int64))
    _14=numpy.zeros((_10,), dtype=numpy.dtype(numpy.int64))
    _15=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    _16=mosek.fusion.Set._make_II(_8,_7)
    _17=(_1.x)
    _18=numpy.array([(_2[_19] // _8) for _19 in range(0,_9)], dtype=numpy.dtype(numpy.int64))
    _20=numpy.array([(_2[_21] % _8) for _21 in range(0,_9)], dtype=numpy.dtype(numpy.int64))
    _22=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
    _23=numpy.zeros(((_9 + 1),), dtype=numpy.dtype(numpy.int64))
    for _24 in range(0,_9):
     _23[(_20[_24] + 1)] += 1
    fragments._c_closure_299(_9,_23) # src/fusion/Expr.mbi:875:13-51
    for _25 in range(0,_9):
     _22[_23[_20[_25]]] = _25
     _23[_20[_25]] += 1
    fragments._c_closure_300(_3,_9,_22,_11) # src/fusion/Expr.mbi:878:13-79
    fragments._c_closure_301(_7,_18,_20,_9,_22,_12) # src/fusion/Expr.mbi:879:13-82
    fragments._c_closure_302(_4,_9,_22,_13) # src/fusion/Expr.mbi:880:13-96
    for _26 in range(0,_9):
     mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(_5,_4[_22[_26]],_14,_13[_26],(_13[(_26 + 1)] - _13[_26]))
     mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_6,_4[_22[_26]],_15,_13[_26],(_13[(_26 + 1)] - _13[_26]))
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_13,_17,_14,_15,_11,_16,_12,1))
   else:
    _27=(_1.shape)._dim_I(0)
    _28=(_1.shape)._dim_I(1)
    _29=numpy.zeros((int(((_1.ptrb)).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _30=numpy.zeros((int(((_1.subj)).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _31=numpy.zeros((int(((_1.cof)).shape[0]),), dtype=numpy.dtype(numpy.float64))
    _32=(numpy.zeros(((_27 * _28),), dtype=numpy.dtype(numpy.float64)) if ((_3 is not None) ) else None)
    _33=mosek.fusion.Set._make_II(_28,_27)
    for _34 in range(0,_28):
     for _35 in range(0,_27):
      _36=((_35 * _28) + _34)
      _37=((_34 * _27) + _35)
      _29[(_37 + 1)] = (_29[_37] + (_4[(_36 + 1)] - _4[_36]))
      mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(_5,_4[_36],_30,_29[_37],(_4[(_36 + 1)] - _4[_36]))
      mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_6,_4[_36],_31,_29[_37],(_4[(_36 + 1)] - _4[_36]))
    fragments._c_closure_303(_27,_28,_3,_32) # src/fusion/Expr.mbi:914:13-926:14
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3JI(_29,(_1.x),_30,_31,_32,_33,None,1))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (int((_0).shape[0])!=int((_1).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Length firsta and lasta do not match")
   if (int((_0).shape[0])!=(self.__shape_p.nd)):
    raise mosek_fusion_LengthError._ctor_S("Length firsta and lasta do not match shape")
   for _2 in range(0,int((_0).shape[0])):
    if ((_0[_2] < 0) or ((_0[_2] > _1[_2]) or (_1[_2] > self.__shape_p._dim_I(_2)))):
     raise mosek_fusion_IndexError._ctor_S("Index is invalid or out of bounds")
   _3=numpy.array([(_1[_4] - _0[_4]) for _4 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _5=mosek_fusion_NDSet._ctor__3I(_3)
   if (self.__inst is None):
    _6=1
    _6 = fragments._c_closure_304(_0,_1,_6) # src/fusion/Expr.mbi:727:31-107
    _6 = numpy.int64(_6) # postprocess
    _7=self.__shape_p._linearidx__3I(_0)
    _8=mosek_fusion_IndexCounter._ctor_J_3ILmosek_4fusion_4Set_2(_7,_3,self.__shape_p)
    _9=0
    for _10 in range(0,_6):
     _11=_8._get_()
     _9 = (_9 + (self.__ptrb[(_11 + 1)] - self.__ptrb[_11]))
     _8._inc_()
    _12=numpy.zeros(((_6 + 1),), dtype=numpy.dtype(numpy.int64))
    _13=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
    _14=numpy.zeros((_9,), dtype=numpy.dtype(numpy.float64))
    _8._reset_()
    for _15 in range(0,_6):
     _16=_8._get_()
     mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(self.__subj,self.__ptrb[_16],_13,_12[_15],(self.__ptrb[(_16 + 1)] - self.__ptrb[_16]))
     mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self.__cof_v,self.__ptrb[_16],_14,_12[_15],(self.__ptrb[(_16 + 1)] - self.__ptrb[_16]))
     _12[(_15 + 1)] = (_12[_15] + (self.__ptrb[(_16 + 1)] - self.__ptrb[_16]))
     _8._inc_()
    _17=None
    if (self.__bfix is not None):
     _8._reset_()
     for _18 in range(0,_6):
      _17[_18] = self.__bfix[_8._get_()]
      _8._inc_()
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_12,self.__x,_13,_14,_17,_5,None))
   else:
    _19=0
    _20=0
    for _21 in range(0,int((self.__inst).shape[0])):
     _22=self.__shape_p._idxtokey_J(self.__inst[_21])
     _23=True
     for _24 in range(0,(self.__shape_p.nd)):
      _23 = (_23 and ((_0[_24] <= _22[_24]) and (_22[_24] < _1[_24])))
     if _23:
      _19 += 1
      _20 = (_20 + (self.__ptrb[(_21 + 1)] - self.__ptrb[_21]))
    _25=numpy.zeros(((_19 + 1),), dtype=numpy.dtype(numpy.int64))
    _26=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    _27=numpy.zeros((_20,), dtype=numpy.dtype(numpy.float64))
    _28=None
    _29=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int64))
    _30=0
    for _31 in range(0,int((self.__inst).shape[0])):
     _32=self.__shape_p._idxtokey_J(self.__inst[_31])
     _33=True
     for _34 in range(0,(self.__shape_p.nd)):
      _33 = (_33 and ((_0[_34] <= _32[_34]) and (_32[_34] < _1[_34])))
     if _33:
      mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(self.__subj,self.__ptrb[_31],_26,_25[_30],(self.__ptrb[(_31 + 1)] - self.__ptrb[_31]))
      mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self.__cof_v,self.__ptrb[_31],_27,_25[_30],(self.__ptrb[(_31 + 1)] - self.__ptrb[_31]))
      _25[(_30 + 1)] = ((_25[_30] + self.__ptrb[(_31 + 1)]) - self.__ptrb[_31])
      _29[_30] = _5._linearidx__3I(numpy.array([(_32[_35] - _0[_35]) for _35 in range(0,int((_32).shape[0]))], dtype=numpy.dtype(numpy.int32)))
      _30 += 1
    if (self.__bfix is not None):
     _28 = numpy.zeros((_19,), dtype=numpy.dtype(numpy.float64))
     _36=0
     for _37 in range(0,int((self.__inst).shape[0])):
      _38=self.__shape_p._idxtokey_J(self.__inst[_37])
      _39=True
      for _40 in range(0,(self.__shape_p.nd)):
       _39 = (_39 and ((_0[_40] <= _38[_40]) and (_38[_40] < _1[_40])))
      if _39:
       _28[_36] = self.__bfix[_37]
       _36 += 1
    return (mosek_fusion_Expr._ctor__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_25,self.__x,_26,_27,_28,_5,_29))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.array([(_0[_2] + 1) for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
   return (self._slice__3I_3I(_0,_1))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   return (self._slice__3I_3I(numpy.array([_0], dtype=numpy.dtype(numpy.int32)),numpy.array([(_0 + 1)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (self._slice__3I_3I(numpy.array([_0], dtype=numpy.dtype(numpy.int32)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulElm_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _mulElm__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def _match_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _mulElm__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def _match_mulElm__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulElm_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm__3DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Variable_2(_0,_1))
  @staticmethod
  def _match_mulElm__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_1),_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(mosek.fusion.Matrix._dense__3_5D(_1),_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_dot__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_dot__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _dot_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _dot__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def _match_dot__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _dot__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def _match_dot__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_dot__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _dot_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot__3DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__dot_1__3DLmosek_4fusion_4Variable_2(_0,_1))
  @staticmethod
  def _match_dot__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__dot_1__3DLmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_1),_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__dot_1__3DLmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__dot_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(mosek.fusion.Matrix._dense__3_5D(_1),_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__dot_1__3DLmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt_DLmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_DLmosek_4fusion_4Variable_2(numpy.float64(__0),_1)
  @staticmethod
  def _sub_DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_1._shape_(),_0),1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2D(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2D(_0,numpy.float64(__1))
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_0._shape_(),_1),(- 1.0)))
  @staticmethod
  def _match_sub__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _sub__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3_5D(_0),1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub__3DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3D(_0),1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,mosek.fusion.Expr._constTerm__3_5D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,mosek.fusion.Expr._constTerm__3D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _sub_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_1._shape_(),_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_0._shape_(),_1),(- 1.0)))
  @staticmethod
  def _match_sub__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _sub__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3_5D(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3D(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3_5D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1._asExpr_(),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1,(- 1.0)))
  @staticmethod
  def _match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),1.0,_0._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),1.0,_0._asExpr_(),1.0))
  @staticmethod
  def _match_add_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add_DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt_DLmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_DLmosek_4fusion_4Variable_2(numpy.float64(__0),_1)
  @staticmethod
  def _add_DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_1._shape_(),_0),1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2D(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2D(_0,numpy.float64(__1))
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_0._shape_(),_1),1.0,_0._asExpr_(),1.0))
  @staticmethod
  def _match_add__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _add__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3_5D(_0),1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3D(_0),1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3_5D(_1),1.0,_0._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3D(_1),1.0,_0._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),1.0))
  @staticmethod
  def _match_add_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _add_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_1._shape_(),_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Set_2D(_0._shape_(),_1),1.0))
  @staticmethod
  def _match_add__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _add__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm__3_5D(_0),1.0))
  @staticmethod
  def _match_add__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm__3D(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3_5D(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3D(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0._asExpr_(),1.0,_1,1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1._asExpr_(),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1,1.0))
  @staticmethod
  def _match_shape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_shape_(*args):
    if len(args) != 0: return False
    return True
  def _shape_alt_(self,):
    return self._shape_()
  def _shape_(self,):
   return (self.__shape_p)
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (self.__shape_p)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__model)
  @staticmethod
  def __validateData_alt__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Expr.__validateData__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validateData__3J_3Lmosek_4fusion_4Variable_2_3J_3D_3DLmosek_4fusion_4Set_2_3J(_0,_1,_2,_3,_4,_5,_6):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   _7=(int((_0).shape[0]) - 1)
   _8=_0[(int((_0).shape[0]) - 1)]
   _9=0
   if (_1 is None):
    raise mosek_fusion_ExpressionError._ctor_S("Array v must not be null")
   for _10 in range(0,int((_1).shape[0])):
    if (_1[_10] is None):
     raise mosek_fusion_ExpressionError._ctor_S("Array elements of v must not be null")
    else:
     _9 = (_9 + _1[_10]._size_())
   if (int((_0).shape[0]) < 1):
    raise mosek_fusion_ExpressionError._ctor_S("Array 'ptrb' in expression has wrong size")
   if (_8!=int((_2).shape[0])):
    raise mosek_fusion_ExpressionError._ctor_S("Array 'subj' in expression has wrong size")
   if (_8!=int((_3).shape[0])):
    raise mosek_fusion_ExpressionError._ctor_S("Array 'cof' in expression has wrong size")
   if ((_4 is not None) and (_7!=int((_4).shape[0]))):
    raise mosek_fusion_ExpressionError._ctor_S("Array 'bfix' in expression has wrong length")
   if (_5 is not None):
    if ((_6 is not None) and (int((_6).shape[0]) < (_5._size))):
     _11=_6
     if (int((_11).shape[0])!=(int((_0).shape[0]) - 1)):
      raise mosek_fusion_ExpressionError._ctor_S("Array 'inst' in expression has wrong length")
     if (int((_11).shape[0]) > 0):
      if ((_11[0] < 0) or (_11[0] >= (_5._size))):
       raise mosek_fusion_ExpressionError._ctor_S("Array 'inst' contains an invalid index")
      _12=True
      _13=(_5._size)
      _12 = fragments._c_closure_305(_11,_12,_13) # src/fusion/Expr.mbi:457:15-463:16
      if (not _12):
       raise mosek_fusion_ExpressionError._ctor_S("Invalid array 'inst'")
    else:
     if ((_5._size)!=(int((_0).shape[0]) - 1)):
      raise mosek_fusion_ExpressionError._ctor_S("Array 'ptrb' in expression has wrong length")
   elif (_6 is not None):
    raise mosek_fusion_ExpressionError._ctor_S("Undefined expression shape")
   _14=False
   _15=False
   if (_0[0]!=0):
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'ptrb' argument in expression")
   _16=True
   _16 = fragments._c_closure_306(_7,_0,_16) # src/fusion/Expr.mbi:483:9-484:64
   if (not _16):
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'ptrb' argument in expression")
   _17=True
   _17 = fragments._c_closure_307(_8,_9,_2,_17) # src/fusion/Expr.mbi:489:9-490:69
   if (not _17):
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'subj' argument in expression")
  @staticmethod
  def __extractModel_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr.__extractModel__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __extractModel__3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return ((None if (((_0 is None) or (int((_0).shape[0])==0)) ) else _0[0]._getModel_()))
 return Expr
mosek_fusion_Expr=__mk_mosek_fusion_Expr()
del __mk_mosek_fusion_Expr
#BEFORE CLASS
def __mk_mosek_fusion_FlatExpr():
 class FlatExpr(object):
  __slots__ = ['inst','shape','nnz','cof','x','subj','ptrb','bfix']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4FlatExpr_2(*args): # mosek.fusion.FlatExpr
      self._ctor_init_Lmosek_4fusion_4FlatExpr_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4FlatExpr_2(*args):# mosek.fusion.FlatExpr
      self._ctor_alt_init_Lmosek_4fusion_4FlatExpr_2(*args)
    elif self.__match_ctor__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(*args): # []double,[]int64,[]int64,[]mosek.fusion.Variable,[]double,mosek.fusion.Set,[]int64
      self._ctor_init__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(*args)
    elif self.__match_alt_ctor__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(*args):# []double,[]int64,[]int64,[]mosek.fusion.Variable,[]double,mosek.fusion.Set,[]int64
      self._ctor_alt_init__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FlatExpr.ctor(mosek.fusion.FlatExpr)\n\tmosek.fusion.FlatExpr.ctor(array(double,ndim=1),array(int64,ndim=1),array(int64,ndim=1),array(mosek.fusion.Variable,ndim=1),array(double,ndim=1),mosek.fusion.Set,array(int64,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_FlatExpr._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_FlatExpr._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FlatExpr.toString()')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_FlatExpr._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_FlatExpr._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FlatExpr.size()')
  def __repr__(self): return 'mosek.fusion.FlatExpr'
  @staticmethod
  def _ctor_Lmosek_4fusion_4FlatExpr_2(e):
    o = FlatExpr.__new__(FlatExpr)
    o._ctor_init_Lmosek_4fusion_4FlatExpr_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4FlatExpr_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4FlatExpr_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4FlatExpr_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4FlatExpr_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4FlatExpr_2(self,e):
    self._ctor_init_Lmosek_4fusion_4FlatExpr_2(e)
  def _ctor_init_Lmosek_4fusion_4FlatExpr_2(self,e):
   object.__init__(self)
   if ((e.bfix) is not None):
    self.bfix = mosek.fusion.Utils.Tools._arraycopy__3D((e.bfix))
   else:
    self.bfix = None
   self.ptrb = mosek.fusion.Utils.Tools._arraycopy__3J((e.ptrb))
   self.subj = mosek.fusion.Utils.Tools._arraycopy__3J((e.subj))
   self.x = (e.x)
   self.cof = mosek.fusion.Utils.Tools._arraycopy__3D((e.cof))
   self.nnz = (e.nnz)
   self.shape = (e.shape)
   self.inst = (e.inst)
  @staticmethod
  def _ctor__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(bfix_,ptrb_,subj_,x_,cof_,shape_,inst_):
    o = FlatExpr.__new__(FlatExpr)
    o._ctor_init__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(bfix_,ptrb_,subj_,x_,cof_,shape_,inst_)
    return o
  @staticmethod
  def __match_ctor__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(*args):
    if len(args) != 7: return False
    bfix_,ptrb_,subj_,x_,cof_,shape_,inst_, = args
    return (__arg_match__3D__(bfix_) and __arg_match__3J__(ptrb_) and __arg_match__3J__(subj_) and __arg_match__3Lmosek_4fusion_4Variable_2__(x_) and __arg_match__3D__(cof_) and __arg_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_match__3J__(inst_))
  @staticmethod
  def __match_alt_ctor__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(*args):
    if len(args) != 7: return False
    bfix_,ptrb_,subj_,x_,cof_,shape_,inst_, = args
    return (__arg_alt_match__3D__(bfix_) and __arg_alt_match__3J__(ptrb_) and __arg_alt_match__3J__(subj_) and __arg_alt_match__3Lmosek_4fusion_4Variable_2__(x_) and __arg_alt_match__3D__(cof_) and __arg_alt_match_Lmosek_4fusion_4Set_2__(shape_) and __arg_alt_match__3J__(inst_))
  def _ctor_alt_init__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(self,bfix_,ptrb_,subj_,x_,cof_,shape_,inst_):
    self._ctor_init__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(subj_,dtype=numpy.dtype(numpy.int64)),numpy.array(x_,dtype=numpy.dtype(object)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),shape_,numpy.array(inst_,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init__3D_3J_3J_3Lmosek_4fusion_4Variable_2_3DLmosek_4fusion_4Set_2_3J(self,bfix_,ptrb_,subj_,x_,cof_,shape_,inst_):
   assert bfix_ is None or isinstance(bfix_,numpy.ndarray)
   assert ptrb_ is None or isinstance(ptrb_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert x_ is None or isinstance(x_,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   assert inst_ is None or isinstance(inst_,numpy.ndarray)
   object.__init__(self)
   if ((bfix_ is not None) and (int((bfix_).shape[0])!=(int((ptrb_).shape[0]) - 1))):
    raise mosek_fusion_SparseFormatError._ctor_S("Mismatching lengths of bfix and ptrb")
   if ((cof_ is None) or ((subj_ is None) or (int((subj_).shape[0])!=int((cof_).shape[0])))):
    raise mosek_fusion_SparseFormatError._ctor_S("Mismatching lengths of subj and cof")
   if (shape_ is not None):
    if (inst_ is not None):
     if (int((inst_).shape[0])!=(int((ptrb_).shape[0]) - 1)):
      raise mosek_fusion_SparseFormatError._ctor_S("Mismatching lengths of inst and ptrb")
    elif ((shape_._size)!=(int((ptrb_).shape[0]) - 1)):
     raise mosek_fusion_SparseFormatError._ctor_S("Mismatching shape and ptrb")
   self.bfix = bfix_
   self.ptrb = ptrb_
   self.subj = subj_
   self.x = x_
   self.cof = cof_
   self.nnz = self.ptrb[(int((self.ptrb).shape[0]) - 1)]
   self.shape = shape_
   self.inst = inst_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("FlatExpr:")._lf_()._a_S("+-----------------")._lf_()._a_S("| ptrb[")._a_I(int((self.ptrb).shape[0]))._a_S("] = ")._a__3J(self.ptrb)._lf_()._a_S("| subj[")._a_I(int((self.subj).shape[0]))._a_S("] = ")._a__3J(self.subj)._lf_()._a_S("| cof [")._a_I(int((self.cof).shape[0]))._a_S("] = ")._a__3D(self.cof)._lf_()._a_S("| bfix[")
   if (self.bfix is not None):
    _0._a_I(int((self.bfix).shape[0]))
   _0._a_S("] = ")._a__3D(self.bfix)._lf_()._a_S("| inst[")
   if (self.inst is not None):
    _0._a_I(int((self.inst).shape[0]))
   _0._a_S("] = ")._a__3J(self.inst)._lf_()._a_S("+-----------------")
   return (_0._toString_())
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int32((int((self.ptrb).shape[0]) - 1))
 return FlatExpr
mosek_fusion_FlatExpr=__mk_mosek_fusion_FlatExpr()
del __mk_mosek_fusion_FlatExpr
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricMatrix():
 class SymmetricMatrix(object):
  __slots__ = ['_SymmetricMatrix__nnz','_SymmetricMatrix__scale','_SymmetricMatrix__vval','_SymmetricMatrix__vsubj','_SymmetricMatrix__vsubi','_SymmetricMatrix__uval','_SymmetricMatrix__usubj','_SymmetricMatrix__usubi','_SymmetricMatrix__d1','_SymmetricMatrix__d0']
  @staticmethod
  def antiDiag(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_antiDiag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._antiDiag__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_antiDiag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._antiDiag_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list antiDiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.antiDiag(array(double,ndim=1))')
  def sub(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._sub_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._sub_alt_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    else:
      raise ValueError('Invalid argument list sub('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.sub(mosek.fusion.SymmetricMatrix)')
  @staticmethod
  def diag(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_diag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._diag__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_diag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._diag_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.diag(array(double,ndim=1))')
  @staticmethod
  def rankOne(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_rankOne__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._rankOne__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_rankOne__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._rankOne_alt__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_rankOne_I_3I_3D(*args): # int32,[]int32,[]double
      return mosek_fusion_SymmetricMatrix._rankOne_I_3I_3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_rankOne_I_3I_3D(*args): # int32,[]int32,[]double
      return mosek_fusion_SymmetricMatrix._rankOne_alt_I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list rankOne('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.rankOne(array(double,ndim=1))\n\tmosek.fusion.SymmetricMatrix.rankOne(int32,array(int32,ndim=1),array(double,ndim=1))')
  def mul(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_mul_D(*args): # double
      return self._mul_D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_mul_D(*args): # double
      return self._mul_alt_D(*args)
    else:
      raise ValueError('Invalid argument list mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.mul(double)')
  def add(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_add_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._add_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_add_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._add_alt_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.add(mosek.fusion.SymmetricMatrix)')
  def getdim(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_getdim_(*args): # 
      return self._getdim_(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_getdim_(*args): # 
      return self._getdim_alt_(*args)
    else:
      raise ValueError('Invalid argument list getdim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.getdim()')
  def __repr__(self): return 'mosek.fusion.SymmetricMatrix'
  @staticmethod
  def _ctor_II_3I_3I_3D_3I_3I_3DD(dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
    o = SymmetricMatrix.__new__(SymmetricMatrix)
    o._ctor_init_II_3I_3I_3D_3I_3I_3DD(dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3D_3I_3I_3DD(*args):
    if len(args) != 9: return False
    dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match__3I__(usubi) and __arg_match__3I__(usubj) and __arg_match__3D__(uval) and __arg_match__3I__(vsubi) and __arg_match__3I__(vsubj) and __arg_match__3D__(vval) and __arg_match_D__(scale))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3D_3I_3I_3DD(*args):
    if len(args) != 9: return False
    dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match__3I__(usubi) and __arg_alt_match__3I__(usubj) and __arg_alt_match__3D__(uval) and __arg_alt_match__3I__(vsubi) and __arg_alt_match__3I__(vsubj) and __arg_alt_match__3D__(vval) and __arg_alt_match_D__(scale))
  def _ctor_alt_init_II_3I_3I_3D_3I_3I_3DD(self,dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
    self._ctor_init_II_3I_3I_3D_3I_3I_3DD(numpy.int32(dim0),numpy.int32(dim1),numpy.array(usubi,dtype=numpy.dtype(numpy.int32)),numpy.array(usubj,dtype=numpy.dtype(numpy.int32)),numpy.array(uval,dtype=numpy.dtype(numpy.float64)),numpy.array(vsubi,dtype=numpy.dtype(numpy.int32)),numpy.array(vsubj,dtype=numpy.dtype(numpy.int32)),numpy.array(vval,dtype=numpy.dtype(numpy.float64)),numpy.float64(scale))
  def _ctor_init_II_3I_3I_3D_3I_3I_3DD(self,dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
   assert usubi is None or isinstance(usubi,numpy.ndarray)
   assert usubj is None or isinstance(usubj,numpy.ndarray)
   assert uval is None or isinstance(uval,numpy.ndarray)
   assert vsubi is None or isinstance(vsubi,numpy.ndarray)
   assert vsubj is None or isinstance(vsubj,numpy.ndarray)
   assert vval is None or isinstance(vval,numpy.ndarray)
   object.__init__(self)
   (self.__d0) = dim0
   (self.__d1) = dim1
   (self.__usubi) = usubi
   (self.__usubj) = usubj
   (self.__uval) = uval
   (self.__vsubi) = vsubi
   (self.__vsubj) = vsubj
   (self.__vval) = vval
   (self.__scale) = scale
   self.__nnz = (- 1)
  @staticmethod
  def _match_rankOne_I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_rankOne_I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _rankOne_alt_I_3I_3D(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._rankOne_I_3I_3D(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _rankOne_I_3I_3D(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (int((_1).shape[0])!=int((_2).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching array lengths")
   for _3 in range(0,int((_1).shape[0])):
    if ((_1[_3] < 0) or (_1[_3] >= _0)):
     raise mosek_fusion_LengthError._ctor_S("Invalid index in argument 'sub'")
   _4=numpy.array([_1[_5] for _5 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _6=numpy.array([1 for _7 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _8=numpy.array([_2[_9] for _9 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_0,1,_4,_6,_8,_4,_6,_8,1.0))
  @staticmethod
  def _match_rankOne__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_rankOne__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _rankOne_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._rankOne__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _rankOne__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   _4=numpy.array([1 for _5 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   _6=numpy.array([_0[_7] for _7 in range(0,_1)], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,1,_2,_4,_6,_2,_4,_6,1.0))
  @staticmethod
  def _match_antiDiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_antiDiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _antiDiag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._antiDiag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antiDiag__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,_1,_2,numpy.array([(_1 - _4) for _4 in range(0,_1)], dtype=numpy.dtype(numpy.int32)),numpy.array([_0[_5] for _5 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),_2,_2,numpy.array([1.0 for _6 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),1.0))
  @staticmethod
  def _match_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _diag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._diag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,_1,_2,_2,numpy.array([_0[_4] for _4 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),_2,_2,numpy.array([1.0 for _5 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  def _add_alt_Lmosek_4fusion_4SymmetricMatrix_2(self,_t__0):
    return self._add_Lmosek_4fusion_4SymmetricMatrix_2(_0)
  def _add_Lmosek_4fusion_4SymmetricMatrix_2(self,_0):
   _1=self._getdim_()
   if (_0._getdim_()!=_1):
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   _2=int((self.__usubi).shape[0])
   _3=int(((_0.__usubi)).shape[0])
   _4=(_2 + _3)
   _5=int((self.__vsubi).shape[0])
   _6=int(((_0.__vsubi)).shape[0])
   _7=(_5 + _6)
   _8=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   _9=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _11=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
   _13=numpy.zeros((_7,), dtype=numpy.dtype(numpy.float64))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubi,0,_8,0,_2)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0.__usubi),0,_8,_2,_3)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubj,0,_9,0,_2)
   for _14 in range(0,_3):
    _9[(_14 + _2)] = ((_0.__usubj)[_14] + self.__d1)
   if ((self.__scale > 1.0) or (self.__scale < 1.0)):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.__uval,0,_10,0,_2)
   else:
    fragments._c_closure_308(_10,self.__scale,_2,self.__uval) # src/fusion/SymmetricMatrix.monty:104:11-61
   if (((_0.__scale) > 1.0) or ((_0.__scale) < 1.0)):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_0.__uval),0,_10,_2,_3)
   else:
    for _15 in range(0,_3):
     _10[(_15 + _2)] = ((_0.__scale) * (_0.__uval)[_15])
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubi,0,_8,0,_2)
   for _16 in range(0,_6):
    _11[(_16 + _5)] = ((_0.__vsubi)[_16] + (_0.__d1))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__vsubj,0,_12,0,_5)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0.__vsubj),_5,_12,_5,_6)
   if ((self.__scale > 1.0) or (self.__scale < 1.0)):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.__vval,0,_13,0,_5)
   else:
    fragments._c_closure_309(_13,self.__scale,_5,self.__vval) # src/fusion/SymmetricMatrix.monty:122:11-61
   if (((_0.__scale) > 1.0) or ((_0.__scale) < 1.0)):
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_0.__vval),0,_13,_5,_6)
   else:
    for _17 in range(0,_6):
     _13[(_17 + _5)] = ((_0.__scale) * (_0.__vval)[_17])
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(self.__d0,(self.__d1 + (_0.__d1)),_8,_9,_10,_11,_12,_13,1.0))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  def _sub_alt_Lmosek_4fusion_4SymmetricMatrix_2(self,_t__0):
    return self._sub_Lmosek_4fusion_4SymmetricMatrix_2(_0)
  def _sub_Lmosek_4fusion_4SymmetricMatrix_2(self,_0):
   return (self._add_Lmosek_4fusion_4SymmetricMatrix_2(_0._mul_D((- 1.0))))
  @staticmethod
  def _match_mul_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_mul_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _mul_alt_D(self,_t__0):
    return self._mul_D(numpy.float64(__0))
  def _mul_D(self,_0):
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(self.__d0,self.__d1,self.__usubi,self.__usubj,self.__uval,self.__vsubi,self.__vsubj,self.__vval,(self.__scale * _0)))
  @staticmethod
  def _match_getdim_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getdim_(*args):
    if len(args) != 0: return False
    return True
  def _getdim_alt_(self,):
    return self._getdim_()
  def _getdim_(self,):
   return numpy.int32(self.__d0)
 return SymmetricMatrix
mosek_fusion_SymmetricMatrix=__mk_mosek_fusion_SymmetricMatrix()
del __mk_mosek_fusion_SymmetricMatrix
#BEFORE CLASS
def __mk_mosek_fusion_NDSparseArray():
 class NDSparseArray(object):
  __slots__ = ['_cof','_inst','_dims','_size']
  @staticmethod
  def make(*args):
    if False: pass
    elif mosek_fusion_NDSparseArray._match_make_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_NDSparseArray._make_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_NDSparseArray._make_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_NDSparseArray._match_make__3I_3J_3D(*args): # []int32,[]int64,[]double
      return mosek_fusion_NDSparseArray._make__3I_3J_3D(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make__3I_3J_3D(*args): # []int32,[]int64,[]double
      return mosek_fusion_NDSparseArray._make_alt__3I_3J_3D(*args)
    elif mosek_fusion_NDSparseArray._match_make__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_NDSparseArray._make__3I_3_5I_3D(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_NDSparseArray._make_alt__3I_3_5I_3D(*args)
    else:
      raise ValueError('Invalid argument list make('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSparseArray.make(mosek.fusion.Matrix)\n\tmosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int32,ndim=2),array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.NDSparseArray'
  @staticmethod
  def _ctor__3I_3_5I_3D(dims_,sub,cof_):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init__3I_3_5I_3D(dims_,sub,cof_)
    return o
  @staticmethod
  def __match_ctor__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    dims_,sub,cof_, = args
    return (__arg_match__3I__(dims_) and __arg_match__3_5I__(sub) and __arg_match__3D__(cof_))
  @staticmethod
  def __match_alt_ctor__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    dims_,sub,cof_, = args
    return (__arg_alt_match__3I__(dims_) and __arg_alt_match__3_5I__(sub) and __arg_alt_match__3D__(cof_))
  def _ctor_alt_init__3I_3_5I_3D(self,dims_,sub,cof_):
    self._ctor_init__3I_3_5I_3D(numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(sub,dtype=numpy.dtype(numpy.int32)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3_5I_3D(self,dims_,sub,cof_):
   assert dims_ is None or isinstance(dims_,numpy.ndarray)
   assert sub is None or isinstance(sub,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   object.__init__(self)
   _0=numpy.zeros((int((sub).shape[0]),), dtype=numpy.dtype(numpy.int64))
   self._size = 1
   self._size = fragments._c_closure_310(dims_,self._size) # src/fusion/Matrix.mbi:1053:20-71
   self._size = numpy.int64(self._size) # postprocess
   _1=int((dims_).shape[0])
   if (int((sub).shape[0])!=int((cof_).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching data array length")
   if (int((sub).shape[1])!=_1):
    raise mosek_fusion_IndexError._ctor_S("An index key in sub has wrong length")
   for _2 in range(0,int((sub).shape[0])):
    for _3 in range(0,int((sub).shape[1])):
     if ((sub[_2,_3] < 0) or (sub[_2,_3] >= dims_[_3])):
      raise mosek_fusion_IndexError._ctor_S("An index in sub is out of bounds")
   for _4 in range(0,int((sub).shape[0])):
    _5=0
    for _6 in range(0,int((sub).shape[1])):
     _5 = ((_5 * dims_[((_1 - _6) - 1)]) + sub[_4,_6])
    _0[_4] = _5
   self._dims = mosek.fusion.Utils.Tools._arraycopy__3I(dims_)
   _7=True
   _7 = fragments._c_closure_311(_0,_7) # src/fusion/Matrix.mbi:1075:9-84
   if _7:
    _8=1
    _8 = fragments._c_closure_312(_0,_8) # src/fusion/Matrix.mbi:1080:11-1082:25
    _8 = numpy.int32(_8) # postprocess
    if (_8==int((_0).shape[0])):
     self._inst = mosek.fusion.Utils.Tools._arraycopy__3J(_0)
     self._cof = mosek.fusion.Utils.Tools._arraycopy__3D(cof_)
    else:
     self._inst = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
     self._inst[0] = _0[0]
     self._cof = numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
     self._cof[0] = cof_[0]
     _9=0
     _9 = fragments._c_closure_313(self._cof,cof_,self._inst,_0,_9) # src/fusion/Matrix.mbi:1093:13-1099:43
     _9 = numpy.int32(_9) # postprocess
   else:
    _10=mosek.fusion.Utils.Tools._range_J(int((_0).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_10,_0,None,0,int((_0).shape[0]))
    _11=1
    _11 = fragments._c_closure_314(_0,_11,_10) # src/fusion/Matrix.mbi:1107:11-1109:25
    _11 = numpy.int32(_11) # postprocess
    self._inst = numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
    self._inst[0] = _0[_10[0]]
    self._cof = numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
    self._cof[0] = cof_[_10[0]]
    _12=0
    _12 = fragments._c_closure_315(self._cof,cof_,self._inst,_0,_12,_10) # src/fusion/Matrix.mbi:1114:11-1120:47
    _12 = numpy.int32(_12) # postprocess
  @staticmethod
  def _ctor__3I_3J_3D(dims_,inst_,cof_):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init__3I_3J_3D(dims_,inst_,cof_)
    return o
  @staticmethod
  def __match_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    dims_,inst_,cof_, = args
    return (__arg_match__3I__(dims_) and __arg_match__3J__(inst_) and __arg_match__3D__(cof_))
  @staticmethod
  def __match_alt_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    dims_,inst_,cof_, = args
    return (__arg_alt_match__3I__(dims_) and __arg_alt_match__3J__(inst_) and __arg_alt_match__3D__(cof_))
  def _ctor_alt_init__3I_3J_3D(self,dims_,inst_,cof_):
    self._ctor_init__3I_3J_3D(numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(inst_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3J_3D(self,dims_,inst_,cof_):
   assert dims_ is None or isinstance(dims_,numpy.ndarray)
   assert inst_ is None or isinstance(inst_,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   object.__init__(self)
   self._size = 1
   self._size = fragments._c_closure_316(dims_,self._size) # src/fusion/Matrix.mbi:991:20-71
   self._size = numpy.int64(self._size) # postprocess
   if (int((inst_).shape[0])!=int((cof_).shape[0])):
    raise mosek_fusion_LengthError._ctor_S("Mismatching data array length")
   for _0 in range(0,int((inst_).shape[0])):
    if ((inst_[_0] < 0) or (inst_[_0] >= self._size)):
     raise mosek_fusion_IndexError._ctor_S("An index in inst is out of bounds")
   self._dims = mosek.fusion.Utils.Tools._arraycopy__3I(dims_)
   _1=True
   _1 = fragments._c_closure_317(inst_,_1) # src/fusion/Matrix.mbi:1000:9-84
   if _1:
    _2=1
    _2 = fragments._c_closure_318(inst_,_2) # src/fusion/Matrix.mbi:1005:11-1007:25
    _2 = numpy.int32(_2) # postprocess
    if (_2==int((inst_).shape[0])):
     self._inst = mosek.fusion.Utils.Tools._arraycopy__3J(inst_)
     self._cof = mosek.fusion.Utils.Tools._arraycopy__3D(cof_)
    else:
     self._inst = numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
     self._inst[0] = inst_[0]
     self._cof = numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
     self._cof[0] = cof_[0]
     _3=0
     _3 = fragments._c_closure_319(self._cof,cof_,self._inst,inst_,_3) # src/fusion/Matrix.mbi:1018:13-1024:43
     _3 = numpy.int32(_3) # postprocess
   else:
    _4=mosek.fusion.Utils.Tools._range_J(int((inst_).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_4,inst_,None,0,int((inst_).shape[0]))
    _5=1
    _5 = fragments._c_closure_320(inst_,_5,_4) # src/fusion/Matrix.mbi:1032:11-1034:25
    _5 = numpy.int32(_5) # postprocess
    self._inst = numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    self._inst[0] = inst_[_4[0]]
    self._cof = numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
    self._cof[0] = cof_[_4[0]]
    _6=0
    _6 = fragments._c_closure_321(self._cof,cof_,self._inst,inst_,_6,_4) # src/fusion/Matrix.mbi:1039:11-1045:47
    _6 = numpy.int32(_6) # postprocess
  @staticmethod
  def _ctor_Lmosek_4fusion_4Matrix_2(m):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init_Lmosek_4fusion_4Matrix_2(m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Matrix_2(self,m):
    self._ctor_init_Lmosek_4fusion_4Matrix_2(m)
  def _ctor_init_Lmosek_4fusion_4Matrix_2(self,m):
   object.__init__(self)
   _0=m._numNonzeros_()
   _1=m._numRows_()
   _2=m._numColumns_()
   _3=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
   m._getDataAsTriplets__3I_3I_3D(_3,_4,_5)
   self._size = (numpy.int64(m._numRows_()) * numpy.int64(m._numColumns_()))
   self._dims = numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))
   self._inst = numpy.array([((numpy.int64(_3[_6]) * _2) + numpy.int64(_4[_6])) for _6 in range(0,_0)], dtype=numpy.dtype(numpy.int64))
   self._cof = _5
  @staticmethod
  def _match_make_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_make_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _make_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_NDSparseArray._make_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _make_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek_fusion_NDSparseArray._ctor_Lmosek_4fusion_4Matrix_2(_0))
  @staticmethod
  def _match_make__3I_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_make__3I_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _make_alt__3I_3J_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_NDSparseArray._make__3I_3J_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I_3J_3D(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_NDSparseArray._ctor__3I_3J_3D(_0,_1,_2))
  @staticmethod
  def _match_make__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_make__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _make_alt__3I_3_5I_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_NDSparseArray._make__3I_3_5I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I_3_5I_3D(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_NDSparseArray._ctor__3I_3_5I_3D(_0,_1,_2))
 return NDSparseArray
mosek_fusion_NDSparseArray=__mk_mosek_fusion_NDSparseArray()
del __mk_mosek_fusion_NDSparseArray
#BEFORE CLASS
def __mk_mosek_fusion_Matrix():
 class Matrix(object):
  __slots__ = ['_dimj','_dimi']
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_Matrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numNonzeros()')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_Matrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.get(int32,int32)')
  def numRows(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numRows_(*args): # 
      return self._numRows_(*args)
    elif mosek_fusion_Matrix._match_alt_numRows_(*args): # 
      return self._numRows_alt_(*args)
    else:
      raise ValueError('Invalid argument list numRows('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numRows()')
  @staticmethod
  def ones(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_ones_II(*args): # int32,int32
      return mosek_fusion_Matrix._ones_II(*args)
    elif mosek_fusion_Matrix._match_alt_ones_II(*args): # int32,int32
      return mosek_fusion_Matrix._ones_alt_II(*args)
    else:
      raise ValueError('Invalid argument list ones('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.ones(int32,int32)')
  @staticmethod
  def sparse(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_sparse__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._sparse__3_5D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._sparse_alt__3_5D(*args)
    elif mosek_fusion_Matrix._match_sparse__3_3Lmosek_4fusion_4Matrix_2(*args): # [][]mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse__3_3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3_3Lmosek_4fusion_4Matrix_2(*args): # [][]mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_alt__3_3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_sparse_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_sparse_II(*args): # int32,int32
      return mosek_fusion_Matrix._sparse_II(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II(*args): # int32,int32
      return mosek_fusion_Matrix._sparse_alt_II(*args)
    elif mosek_fusion_Matrix._match_sparse__3I_3I_3D(*args): # []int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3I_3I_3D(*args): # []int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_alt__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_sparse__3I_3ID(*args): # []int32,[]int32,double
      return mosek_fusion_Matrix._sparse__3I_3ID(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3I_3ID(*args): # []int32,[]int32,double
      return mosek_fusion_Matrix._sparse_alt__3I_3ID(*args)
    elif mosek_fusion_Matrix._match_sparse_II_3I_3ID(*args): # int32,int32,[]int32,[]int32,double
      return mosek_fusion_Matrix._sparse_II_3I_3ID(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II_3I_3ID(*args): # int32,int32,[]int32,[]int32,double
      return mosek_fusion_Matrix._sparse_alt_II_3I_3ID(*args)
    elif mosek_fusion_Matrix._match_sparse_II_3I_3I_3D(*args): # int32,int32,[]int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_II_3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II_3I_3I_3D(*args): # int32,int32,[]int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_alt_II_3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.sparse(array(double,ndim=2))\n\tmosek.fusion.Matrix.sparse(array(array(mosek.fusion.Matrix,ndim=1),ndim=1))\n\tmosek.fusion.Matrix.sparse(mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.sparse(int32,int32)\n\tmosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))\n\tmosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),double)\n\tmosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),double)\n\tmosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_Matrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.getDataAsArray()')
  @staticmethod
  def diag(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_diag__3D(*args): # []double
      return mosek_fusion_Matrix._diag__3D(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3D(*args): # []double
      return mosek_fusion_Matrix._diag_alt__3D(*args)
    elif mosek_fusion_Matrix._match_diag__3Lmosek_4fusion_4Matrix_2(*args): # []mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag__3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3Lmosek_4fusion_4Matrix_2(*args): # []mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_alt__3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_diag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._diag__3DI(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._diag_alt__3DI(*args)
    elif mosek_fusion_Matrix._match_diag_ILmosek_4fusion_4Matrix_2(*args): # int32,mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_ILmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_diag_ILmosek_4fusion_4Matrix_2(*args): # int32,mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_alt_ILmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_diag_ID(*args): # int32,double
      return mosek_fusion_Matrix._diag_ID(*args)
    elif mosek_fusion_Matrix._match_alt_diag_ID(*args): # int32,double
      return mosek_fusion_Matrix._diag_alt_ID(*args)
    elif mosek_fusion_Matrix._match_diag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._diag_IDI(*args)
    elif mosek_fusion_Matrix._match_alt_diag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._diag_alt_IDI(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.diag(array(double,ndim=1))\n\tmosek.fusion.Matrix.diag(array(mosek.fusion.Matrix,ndim=1))\n\tmosek.fusion.Matrix.diag(array(double,ndim=1),int32)\n\tmosek.fusion.Matrix.diag(int32,mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.diag(int32,double)\n\tmosek.fusion.Matrix.diag(int32,double,int32)')
  @staticmethod
  def eye(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_eye_I(*args): # int32
      return mosek_fusion_Matrix._eye_I(*args)
    elif mosek_fusion_Matrix._match_alt_eye_I(*args): # int32
      return mosek_fusion_Matrix._eye_alt_I(*args)
    else:
      raise ValueError('Invalid argument list eye('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.eye(int32)')
  @staticmethod
  def antidiag(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_antidiag__3D(*args): # []double
      return mosek_fusion_Matrix._antidiag__3D(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag__3D(*args): # []double
      return mosek_fusion_Matrix._antidiag_alt__3D(*args)
    elif mosek_fusion_Matrix._match_antidiag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._antidiag__3DI(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._antidiag_alt__3DI(*args)
    elif mosek_fusion_Matrix._match_antidiag_ID(*args): # int32,double
      return mosek_fusion_Matrix._antidiag_ID(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag_ID(*args): # int32,double
      return mosek_fusion_Matrix._antidiag_alt_ID(*args)
    elif mosek_fusion_Matrix._match_antidiag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._antidiag_IDI(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._antidiag_alt_IDI(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.antidiag(array(double,ndim=1))\n\tmosek.fusion.Matrix.antidiag(array(double,ndim=1),int32)\n\tmosek.fusion.Matrix.antidiag(int32,double)\n\tmosek.fusion.Matrix.antidiag(int32,double,int32)')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Matrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.transpose()')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_Matrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.isSparse()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Matrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.toString()')
  def numColumns(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numColumns_(*args): # 
      return self._numColumns_(*args)
    elif mosek_fusion_Matrix._match_alt_numColumns_(*args): # 
      return self._numColumns_alt_(*args)
    else:
      raise ValueError('Invalid argument list numColumns('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numColumns()')
  @staticmethod
  def dense(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_dense__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._dense__3_5D(*args)
    elif mosek_fusion_Matrix._match_alt_dense__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._dense_alt__3_5D(*args)
    elif mosek_fusion_Matrix._match_dense_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._dense_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_dense_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._dense_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_dense_IID(*args): # int32,int32,double
      return mosek_fusion_Matrix._dense_IID(*args)
    elif mosek_fusion_Matrix._match_alt_dense_IID(*args): # int32,int32,double
      return mosek_fusion_Matrix._dense_alt_IID(*args)
    elif mosek_fusion_Matrix._match_dense_II_3D(*args): # int32,int32,[]double
      return mosek_fusion_Matrix._dense_II_3D(*args)
    elif mosek_fusion_Matrix._match_alt_dense_II_3D(*args): # int32,int32,[]double
      return mosek_fusion_Matrix._dense_alt_II_3D(*args)
    else:
      raise ValueError('Invalid argument list dense('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.dense(array(double,ndim=2))\n\tmosek.fusion.Matrix.dense(mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.dense(int32,int32,double)\n\tmosek.fusion.Matrix.dense(int32,int32,array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.Matrix'
  @staticmethod
  def _ctor_II(di,dj):
    o = Matrix.__new__(Matrix)
    o._ctor_init_II(di,dj)
    return o
  @staticmethod
  def __match_ctor_II(*args):
    if len(args) != 2: return False
    di,dj, = args
    return (__arg_match_I__(di) and __arg_match_I__(dj))
  @staticmethod
  def __match_alt_ctor_II(*args):
    if len(args) != 2: return False
    di,dj, = args
    return (__arg_alt_match_I__(di) and __arg_alt_match_I__(dj))
  def _ctor_alt_init_II(self,di,dj):
    self._ctor_init_II(numpy.int32(di),numpy.int32(dj))
  def _ctor_init_II(self,di,dj):
   object.__init__(self)
   if ((di < 0) or (dj < 0)):
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimensions")
   self._dimi = di
   self._dimj = dj
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("")
  def _switchDims_alt_(self,):
    return self._switchDims_()
  def _switchDims_(self,):
   _0=self._dimi
   self._dimi = self._dimj
   self._dimj = _0
  @staticmethod
  def _match_diag_ILmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_diag_ILmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _diag_alt_ILmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Matrix._diag_ILmosek_4fusion_4Matrix_2(numpy.int32(__0),_1)
  @staticmethod
  def _diag_ILmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Matrix._diag__3Lmosek_4fusion_4Matrix_2(numpy.array([_1 for _2 in range(0,_0)], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_diag__3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_diag__3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _diag_alt__3Lmosek_4fusion_4Matrix_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Matrix._diag__3Lmosek_4fusion_4Matrix_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3Lmosek_4fusion_4Matrix_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=_0
   _2=0
   _3=0
   _4=0
   for _5 in range(0,int((_0).shape[0])):
    _3 = (_3 + (_0[_5]._dimi))
    _4 = (_4 + (_0[_5]._dimj))
    _2 = (_2 + _0[_5]._numNonzeros_())
   _6=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _9=0
   _10=0
   _11=0
   for _12 in range(0,int((_0).shape[0])):
    _13=_0[_12]._numNonzeros_()
    _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    _0[_12]._getDataAsTriplets__3I_3I_3D(_14,_15,_16)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_16,0,_8,_11,_13)
    fragments._c_closure_322(_13,_11,_14,_9,_10,_6,_7) # src/fusion/Matrix.mbi:525:13-529:14
    _11 = (_11 + _13)
    _9 = (_9 + (_0[_12]._dimi))
    _10 = (_10 + (_0[_12]._dimj))
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_4,_6,_7,_8))
  @staticmethod
  def _match_antidiag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_antidiag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _antidiag_alt_IDI(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._antidiag_IDI(numpy.int32(__0),numpy.float64(__1),numpy.int32(__2))
  @staticmethod
  def _antidiag_IDI(_0,_1,_2):
   if ((_2 < _0) and (_2 >= 0)):
    return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 - _2)),_2))
   elif ((_2 > (- _0)) and (_2 < 0)):
    return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 + _2)),_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Diagonal index out of bounds")
  @staticmethod
  def _match_antidiag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_antidiag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _antidiag_alt_ID(_t__0,_t__1):
    return mosek_fusion_Matrix._antidiag_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _antidiag_ID(_0,_1):
   return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,_0),0))
  @staticmethod
  def _match_diag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_diag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _diag_alt_IDI(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._diag_IDI(numpy.int32(__0),numpy.float64(__1),numpy.int32(__2))
  @staticmethod
  def _diag_IDI(_0,_1,_2):
   if ((_2 < _0) and (_2 >= 0)):
    return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 - _2)),_2))
   elif ((_2 > (- _0)) and (_2 < 0)):
    return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 + _2)),_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Diagonal index out of bounds")
  @staticmethod
  def _match_diag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_diag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _diag_alt_ID(_t__0,_t__1):
    return mosek_fusion_Matrix._diag_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _diag_ID(_0,_1):
   return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,_0),0))
  @staticmethod
  def _match_antidiag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_antidiag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _antidiag_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Matrix._antidiag__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antidiag__3DI(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=(_1 if ((_1 > 0) ) else (- _1))
   _3=(int((_0).shape[0]) + _2)
   _4=int((_0).shape[0])
   if (_1 >= 0):
    _5=mosek.fusion.Utils.Tools._range_II(_1,(_4 + _1))
    _6=numpy.array([((_4 + _1) - _7) for _7 in range(1,(_4 + 1))], dtype=numpy.dtype(numpy.int32))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_5,_6,_0))
   else:
    _8=mosek.fusion.Utils.Tools._range_II(0,_4)
    _9=numpy.array([(_4 - _10) for _10 in range(1,(_4 + 1))], dtype=numpy.dtype(numpy.int32))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_8,_9,_0))
  @staticmethod
  def _match_antidiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_antidiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _antidiag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._antidiag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antidiag__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Matrix._antidiag__3DI(_0,0))
  @staticmethod
  def _match_diag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_diag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _diag_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Matrix._diag__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3DI(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=(_1 if ((_1 > 0) ) else (- _1))
   _3=(int((_0).shape[0]) + _2)
   _4=int((_0).shape[0])
   if (_1 >= 0):
    _5=mosek.fusion.Utils.Tools._range_II(0,_4)
    _6=mosek.fusion.Utils.Tools._range_II(_2,(_4 + _2))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_5,_6,_0))
   else:
    _7=mosek.fusion.Utils.Tools._range_II(_2,(_4 + _2))
    _8=mosek.fusion.Utils.Tools._range_II(0,_4)
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_7,_8,_0))
  @staticmethod
  def _match_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _diag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._diag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Matrix._diag__3DI(_0,0))
  @staticmethod
  def _match_ones_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_ones_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _ones_alt_II(_t__0,_t__1):
    return mosek_fusion_Matrix._ones_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _ones_II(_0,_1):
   return (mosek.fusion.Matrix._dense_IID(_0,_1,1.0))
  @staticmethod
  def _match_eye_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_eye_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _eye_alt_I(_t__0):
    return mosek_fusion_Matrix._eye_I(numpy.int32(__0))
  @staticmethod
  def _eye_I(_0):
   return (mosek.fusion.Matrix._diag__3D(numpy.array([1.0 for _1 in range(0,_0)], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_dense_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_dense_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _dense_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Matrix._dense_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _dense_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek_fusion_DenseMatrix._ctor_Lmosek_4fusion_4Matrix_2(_0))
  @staticmethod
  def _match_dense_IID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_dense_IID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _dense_alt_IID(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._dense_IID(numpy.int32(__0),numpy.int32(__1),numpy.float64(__2))
  @staticmethod
  def _dense_IID(_0,_1,_2):
   return (mosek_fusion_DenseMatrix._ctor_IID(_0,_1,_2))
  @staticmethod
  def _match_dense_II_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_dense_II_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _dense_alt_II_3D(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._dense_II_3D(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dense_II_3D(_0,_1,_2):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_DenseMatrix._ctor_II_3D(_0,_1,_2))
  @staticmethod
  def _match_dense__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_dense__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _dense_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._dense__3_5D(_0)
   return _1
  @staticmethod
  def _dense__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_DenseMatrix._ctor__3_5D(_0))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Matrix._sparse_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _sparse_Lmosek_4fusion_4Matrix_2(_0):
   _1=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _2=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _3=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_1,_2,_3)
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_0._numRows_(),_0._numColumns_(),_1,_2,_3))
  @staticmethod
  def _match_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _sparse_alt__3_3Lmosek_4fusion_4Matrix_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Matrix._sparse__3_3Lmosek_4fusion_4Matrix_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3_3Lmosek_4fusion_4Matrix_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=int((_0[0]).shape[0])
   _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _5=0
   _6=0
   _7=0
   while (_7 < _1):
    _8=0
    while (_8 < _2):
     _9=_0[_7][_8]
     if (_9 is not None):
      if (_4[_8]==0):
       _4[_8] = (_9._dimj)
      elif (_4[_8]!=(_9._dimj)):
       raise mosek_fusion_SparseFormatError._ctor_S("Sparse matrix construction blocks are not aligned")
      if (_3[_7]==0):
       _3[_7] = (_9._dimi)
      elif (_3[_7]!=(_9._dimi)):
       raise mosek_fusion_SparseFormatError._ctor_S("Sparse matrix construction blocks are not aligned")
      _5 = (_5 + _9._numNonzeros_())
     _6 += 1
     _8 += 1
    _7 += 1
   _10=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
   _11=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _13=0
   _14=0
   _15=0
   while (_15 < _1):
    _16=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _17=0
    while (_17 < _3[_15]):
     _18=0
     _19=0
     while (_19 < _2):
      _20=_0[_15][_19]
      if (_20 is not None):
       _22=_20
       if   isinstance(_22,mosek_fusion_DenseMatrix):
        m=_22
        _22=_16[_19]
        _23=0
        while (_23 < (m._dimj)):
         _10[_13] = (m._data)[_22]
         _11[_13] = (_14 + _17)
         _12[_13] = (_18 + _23)
         _22 += 1
         _13 += 1
         _23 += 1
        _16[_19] = _22
       elif isinstance(_22,mosek_fusion_SparseMatrix):
        _24=_22
        _25 = _16[_19]
        while ((_25 < (_24._nnz)) and ((_24._subi)[_25]==_17)):
         _10[_13] = (_24._val)[_25]
         _12[_13] = ((_24._subj)[_25] + _18)
         _11[_13] = (_14 + _17)
         _13 += 1
         _25 += 1
        _16[_19] = _25
       else:
        m=_22
        raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type.")
      _18 = (_18 + _4[_19])
      _19 += 1
     _17 += 1
    _14 = (_14 + _3[_15])
    _15 += 1
   _26=0
   _27=0
   _26 = fragments._c_closure_323(_26,_3,_1) # src/fusion/Matrix.mbi:351:9-354:10
   _26 = numpy.int32(_26) # postprocess
   _27 = fragments._c_closure_324(_27,_4,_2) # src/fusion/Matrix.mbi:355:9-358:10
   _27 = numpy.int32(_27) # postprocess
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_26,_27,_11,_12,_10))
  @staticmethod
  def _match_sparse__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_sparse__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _sparse_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse__3_5D(_0)
   return _1
  @staticmethod
  def _sparse__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=int((_0).shape[1])
   _3=numpy.int64((_1 * _2))
   _4=numpy.array([_5 for _5 in range(0,_1) for _6 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   _7=numpy.array([_9 for _8 in range(0,_1) for _9 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   _10=numpy.array([_0[_11,_12] for _11 in range(0,_1) for _12 in range(0,_2)], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_1,_2,_4,_7,_10))
  @staticmethod
  def _match_sparse_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_sparse_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _sparse_alt_II(_t__0,_t__1):
    return mosek_fusion_Matrix._sparse_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _sparse_II(_0,_1):
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3DJ(_0,_1,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),0))
  @staticmethod
  def _match_sparse_II_3I_3ID(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match_D__(_4))
  @staticmethod
  def _match_alt_sparse_II_3I_3ID(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match_D__(_4))
  @staticmethod
  def _sparse_alt_II_3I_3ID(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.float64(_t__4)
   _1 = mosek_fusion_Matrix._sparse_II_3I_3ID(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_II_3I_3ID(_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _5=0
   if (_2 is not None):
    _5 = int((_2).shape[0])
   elif (_3 is not None):
    _5 = int((_3).shape[0])
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D(_0,_1,_2,_3,mosek.fusion.Utils.Tools._makevector_DI(_4,_5)))
  @staticmethod
  def _match_sparse__3I_3ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_sparse__3I_3ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _sparse_alt__3I_3ID(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.float64(_t__2)
   _1 = mosek_fusion_Matrix._sparse__3I_3ID(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3I_3ID(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=0
   _4=0
   _5=int((_0).shape[0])
   if (_5 > int((_1).shape[0])):
    _5 = int((_1).shape[0])
   _3,_4 = fragments._c_closure_325(_3,_4,_5,_0,_1) # src/fusion/Matrix.mbi:179:9-183:10
   _3 = numpy.int32(_3) # postprocess
   _4 = numpy.int32(_4) # postprocess
   return (mosek.fusion.Matrix._sparse_II_3I_3ID((_3 + 1),(_4 + 1),_0,_1,_2))
  @staticmethod
  def _match_sparse__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_sparse__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _sparse_alt__3I_3I_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3I_3I_3D(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=0
   _4=0
   _5=int((_0).shape[0])
   if (_5 > int((_1).shape[0])):
    _5 = int((_1).shape[0])
   if (_5 > int((_2).shape[0])):
    _5 = int((_2).shape[0])
   _3,_4 = fragments._c_closure_326(_3,_4,_5,_0,_1) # src/fusion/Matrix.mbi:161:9-165:10
   _3 = numpy.int32(_3) # postprocess
   _4 = numpy.int32(_4) # postprocess
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D((_3 + 1),(_4 + 1),_0,_1,_2))
  @staticmethod
  def _match_sparse_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3D__(_4))
  @staticmethod
  def _match_alt_sparse_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3D__(_4))
  @staticmethod
  def _sparse_alt_II_3I_3I_3D(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse_II_3I_3I_3D(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_II_3I_3I_3D(_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=(_2 if ((_2 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   _6=(_3 if ((_3 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   _7=(_4 if ((_4 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
   _8=int((_5).shape[0])
   if ((int((_6).shape[0])!=_8) or (int((_7).shape[0])!=_8)):
    raise mosek_fusion_SparseFormatError._ctor_S("Arrays defining sparse data have different lengths")
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3DJ(_0,_1,_5,_6,_7,_8))
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   pass
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   pass
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   pass
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   pass
  @staticmethod
  def _match_numColumns_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numColumns_(*args):
    if len(args) != 0: return False
    return True
  def _numColumns_alt_(self,):
    return self._numColumns_()
  def _numColumns_(self,):
   return numpy.int32(self._dimj)
  @staticmethod
  def _match_numRows_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numRows_(*args):
    if len(args) != 0: return False
    return True
  def _numRows_alt_(self,):
    return self._numRows_()
  def _numRows_(self,):
   return numpy.int32(self._dimi)
 return Matrix
mosek_fusion_Matrix=__mk_mosek_fusion_Matrix()
del __mk_mosek_fusion_Matrix
#BEFORE CLASS
def __mk_mosek_fusion_DenseMatrix():
 class DenseMatrix(mosek_fusion_Matrix):
  __slots__ = ['_nnz','_data']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.toString()')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.numNonzeros()')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.getDataAsArray()')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.isSparse()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_DenseMatrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.get(int32,int32)')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.transpose()')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_DenseMatrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.DenseMatrix'
  @staticmethod
  def _ctor_II_3D(dimi_,dimj_,cof):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_II_3D(dimi_,dimj_,cof)
    return o
  @staticmethod
  def __match_ctor_II_3D(*args):
    if len(args) != 3: return False
    dimi_,dimj_,cof, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3D__(cof))
  @staticmethod
  def __match_alt_ctor_II_3D(*args):
    if len(args) != 3: return False
    dimi_,dimj_,cof, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3D__(cof))
  def _ctor_alt_init_II_3D(self,dimi_,dimj_,cof):
    self._ctor_init_II_3D(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(cof,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_II_3D(self,dimi_,dimj_,cof):
   assert cof is None or isinstance(cof,numpy.ndarray)
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   self._nnz = numpy.int64((dimi_ * dimj_))
   self._data = numpy.zeros(((dimi_ * dimj_),), dtype=numpy.dtype(numpy.float64))
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(cof,0,self._data,0,(dimi_ * dimj_))
  @staticmethod
  def _ctor_Lmosek_4fusion_4Matrix_2(m_):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_Lmosek_4fusion_4Matrix_2(m_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m_, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(m_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(m_))
  def _ctor_alt_init_Lmosek_4fusion_4Matrix_2(self,m_):
    self._ctor_init_Lmosek_4fusion_4Matrix_2(m_)
  def _ctor_init_Lmosek_4fusion_4Matrix_2(self,m_):
   mosek_fusion_Matrix._ctor_init_II(self,(m_._dimi),(m_._dimj))
   _1=m_
   if   isinstance(_1,mosek_fusion_DenseMatrix):
    m=_1
    self._data = mosek.fusion.Utils.Tools._arraycopy__3D((m._data))
   elif isinstance(_1,mosek_fusion_SparseMatrix):
    _1=_1
    self._data = mosek.fusion.Utils.Tools._zeros_I(((_1._dimi) * (_1._dimj)))
    for _2 in range(0,(_1._nnz)):
     self._data[(((_1._subi)[_2] * self._dimj) + (_1._subj)[_2])] = (_1._val)[_2]
   else:
    m=_1
    raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type.")
   self._nnz = numpy.int64((self._dimi * self._dimj))
  @staticmethod
  def _ctor__3_5D(d):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init__3_5D(d)
    return o
  @staticmethod
  def __match_ctor__3_5D(*args):
    if len(args) != 1: return False
    d, = args
    return (__arg_match__3_5D__(d))
  @staticmethod
  def __match_alt_ctor__3_5D(*args):
    if len(args) != 1: return False
    d, = args
    return (__arg_alt_match__3_5D__(d))
  def _ctor_alt_init__3_5D(self,d):
    self._ctor_init__3_5D(numpy.array(d,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3_5D(self,d):
   assert d is None or isinstance(d,numpy.ndarray)
   mosek_fusion_Matrix._ctor_init_II(self,int((d).shape[0]),int((d).shape[1]))
   self._data = numpy.array([d[_0,_1] for _0 in range(0,self._dimi) for _1 in range(0,self._dimj)], dtype=numpy.dtype(numpy.float64))
   self._nnz = numpy.int64((self._dimi * self._dimj))
  @staticmethod
  def _ctor_IID(dimi_,dimj_,value_):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_IID(dimi_,dimj_,value_)
    return o
  @staticmethod
  def __match_ctor_IID(*args):
    if len(args) != 3: return False
    dimi_,dimj_,value_, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match_D__(value_))
  @staticmethod
  def __match_alt_ctor_IID(*args):
    if len(args) != 3: return False
    dimi_,dimj_,value_, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match_D__(value_))
  def _ctor_alt_init_IID(self,dimi_,dimj_,value_):
    self._ctor_init_IID(numpy.int32(dimi_),numpy.int32(dimj_),numpy.float64(value_))
  def _ctor_init_IID(self,dimi_,dimj_,value_):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   self._data = numpy.array([value_ for _0 in range(0,dimi_) for _1 in range(0,dimj_)], dtype=numpy.dtype(numpy.float64))
   self._nnz = numpy.int64((dimi_ * dimj_))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("DenseMatrix(")
   _0._a_I(self._dimi)
   _0._a_S(",")
   _0._a_I(self._dimj)
   _0._a_S(": ")
   _1=0
   _2=0
   while (_2 < self._dimi):
    if (_2 > 0):
     _0._a_S(",")
    _0._a_S("[ ")
    _0._a_D(self._data[_1])
    _1 += 1
    _3=1
    while (_3 < self._dimj):
     _0._a_S(",")
     _0._a_D(self._data[_1])
     _1 += 1
     _3 += 1
    _0._a_S(" ]")
    _2 += 1
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   _0=numpy.zeros(((self._dimi * self._dimj),), dtype=numpy.dtype(numpy.float64))
   _1=0
   _2=self._dimi
   _1 = fragments._c_closure_327(self._data,self._dimi,self._dimj,_0,_1,_2) # src/fusion/Matrix.mbi:911:9-921:10
   _1 = numpy.int32(_1) # postprocess
   return (mosek_fusion_DenseMatrix._ctor_II_3D(self._dimj,self._dimi,_0))
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return (False)
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3D(self._data))
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((int((_0).shape[0]) < self._nnz) or ((int((_1).shape[0]) < self._nnz) or (int((_2).shape[0]) < self._nnz))):
    raise mosek_fusion_LengthError._ctor_S("Output arrays are not long enough.")
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self._data,0,_2,0,int((self._data).shape[0]))
   _3=0
   _3 = fragments._c_closure_328(self._dimi,self._dimj,_3,_0,_1) # src/fusion/Matrix.mbi:811:9-819:10
   _3 = numpy.int32(_3) # postprocess
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   return numpy.float64(self._data[((_0 * self._dimi) + _1)])
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(numpy.int64((self._dimi * self._dimj)))
 return DenseMatrix
mosek_fusion_DenseMatrix=__mk_mosek_fusion_DenseMatrix()
del __mk_mosek_fusion_DenseMatrix
#BEFORE CLASS
def __mk_mosek_fusion_SparseMatrix():
 class SparseMatrix(mosek_fusion_Matrix):
  __slots__ = ['_nnz','_val','_subj','_subi']
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_SparseMatrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_SparseMatrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.get(int32,int32)')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.numNonzeros()')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.isSparse()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.toString()')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.transpose()')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.getDataAsArray()')
  def __repr__(self): return 'mosek.fusion.SparseMatrix'
  @staticmethod
  def _ctor_II_3I_3I_3DJ(dimi_,dimj_,subi_,subj_,val_,nelm):
    o = SparseMatrix.__new__(SparseMatrix)
    o._ctor_init_II_3I_3I_3DJ(dimi_,dimj_,subi_,subj_,val_,nelm)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DJ(*args):
    if len(args) != 6: return False
    dimi_,dimj_,subi_,subj_,val_,nelm, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3I__(subi_) and __arg_match__3I__(subj_) and __arg_match__3D__(val_) and __arg_match_J__(nelm))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DJ(*args):
    if len(args) != 6: return False
    dimi_,dimj_,subi_,subj_,val_,nelm, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3I__(subi_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(val_) and __arg_alt_match_J__(nelm))
  def _ctor_alt_init_II_3I_3I_3DJ(self,dimi_,dimj_,subi_,subj_,val_,nelm):
    self._ctor_init_II_3I_3I_3DJ(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(subi_,dtype=numpy.dtype(numpy.int32)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(val_,dtype=numpy.dtype(numpy.float64)),numpy.int64(nelm))
  def _ctor_init_II_3I_3I_3DJ(self,dimi_,dimj_,subi_,subj_,val_,nelm):
   assert subi_ is None or isinstance(subi_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert val_ is None or isinstance(val_,numpy.ndarray)
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   if (nelm > 0):
    if ((int((subi_).shape[0]) < nelm) or ((int((subj_).shape[0]) < nelm) or (int((val_).shape[0]) < nelm))):
     raise mosek_fusion_SparseFormatError._ctor_S("Mismatching arrays in sparse data.")
    for _0 in range(0,nelm):
     if ((subi_[_0] < 0) or ((subi_[_0] >= self._dimi) or ((subj_[_0] < 0) or (subj_[_0] >= self._dimj)))):
      raise mosek_fusion_SparseFormatError._ctor_S("Subscript out of bounds.")
    _1=numpy.zeros((1,), dtype=numpy.dtype(object))
    _2=numpy.zeros((1,), dtype=numpy.dtype(object))
    _3=numpy.zeros((1,), dtype=numpy.dtype(object))
    mosek.fusion.CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(subi_,subj_,val_,_1,_2,_3,nelm,self._dimi,self._dimj)
    self._subi = _1[0]
    self._subj = _2[0]
    self._val = _3[0]
    self._nnz = int((self._val).shape[0])
   else:
    self._subi = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._subj = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._val = numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
    self._nnz = 0
  @staticmethod
  def _ctor_II_3I_3I_3D(dimi_,dimj_,subi_,subj_,val_):
    o = SparseMatrix.__new__(SparseMatrix)
    o._ctor_init_II_3I_3I_3D(dimi_,dimj_,subi_,subj_,val_)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    dimi_,dimj_,subi_,subj_,val_, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3I__(subi_) and __arg_match__3I__(subj_) and __arg_match__3D__(val_))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    dimi_,dimj_,subi_,subj_,val_, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3I__(subi_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(val_))
  def _ctor_alt_init_II_3I_3I_3D(self,dimi_,dimj_,subi_,subj_,val_):
    self._ctor_init_II_3I_3I_3D(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(subi_,dtype=numpy.dtype(numpy.int32)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(val_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_II_3I_3I_3D(self,dimi_,dimj_,subi_,subj_,val_):
   assert subi_ is None or isinstance(subi_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert val_ is None or isinstance(val_,numpy.ndarray)
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   _0=0
   _0 = fragments._c_closure_329(_0,val_) # src/fusion/Matrix.mbi:615:20-89
   _0 = numpy.int32(_0) # postprocess
   if ((_0 > 0) and (_0 < int((subi_).shape[0]))):
    self._subi = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    self._subj = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    self._val = numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
    self._nnz = _0
    _1=0
    _1 = fragments._c_closure_330(_1,self._subi,subi_,self._subj,subj_,self._val,val_) # src/fusion/Matrix.mbi:624:11-631:14
    _1 = numpy.int32(_1) # postprocess
   else:
    self._subi = subi_
    self._subj = subj_
    self._val = val_
    if (subi_ is None):
     self._nnz = 0
    else:
     self._nnz = int((self._subi).shape[0])
  def _formPtrb_alt_(self,):
    return self._formPtrb_()
  def _formPtrb_(self,):
   _0=numpy.zeros(((self._dimi + 1),), dtype=numpy.dtype(numpy.int64))
   _1=0
   _1 = fragments._c_closure_331(self._dimi,self._nnz,_1,_0,self._subi) # src/fusion/Matrix.mbi:764:9-770:10
   _1 = numpy.int64(_1) # postprocess
   _0[self._dimi] = _1
   return (_0)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SparseMatrix(")._a_I(self._dimi)._a_S(",")._a_I(self._dimj)._a_S(", [")
   if ((self._subi is not None) and (int((self._subi).shape[0]) > 0)):
    _0._a_S("(")._a_I(self._subi[0])._a_S(",")._a_I(self._subj[0])._a_S(",")._a_D(self._val[0])._a_S(")")
    for _1 in range(1,int((self._subi).shape[0])):
     _0._a_S(",(")._a_I(self._subi[_1])._a_S(",")._a_I(self._subj[_1])._a_S(",")._a_D(self._val[_1])._a_S(")")
   _0._a_S(" ])")
   return (_0._toString_())
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(self._nnz)
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D(self._dimj,self._dimi,self._subj,self._subi,self._val))
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return (True)
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   _0=numpy.zeros(((self._dimi * self._dimj),), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_332(self._dimj,_0,self._subi,self._subj,self._val) # src/fusion/Matrix.mbi:725:9-726:46
   return (_0)
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((int((_0).shape[0]) < self._nnz) or ((int((_1).shape[0]) < self._nnz) or (int((_2).shape[0]) < self._nnz))):
    raise mosek_fusion_LengthError._ctor_S("Output arrays are not long enough.")
   if ((self._subi is not None) and (int((self._subi).shape[0]) > 0)):
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self._subi,0,_0,0,self._nnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self._subj,0,_1,0,self._nnz)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self._val,0,_2,0,self._nnz)
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   if ((_0 < 0) or ((_0 >= self._dimi) or ((_1 < 0) or (_1 >= self._dimj)))):
    raise mosek_fusion_IndexError._ctor_S("Index out if bounds")
   _2=0
   _3=int((self._subi).shape[0])
   while ((_3 - _2) > 1):
    _4=((_2 + _3) // 2)
    if ((self._subi[_4] < _0) or ((self._subi[_4]==_0) and (self._subj[_4] < _1))):
     _2 = _4
    elif ((self._subi[_4] > _0) or ((self._subi[_4]==_0) and (self._subj[_4] > _1))):
     _3 = _4
    else:
     return numpy.float64(self._val[_4])
   if ((self._subi[_2]==_0) and (self._subj[_2]==_1)):
    return numpy.float64(self._val[_2])
   else:
    return numpy.float64(0.0)
 return SparseMatrix
mosek_fusion_SparseMatrix=__mk_mosek_fusion_SparseMatrix()
del __mk_mosek_fusion_SparseMatrix
#BEFORE CLASS
def __mk_mosek_fusion_Parameters():
 class Parameters(object):
  @staticmethod
  def setParameter(*args):
    if False: pass
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SS(*args): # mosek.fusion.Model,string,string
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SS(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SS(*args): # mosek.fusion.Model,string,string
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SS(*args)
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SI(*args): # mosek.fusion.Model,string,int32
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SI(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SI(*args): # mosek.fusion.Model,string,int32
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SI(*args)
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SD(*args): # mosek.fusion.Model,string,double
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SD(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SD(*args): # mosek.fusion.Model,string,double
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SD(*args)
    else:
      raise ValueError('Invalid argument list setParameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,string)\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,int32)\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,double)')
  def __repr__(self): return 'mosek.fusion.Parameters'
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SD(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SD(_0,_1,numpy.float64(__2))
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SD(_0,_1,_2):
   if False:
    pass
   elif (_1=="autoUpdateSolInfo"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
   elif (_1=="removeUnusedSolutions"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
   if (_1=="numThreads"):
    if ((_2 - numpy.int32(_2))==0.0):
     _3=_2
     if (0 <= _3):
      _0._task_1put_1param_SD("MSK_IPAR_NUM_THREADS",_3)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   elif (_1=="intpntMultiThread"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMultiThread)")
   if (_1=="mtSpincount"):
    if ((_2 - numpy.int32(_2))==0.0):
     _4=_2
     if ((0 <= _4) and (_4 <= 1000000000)):
      _0._task_1put_1param_SD("MSK_IPAR_MT_SPINCOUNT",_4)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   elif (_1=="optimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
   if (_1=="biMaxIterations"):
    if ((_2 - numpy.int32(_2))==0.0):
     _5=_2
     if (0 <= _5):
      _0._task_1put_1param_SD("MSK_IPAR_BI_MAX_ITERATIONS",_5)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"):
    if ((_2 - numpy.int32(_2))==0.0):
     _6=_2
     if (0 <= _6):
      _0._task_1put_1param_SD("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_6)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"):
    if ((_2 - numpy.int32(_2))==0.0):
     _7=_2
     if (0 <= _7):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_CUT_SECOND_OPT",_7)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logAnaPro"):
    if ((_2 - numpy.int32(_2))==0.0):
     _8=_2
     if (0 <= _8):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_ANA_PRO",_8)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logAnaPro)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logAnaPro)")
   if (_1=="logResponse"):
    if ((_2 - numpy.int32(_2))==0.0):
     _9=_2
     if (0 <= _9):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_RESPONSE",_9)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   if (_1=="logBi"):
    if ((_2 - numpy.int32(_2))==0.0):
     _10=_2
     if (0 <= _10):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_BI",_10)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"):
    if ((_2 - numpy.int32(_2))==0.0):
     _11=_2
     if (0 <= _11):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_BI_FREQ",_11)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   elif (_1=="biCleanOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
   elif (_1=="intpntStartingPoint"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
   elif (_1=="intpntDiffStep"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
   elif (_1=="intpntScaling"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
   elif (_1=="intpntSolveForm"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
   if (_1=="logIntpnt"):
    if ((_2 - numpy.int32(_2))==0.0):
     _12=_2
     if (0 <= _12):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_INTPNT",_12)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"):
    if ((_2 - numpy.int32(_2))==0.0):
     _13=_2
     if (0 <= _13):
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_MAX_ITERATIONS",_13)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"):
    if ((_2 - numpy.int32(_2))==0.0):
     _14=_2
     if (0 <= _14):
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_OFF_COL_TRH",_14)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   elif (_1=="intpntOrderMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
   elif (_1=="intpntBasis"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
   elif (_1=="biIgnoreMaxIter"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
   elif (_1=="biIgnoreNumError"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
   if (_1=="intpntMaxNumCor"):
    if ((_2 - numpy.int32(_2))==0.0):
     _15=_2
     if ((- 1) <= _15):
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_MAX_NUM_COR",_15)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   elif (_1=="presolveUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
   if (_1=="presolveLevel"):
    if ((_2 - numpy.int32(_2))==0.0):
     _16=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LEVEL",_16)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"):
    if ((_2 - numpy.int32(_2))==0.0):
     _17=_2
     if (0 <= _17):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_PRESOLVE",_17)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   elif (_1=="presolveLindepUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
   if (_1=="presolveEliminatorMaxNumTries"):
    if ((_2 - numpy.int32(_2))==0.0):
     _18=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_18)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"):
    if ((_2 - numpy.int32(_2))==0.0):
     _19=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_19)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"):
    if ((_2 - numpy.int32(_2))==0.0):
     _20=_2
     if (0 <= _20):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_CRASH",_20)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"):
    if ((_2 - numpy.int32(_2))==0.0):
     _21=_2
     if (0 <= _21):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM",_21)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"):
    if ((_2 - numpy.int32(_2))==0.0):
     _22=_2
     if (0 <= _22):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM_MINOR",_22)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"):
    if ((_2 - numpy.int32(_2))==0.0):
     _23=_2
     if (0 <= _23):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM_FREQ",_23)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"):
    if ((_2 - numpy.int32(_2))==0.0):
     _24=_2
     if ((0 <= _24) and (_24 <= 100)):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_24)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   elif (_1=="simPrimalSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
   if (_1=="simDualRestrictSelection"):
    if ((_2 - numpy.int32(_2))==0.0):
     _25=_2
     if ((0 <= _25) and (_25 <= 100)):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_25)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   elif (_1=="simDualSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
   if (_1=="simMaxIterations"):
    if ((_2 - numpy.int32(_2))==0.0):
     _26=_2
     if (0 <= _26):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_MAX_ITERATIONS",_26)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   elif (_1=="simHotstartLu"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
   if (_1=="simRefactorFreq"):
    if ((_2 - numpy.int32(_2))==0.0):
     _27=_2
     if (0 <= _27):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_REFACTOR_FREQ",_27)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   elif (_1=="mioMode"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
   if (_1=="logMio"):
    if ((_2 - numpy.int32(_2))==0.0):
     _28=_2
     if (0 <= _28):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_MIO",_28)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"):
    if ((_2 - numpy.int32(_2))==0.0):
     _29=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_LOG_MIO_FREQ",_29)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"):
    if ((_2 - numpy.int32(_2))==0.0):
     _30=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_RELAXS",_30)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"):
    if ((_2 - numpy.int32(_2))==0.0):
     _31=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_31)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumSolutions"):
    if ((_2 - numpy.int32(_2))==0.0):
     _32=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_32)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   elif (_1=="mioNodeSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
   if (_1=="mioHeuristicLevel"):
    if ((_2 - numpy.int32(_2))==0.0):
     _33=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_MIO_HEURISTIC_LEVEL",_33)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"):
    if ((_2 - numpy.int32(_2))==0.0):
     _34=_2
     if (((- 1) <= _34) and (_34 <= 3)):
      _0._task_1put_1param_SD("MSK_IPAR_MIO_PROBING_LEVEL",_34)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioCutSelectionLevel"):
    if ((_2 - numpy.int32(_2))==0.0):
     _35=_2
     if (((- 1) <= _35) and (_35 <= 1)):
      _0._task_1put_1param_SD("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_35)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"):
    if ((_2 - numpy.int32(_2))==0.0):
     _36=_2
     if (((- 1) <= _36) and (_36 <= 2)):
      _0._task_1put_1param_SD("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_36)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   elif (_1=="mioBranchDir"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
   elif (_1=="mioRootOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
   elif (_1=="mioNodeOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
   elif (_1=="mioPerspectiveReformulate"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
   elif (_1=="writeLpQuotedNames"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpQuotedNames)")
   if (_1=="writeLpLineWidth"):
    if ((_2 - numpy.int32(_2))==0.0):
     _37=_2
     if (40 <= _37):
      _0._task_1put_1param_SD("MSK_IPAR_WRITE_LP_LINE_WIDTH",_37)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_1=="writeLpTermsPerLine"):
    if ((_2 - numpy.int32(_2))==0.0):
     _38=_2
     if (0 <= _38):
      _0._task_1put_1param_SD("MSK_IPAR_WRITE_LP_TERMS_PER_LINE",_38)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
   elif (_1=="writeLpFullObj"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
   if (_1=="logInfeasAna"):
    if ((_2 - numpy.int32(_2))==0.0):
     _39=_2
     if (0 <= _39):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_INFEAS_ANA",_39)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   elif (_1=="licenseWait"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
   elif (_1=="licenseSuppressExpireWrns"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
   if (_1=="licensePauseTime"):
    if ((_2 - numpy.int32(_2))==0.0):
     _40=_2
     if ((0 <= _40) and (_40 <= 1000000)):
      _0._task_1put_1param_SD("MSK_IPAR_LICENSE_PAUSE_TIME",_40)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   elif (_1=="licenseDebug"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
   if (_1=="log"):
    if ((_2 - numpy.int32(_2))==0.0):
     _41=_2
     if (0 <= _41):
      _0._task_1put_1param_SD("MSK_IPAR_LOG",_41)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"):
    if ((_2 - numpy.int32(_2))==0.0):
     _42=_2
     if (0 <= _42):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_EXPAND",_42)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"):
    if ((_2 - numpy.int32(_2))==0.0):
     _43=_2
     if (0 <= _43):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_FILE",_43)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"):
    if ((_2 - numpy.int32(_2))==0.0):
     _44=_2
     if (0 <= _44):
      _0._task_1put_1param_SD("MSK_IPAR_LOG_ORDER",_44)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   elif (_1=="simScaling"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
   elif (_1=="simScalingMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
   if (_1=="simPrimalPhaseoneMethod"):
    if ((_2 - numpy.int32(_2))==0.0):
     _45=_2
     if ((0 <= _45) and (_45 <= 10)):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_45)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"):
    if ((_2 - numpy.int32(_2))==0.0):
     _46=_2
     if ((0 <= _46) and (_46 <= 10)):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_46)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"):
    if ((_2 - numpy.int32(_2))==0.0):
     _47=_2
     if (0 <= _47):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_47)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   elif (_1=="simHotstart"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
   elif (_1=="simBasisFactorUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
   elif (_1=="simDegen"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
   elif (_1=="simReformulation"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
   elif (_1=="simExploitDupvec"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
   elif (_1=="simSaveLu"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
   elif (_1=="simNonSingular"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
   if (_1=="simDualCrash"):
    if ((_2 - numpy.int32(_2))==0.0):
     _48=_2
     if (0 <= _48):
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_CRASH",_48)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   elif (_1=="infeasPreferPrimal"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
   if (_1=="mioRootRepeatPresolveLevel"):
    if ((_2 - numpy.int32(_2))==0.0):
     _49=_2
     if (((- 1) <= _49) and (_49 <= 1)):
      _0._task_1put_1param_SD("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_49)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   elif (_1=="mioCutCmir"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
   elif (_1=="mioCutClique"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
   elif (_1=="mioCutImpliedBound"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
   elif (_1=="mioCutKnapsackCover"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
   elif (_1=="mioCutGmi"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
   elif (_1=="mioConstructSol"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConstructSol)")
   if (_1=="presolveLindepRelWorkTrh"):
    if ((_2 - numpy.int32(_2))==0.0):
     _50=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_50)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"):
    if ((_2 - numpy.int32(_2))==0.0):
     _51=_2
     if True:
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_51)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   elif (_1=="cacheLicense"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
   elif (_1=="intpntRegularizationUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
   elif (_1=="simSolveForm"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
   elif (_1=="simSwitchOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
   if (_1=="mioRinsMaxNodes"):
    if ((_2 - numpy.int32(_2))==0.0):
     _52=_2
     if ((- 1) <= _52):
      _0._task_1put_1param_SD("MSK_IPAR_MIO_RINS_MAX_NODES",_52)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="optimizerMaxTime"):
    _53=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_53)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"):
    _54=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_54)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"):
    _55=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_55)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"):
    _56=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_56)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"):
    _57=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_57)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"):
    _58=_2
    if (1.000000e-14 <= _58):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_58)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"):
    _59=_2
    if ((0.000000e+00 <= _59) and (_59 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_59)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"):
    _60=_2
    if ((1.000000e-06 <= _60) and (_60 <= 9.999990e-01)):
     _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_60)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"):
    _61=_2
    if ((1.000000e-04 <= _61) and (_61 <= 9.999990e-01)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_61)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"):
    _62=_2
    if ((0.000000e+00 <= _62) and (_62 <= 9.999000e-01)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_62)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"):
    _63=_2
    if ((0.000000e+00 <= _63) and (_63 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_63)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"):
    _64=_2
    if ((0.000000e+00 <= _64) and (_64 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_64)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"):
    _65=_2
    if ((0.000000e+00 <= _65) and (_65 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_65)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"):
    _66=_2
    if ((0.000000e+00 <= _66) and (_66 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_66)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"):
    _67=_2
    if ((0.000000e+00 <= _67) and (_67 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_67)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"):
    _68=_2
    if ((0.000000e+00 <= _68) and (_68 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_68)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"):
    _69=_2
    if ((0.000000e+00 <= _69) and (_69 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_69)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"):
    _70=_2
    if ((0.000000e+00 <= _70) and (_70 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_70)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"):
    _71=_2
    if (1.000000e+00 <= _71):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_71)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"):
    _72=_2
    if ((0.000000e+00 <= _72) and (_72 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_72)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntQoTolRelGap"):
    _73=_2
    if ((0.000000e+00 <= _73) and (_73 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_REL_GAP",_73)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolRelGap)")
   if (_1=="intpntQoTolPfeas"):
    _74=_2
    if ((0.000000e+00 <= _74) and (_74 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_PFEAS",_74)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolPfeas)")
   if (_1=="intpntQoTolDfeas"):
    _75=_2
    if ((0.000000e+00 <= _75) and (_75 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_DFEAS",_75)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolDfeas)")
   if (_1=="intpntQoTolMuRed"):
    _76=_2
    if ((0.000000e+00 <= _76) and (_76 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_MU_RED",_76)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolMuRed)")
   if (_1=="intpntQoTolNearRel"):
    _77=_2
    if (1.000000e+00 <= _77):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_NEAR_REL",_77)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolNearRel)")
   if (_1=="intpntQoTolInfeas"):
    _78=_2
    if ((0.000000e+00 <= _78) and (_78 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_INFEAS",_78)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolInfeas)")
   if (_1=="intpntTolPsafe"):
    _79=_2
    if (1.000000e-04 <= _79):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_79)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"):
    _80=_2
    if (1.000000e-04 <= _80):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_80)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"):
    _81=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_81)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioDisableTermTime"):
    _82=_2
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_MIO_DISABLE_TERM_TIME",_82)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDisableTermTime)")
   if (_1=="mioRelGapConst"):
    _83=_2
    if (1.000000e-15 <= _83):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_83)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"):
    _84=_2
    if (0.000000e+00 <= _84):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_84)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioNearTolRelGap"):
    _85=_2
    if (0.000000e+00 <= _85):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_NEAR_TOL_REL_GAP",_85)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolRelGap)")
   if (_1=="mioTolAbsGap"):
    _86=_2
    if (0.000000e+00 <= _86):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_86)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioNearTolAbsGap"):
    _87=_2
    if (0.000000e+00 <= _87):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_NEAR_TOL_ABS_GAP",_87)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"):
    _88=_2
    if (1.000000e-09 <= _88):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_88)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="basisTolX"):
    _89=_2
    if (1.000000e-09 <= _89):
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_89)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"):
    _90=_2
    if (1.000000e-09 <= _90):
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_90)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"):
    _91=_2
    if (0.000000e+00 <= _91):
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_91)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"):
    _92=_2
    if (0.000000e+00 <= _92):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_92)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolS"):
    _93=_2
    if (0.000000e+00 <= _93):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_93)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"):
    _94=_2
    if (1.000000e-15 <= _94):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_94)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"):
    _95=_2
    if (0.000000e+00 <= _95):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_95)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"):
    _96=_2
    if (0.000000e+00 <= _96):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_96)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"):
    _97=_2
    if (1.000000e-12 <= _97):
     _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_97)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"):
    _98=_2
    if ((1.000000e-09 <= _98) and (_98 <= 1.000000e-03)):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_98)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="anaSolInfeasTol"):
    _99=_2
    if (0.000000e+00 <= _99):
     _0._task_1put_1param_SD("MSK_DPAR_ANA_SOL_INFEAS_TOL",_99)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (anaSolInfeasTol)")
   if (_1=="mioTolRelDualBoundImprovement"):
    _100=_2
    if ((0.000000e+00 <= _100) and (_100 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_100)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SI(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SI(_0,_1,numpy.int32(__2))
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SI(_0,_1,_2):
   if False:
    pass
   elif (_1=="autoUpdateSolInfo"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
   elif (_1=="removeUnusedSolutions"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
   if (_1=="numThreads"):
    _3=_2
    if (0 <= _3):
     _0._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",_3)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   elif (_1=="intpntMultiThread"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMultiThread)")
   if (_1=="mtSpincount"):
    _4=_2
    if ((0 <= _4) and (_4 <= 1000000000)):
     _0._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",_4)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   elif (_1=="optimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
   if (_1=="biMaxIterations"):
    _5=_2
    if (0 <= _5):
     _0._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",_5)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"):
    _6=_2
    if (0 <= _6):
     _0._task_1put_1param_SI("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_6)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"):
    _7=_2
    if (0 <= _7):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",_7)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logAnaPro"):
    _8=_2
    if (0 <= _8):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_ANA_PRO",_8)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logAnaPro)")
   if (_1=="logResponse"):
    _9=_2
    if (0 <= _9):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",_9)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   if (_1=="logBi"):
    _10=_2
    if (0 <= _10):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_BI",_10)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"):
    _11=_2
    if (0 <= _11):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",_11)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   elif (_1=="biCleanOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
   elif (_1=="intpntStartingPoint"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
   elif (_1=="intpntDiffStep"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
   elif (_1=="intpntScaling"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
   elif (_1=="intpntSolveForm"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
   if (_1=="logIntpnt"):
    _12=_2
    if (0 <= _12):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",_12)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"):
    _13=_2
    if (0 <= _13):
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",_13)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"):
    _14=_2
    if (0 <= _14):
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",_14)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   elif (_1=="intpntOrderMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
   elif (_1=="intpntBasis"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
   elif (_1=="biIgnoreMaxIter"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
   elif (_1=="biIgnoreNumError"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
   if (_1=="intpntMaxNumCor"):
    _15=_2
    if ((- 1) <= _15):
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",_15)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   elif (_1=="presolveUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
   if (_1=="presolveLevel"):
    _16=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",_16)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"):
    _17=_2
    if (0 <= _17):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",_17)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   elif (_1=="presolveLindepUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
   if (_1=="presolveEliminatorMaxNumTries"):
    _18=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_18)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"):
    _19=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_19)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"):
    _20=_2
    if (0 <= _20):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",_20)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"):
    _21=_2
    if (0 <= _21):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM",_21)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"):
    _22=_2
    if (0 <= _22):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",_22)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"):
    _23=_2
    if (0 <= _23):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",_23)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"):
    _24=_2
    if ((0 <= _24) and (_24 <= 100)):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_24)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   elif (_1=="simPrimalSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
   if (_1=="simDualRestrictSelection"):
    _25=_2
    if ((0 <= _25) and (_25 <= 100)):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_25)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   elif (_1=="simDualSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
   if (_1=="simMaxIterations"):
    _26=_2
    if (0 <= _26):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",_26)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   elif (_1=="simHotstartLu"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
   if (_1=="simRefactorFreq"):
    _27=_2
    if (0 <= _27):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",_27)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   elif (_1=="mioMode"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
   if (_1=="logMio"):
    _28=_2
    if (0 <= _28):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO",_28)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"):
    _29=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",_29)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"):
    _30=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",_30)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"):
    _31=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_31)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumSolutions"):
    _32=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_32)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   elif (_1=="mioNodeSelection"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
   if (_1=="mioHeuristicLevel"):
    _33=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",_33)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"):
    _34=_2
    if (((- 1) <= _34) and (_34 <= 3)):
     _0._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",_34)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioCutSelectionLevel"):
    _35=_2
    if (((- 1) <= _35) and (_35 <= 1)):
     _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_35)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"):
    _36=_2
    if (((- 1) <= _36) and (_36 <= 2)):
     _0._task_1put_1param_SI("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_36)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   elif (_1=="mioBranchDir"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
   elif (_1=="mioRootOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
   elif (_1=="mioNodeOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
   elif (_1=="mioPerspectiveReformulate"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
   elif (_1=="writeLpQuotedNames"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpQuotedNames)")
   if (_1=="writeLpLineWidth"):
    _37=_2
    if (40 <= _37):
     _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_LINE_WIDTH",_37)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_1=="writeLpTermsPerLine"):
    _38=_2
    if (0 <= _38):
     _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_TERMS_PER_LINE",_38)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
   elif (_1=="writeLpFullObj"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
   if (_1=="logInfeasAna"):
    _39=_2
    if (0 <= _39):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",_39)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   elif (_1=="licenseWait"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
   elif (_1=="licenseSuppressExpireWrns"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
   if (_1=="licensePauseTime"):
    _40=_2
    if ((0 <= _40) and (_40 <= 1000000)):
     _0._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",_40)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   elif (_1=="licenseDebug"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
   if (_1=="log"):
    _41=_2
    if (0 <= _41):
     _0._task_1put_1param_SI("MSK_IPAR_LOG",_41)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"):
    _42=_2
    if (0 <= _42):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",_42)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"):
    _43=_2
    if (0 <= _43):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_FILE",_43)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"):
    _44=_2
    if (0 <= _44):
     _0._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",_44)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   elif (_1=="simScaling"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
   elif (_1=="simScalingMethod"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
   if (_1=="simPrimalPhaseoneMethod"):
    _45=_2
    if ((0 <= _45) and (_45 <= 10)):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_45)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"):
    _46=_2
    if ((0 <= _46) and (_46 <= 10)):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_46)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"):
    _47=_2
    if (0 <= _47):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_47)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   elif (_1=="simHotstart"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
   elif (_1=="simBasisFactorUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
   elif (_1=="simDegen"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
   elif (_1=="simReformulation"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
   elif (_1=="simExploitDupvec"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
   elif (_1=="simSaveLu"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
   elif (_1=="simNonSingular"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
   if (_1=="simDualCrash"):
    _48=_2
    if (0 <= _48):
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",_48)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   elif (_1=="infeasPreferPrimal"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
   if (_1=="mioRootRepeatPresolveLevel"):
    _49=_2
    if (((- 1) <= _49) and (_49 <= 1)):
     _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_49)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   elif (_1=="mioCutCmir"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
   elif (_1=="mioCutClique"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
   elif (_1=="mioCutImpliedBound"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
   elif (_1=="mioCutKnapsackCover"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
   elif (_1=="mioCutGmi"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
   elif (_1=="mioConstructSol"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConstructSol)")
   if (_1=="presolveLindepRelWorkTrh"):
    _50=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_50)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"):
    _51=_2
    if True:
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_51)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   elif (_1=="cacheLicense"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
   elif (_1=="intpntRegularizationUse"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
   elif (_1=="simSolveForm"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
   elif (_1=="simSwitchOptimizer"):
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
   if (_1=="mioRinsMaxNodes"):
    _52=_2
    if ((- 1) <= _52):
     _0._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",_52)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="optimizerMaxTime"):
    _53=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_53)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"):
    _54=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_54)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"):
    _55=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_55)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"):
    _56=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_56)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"):
    _57=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_57)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"):
    _58=numpy.float64(_2)
    if (1.000000e-14 <= _58):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_58)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"):
    _59=numpy.float64(_2)
    if ((0.000000e+00 <= _59) and (_59 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_59)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"):
    _60=numpy.float64(_2)
    if ((1.000000e-06 <= _60) and (_60 <= 9.999990e-01)):
     _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_60)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"):
    _61=numpy.float64(_2)
    if ((1.000000e-04 <= _61) and (_61 <= 9.999990e-01)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_61)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"):
    _62=numpy.float64(_2)
    if ((0.000000e+00 <= _62) and (_62 <= 9.999000e-01)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_62)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"):
    _63=numpy.float64(_2)
    if ((0.000000e+00 <= _63) and (_63 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_63)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"):
    _64=numpy.float64(_2)
    if ((0.000000e+00 <= _64) and (_64 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_64)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"):
    _65=numpy.float64(_2)
    if ((0.000000e+00 <= _65) and (_65 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_65)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"):
    _66=numpy.float64(_2)
    if ((0.000000e+00 <= _66) and (_66 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_66)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"):
    _67=numpy.float64(_2)
    if ((0.000000e+00 <= _67) and (_67 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_67)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"):
    _68=numpy.float64(_2)
    if ((0.000000e+00 <= _68) and (_68 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_68)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"):
    _69=numpy.float64(_2)
    if ((0.000000e+00 <= _69) and (_69 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_69)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"):
    _70=numpy.float64(_2)
    if ((0.000000e+00 <= _70) and (_70 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_70)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"):
    _71=numpy.float64(_2)
    if (1.000000e+00 <= _71):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_71)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"):
    _72=numpy.float64(_2)
    if ((0.000000e+00 <= _72) and (_72 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_72)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntQoTolRelGap"):
    _73=numpy.float64(_2)
    if ((0.000000e+00 <= _73) and (_73 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_REL_GAP",_73)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolRelGap)")
   if (_1=="intpntQoTolPfeas"):
    _74=numpy.float64(_2)
    if ((0.000000e+00 <= _74) and (_74 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_PFEAS",_74)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolPfeas)")
   if (_1=="intpntQoTolDfeas"):
    _75=numpy.float64(_2)
    if ((0.000000e+00 <= _75) and (_75 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_DFEAS",_75)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolDfeas)")
   if (_1=="intpntQoTolMuRed"):
    _76=numpy.float64(_2)
    if ((0.000000e+00 <= _76) and (_76 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_MU_RED",_76)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolMuRed)")
   if (_1=="intpntQoTolNearRel"):
    _77=numpy.float64(_2)
    if (1.000000e+00 <= _77):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_NEAR_REL",_77)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolNearRel)")
   if (_1=="intpntQoTolInfeas"):
    _78=numpy.float64(_2)
    if ((0.000000e+00 <= _78) and (_78 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_INFEAS",_78)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolInfeas)")
   if (_1=="intpntTolPsafe"):
    _79=numpy.float64(_2)
    if (1.000000e-04 <= _79):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_79)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"):
    _80=numpy.float64(_2)
    if (1.000000e-04 <= _80):
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_80)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"):
    _81=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_81)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioDisableTermTime"):
    _82=numpy.float64(_2)
    if True:
     _0._task_1put_1param_SD("MSK_DPAR_MIO_DISABLE_TERM_TIME",_82)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDisableTermTime)")
   if (_1=="mioRelGapConst"):
    _83=numpy.float64(_2)
    if (1.000000e-15 <= _83):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_83)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"):
    _84=numpy.float64(_2)
    if (0.000000e+00 <= _84):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_84)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioNearTolRelGap"):
    _85=numpy.float64(_2)
    if (0.000000e+00 <= _85):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_NEAR_TOL_REL_GAP",_85)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolRelGap)")
   if (_1=="mioTolAbsGap"):
    _86=numpy.float64(_2)
    if (0.000000e+00 <= _86):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_86)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioNearTolAbsGap"):
    _87=numpy.float64(_2)
    if (0.000000e+00 <= _87):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_NEAR_TOL_ABS_GAP",_87)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"):
    _88=numpy.float64(_2)
    if (1.000000e-09 <= _88):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_88)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="basisTolX"):
    _89=numpy.float64(_2)
    if (1.000000e-09 <= _89):
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_89)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"):
    _90=numpy.float64(_2)
    if (1.000000e-09 <= _90):
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_90)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"):
    _91=numpy.float64(_2)
    if (0.000000e+00 <= _91):
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_91)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"):
    _92=numpy.float64(_2)
    if (0.000000e+00 <= _92):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_92)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolS"):
    _93=numpy.float64(_2)
    if (0.000000e+00 <= _93):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_93)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"):
    _94=numpy.float64(_2)
    if (1.000000e-15 <= _94):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_94)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"):
    _95=numpy.float64(_2)
    if (0.000000e+00 <= _95):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_95)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"):
    _96=numpy.float64(_2)
    if (0.000000e+00 <= _96):
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_96)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"):
    _97=numpy.float64(_2)
    if (1.000000e-12 <= _97):
     _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_97)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"):
    _98=numpy.float64(_2)
    if ((1.000000e-09 <= _98) and (_98 <= 1.000000e-03)):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_98)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="anaSolInfeasTol"):
    _99=numpy.float64(_2)
    if (0.000000e+00 <= _99):
     _0._task_1put_1param_SD("MSK_DPAR_ANA_SOL_INFEAS_TOL",_99)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (anaSolInfeasTol)")
   if (_1=="mioTolRelDualBoundImprovement"):
    _100=numpy.float64(_2)
    if ((0.000000e+00 <= _100) and (_100 <= 1.000000e+00)):
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_100)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SS(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_S__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SS(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_S__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SS(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SS(_0,_1,_2)
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SS(_0,_1,_2):
   if False:
    pass
   if (_1=="autoUpdateSolInfo"):
    _3=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_3 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
    _0._task_1put_1param_SI("MSK_IPAR_AUTO_UPDATE_SOL_INFO",_3)
    return 
   if (_1=="removeUnusedSolutions"):
    _4=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_4 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
    _0._task_1put_1param_SI("MSK_IPAR_REMOVE_UNUSED_SOLUTIONS",_4)
    return 
   if (_1=="numThreads"):
    try:
     _5=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _5):
      _0._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",_5)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
    except mosek_fusion_ValueConversionError as _6:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   if (_1=="intpntMultiThread"):
    _7=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_7 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMultiThread)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MULTI_THREAD",_7)
    return 
   if (_1=="mtSpincount"):
    try:
     _8=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _8) and (_8 <= 1000000000)):
      _0._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",_8)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
    except mosek_fusion_ValueConversionError as _9:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   if (_1=="optimizer"):
    _10=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_10 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_OPTIMIZER",_10)
    return 
   if (_1=="biMaxIterations"):
    try:
     _11=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _11):
      _0._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",_11)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
    except mosek_fusion_ValueConversionError as _12:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"):
    try:
     _13=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _13):
      _0._task_1put_1param_SI("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_13)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
    except mosek_fusion_ValueConversionError as _14:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"):
    try:
     _15=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _15):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",_15)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
    except mosek_fusion_ValueConversionError as _16:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logAnaPro"):
    try:
     _17=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _17):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_ANA_PRO",_17)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logAnaPro)")
    except mosek_fusion_ValueConversionError as _18:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logAnaPro)")
   if (_1=="logResponse"):
    try:
     _19=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _19):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",_19)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
    except mosek_fusion_ValueConversionError as _20:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   if (_1=="logBi"):
    try:
     _21=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _21):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_BI",_21)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
    except mosek_fusion_ValueConversionError as _22:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"):
    try:
     _23=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _23):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",_23)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
    except mosek_fusion_ValueConversionError as _24:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   if (_1=="biCleanOptimizer"):
    _25=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_25 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_CLEAN_OPTIMIZER",_25)
    return 
   if (_1=="intpntStartingPoint"):
    _26=mosek.fusion.Parameters.__string_1to_1startpointtype_1value_S(_2)
    if (_26 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_STARTING_POINT",_26)
    return 
   if (_1=="intpntDiffStep"):
    _27=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_27 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_DIFF_STEP",_27)
    return 
   if (_1=="intpntScaling"):
    _28=mosek.fusion.Parameters.__string_1to_1scalingtype_1value_S(_2)
    if (_28 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_SCALING",_28)
    return 
   if (_1=="intpntSolveForm"):
    _29=mosek.fusion.Parameters.__string_1to_1solveform_1value_S(_2)
    if (_29 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_SOLVE_FORM",_29)
    return 
   if (_1=="logIntpnt"):
    try:
     _30=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _30):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",_30)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
    except mosek_fusion_ValueConversionError as _31:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"):
    try:
     _32=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _32):
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",_32)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
    except mosek_fusion_ValueConversionError as _33:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"):
    try:
     _34=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _34):
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",_34)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
    except mosek_fusion_ValueConversionError as _35:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   if (_1=="intpntOrderMethod"):
    _36=mosek.fusion.Parameters.__string_1to_1orderingtype_1value_S(_2)
    if (_36 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_METHOD",_36)
    return 
   if (_1=="intpntBasis"):
    _37=mosek.fusion.Parameters.__string_1to_1basindtype_1value_S(_2)
    if (_37 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_BASIS",_37)
    return 
   if (_1=="biIgnoreMaxIter"):
    _38=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_38 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_MAX_ITER",_38)
    return 
   if (_1=="biIgnoreNumError"):
    _39=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_39 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_NUM_ERROR",_39)
    return 
   if (_1=="intpntMaxNumCor"):
    try:
     _40=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((- 1) <= _40):
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",_40)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
    except mosek_fusion_ValueConversionError as _41:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   if (_1=="presolveUse"):
    _42=mosek.fusion.Parameters.__string_1to_1presolvemode_1value_S(_2)
    if (_42 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
    _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_USE",_42)
    return 
   if (_1=="presolveLevel"):
    try:
     _43=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",_43)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
    except mosek_fusion_ValueConversionError as _44:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"):
    try:
     _45=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _45):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",_45)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
    except mosek_fusion_ValueConversionError as _46:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   if (_1=="presolveLindepUse"):
    _47=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_47 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
    _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_USE",_47)
    return 
   if (_1=="presolveEliminatorMaxNumTries"):
    try:
     _48=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_48)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    except mosek_fusion_ValueConversionError as _49:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"):
    try:
     _50=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_50)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
    except mosek_fusion_ValueConversionError as _51:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"):
    try:
     _52=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _52):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",_52)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
    except mosek_fusion_ValueConversionError as _53:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"):
    try:
     _54=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _54):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM",_54)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
    except mosek_fusion_ValueConversionError as _55:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"):
    try:
     _56=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _56):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",_56)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
    except mosek_fusion_ValueConversionError as _57:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"):
    try:
     _58=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _58):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",_58)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
    except mosek_fusion_ValueConversionError as _59:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"):
    try:
     _60=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _60) and (_60 <= 100)):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_60)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
    except mosek_fusion_ValueConversionError as _61:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   if (_1=="simPrimalSelection"):
    _62=mosek.fusion.Parameters.__string_1to_1simseltype_1value_S(_2)
    if (_62 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_SELECTION",_62)
    return 
   if (_1=="simDualRestrictSelection"):
    try:
     _63=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _63) and (_63 <= 100)):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_63)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
    except mosek_fusion_ValueConversionError as _64:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   if (_1=="simDualSelection"):
    _65=mosek.fusion.Parameters.__string_1to_1simseltype_1value_S(_2)
    if (_65 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_SELECTION",_65)
    return 
   if (_1=="simMaxIterations"):
    try:
     _66=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _66):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",_66)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
    except mosek_fusion_ValueConversionError as _67:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   if (_1=="simHotstartLu"):
    _68=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_68 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART_LU",_68)
    return 
   if (_1=="simRefactorFreq"):
    try:
     _69=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _69):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",_69)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
    except mosek_fusion_ValueConversionError as _70:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_1=="mioMode"):
    _71=mosek.fusion.Parameters.__string_1to_1miomode_1value_S(_2)
    if (_71 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_MODE",_71)
    return 
   if (_1=="logMio"):
    try:
     _72=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _72):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO",_72)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
    except mosek_fusion_ValueConversionError as _73:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"):
    try:
     _74=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",_74)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
    except mosek_fusion_ValueConversionError as _75:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"):
    try:
     _76=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",_76)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
    except mosek_fusion_ValueConversionError as _77:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"):
    try:
     _78=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_78)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
    except mosek_fusion_ValueConversionError as _79:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumSolutions"):
    try:
     _80=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_80)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
    except mosek_fusion_ValueConversionError as _81:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   if (_1=="mioNodeSelection"):
    _82=mosek.fusion.Parameters.__string_1to_1mionodeseltype_1value_S(_2)
    if (_82 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_NODE_SELECTION",_82)
    return 
   if (_1=="mioHeuristicLevel"):
    try:
     _83=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",_83)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
    except mosek_fusion_ValueConversionError as _84:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"):
    try:
     _85=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _85) and (_85 <= 3)):
      _0._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",_85)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
    except mosek_fusion_ValueConversionError as _86:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioCutSelectionLevel"):
    try:
     _87=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _87) and (_87 <= 1)):
      _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_87)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
    except mosek_fusion_ValueConversionError as _88:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"):
    try:
     _89=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _89) and (_89 <= 2)):
      _0._task_1put_1param_SI("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_89)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
    except mosek_fusion_ValueConversionError as _90:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   if (_1=="mioBranchDir"):
    _91=mosek.fusion.Parameters.__string_1to_1branchdir_1value_S(_2)
    if (_91 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_BRANCH_DIR",_91)
    return 
   if (_1=="mioRootOptimizer"):
    _92=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_92 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_OPTIMIZER",_92)
    return 
   if (_1=="mioNodeOptimizer"):
    _93=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_93 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_NODE_OPTIMIZER",_93)
    return 
   if (_1=="mioPerspectiveReformulate"):
    _94=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_94 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE",_94)
    return 
   if (_1=="writeLpQuotedNames"):
    _95=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_95 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpQuotedNames)")
    _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_QUOTED_NAMES",_95)
    return 
   if (_1=="writeLpLineWidth"):
    try:
     _96=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (40 <= _96):
      _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_LINE_WIDTH",_96)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
    except mosek_fusion_ValueConversionError as _97:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_1=="writeLpTermsPerLine"):
    try:
     _98=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _98):
      _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_TERMS_PER_LINE",_98)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
    except mosek_fusion_ValueConversionError as _99:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
   if (_1=="writeLpFullObj"):
    _100=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_100 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
    _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_FULL_OBJ",_100)
    return 
   if (_1=="logInfeasAna"):
    try:
     _101=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _101):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",_101)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
    except mosek_fusion_ValueConversionError as _102:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   if (_1=="licenseWait"):
    _103=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_103 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_WAIT",_103)
    return 
   if (_1=="licenseSuppressExpireWrns"):
    _104=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_104 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS",_104)
    return 
   if (_1=="licensePauseTime"):
    try:
     _105=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _105) and (_105 <= 1000000)):
      _0._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",_105)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
    except mosek_fusion_ValueConversionError as _106:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   if (_1=="licenseDebug"):
    _107=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_107 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_DEBUG",_107)
    return 
   if (_1=="log"):
    try:
     _108=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _108):
      _0._task_1put_1param_SI("MSK_IPAR_LOG",_108)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
    except mosek_fusion_ValueConversionError as _109:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"):
    try:
     _110=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _110):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",_110)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
    except mosek_fusion_ValueConversionError as _111:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"):
    try:
     _112=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _112):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_FILE",_112)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
    except mosek_fusion_ValueConversionError as _113:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"):
    try:
     _114=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _114):
      _0._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",_114)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
    except mosek_fusion_ValueConversionError as _115:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   if (_1=="simScaling"):
    _116=mosek.fusion.Parameters.__string_1to_1scalingtype_1value_S(_2)
    if (_116 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SCALING",_116)
    return 
   if (_1=="simScalingMethod"):
    _117=mosek.fusion.Parameters.__string_1to_1scalingmethod_1value_S(_2)
    if (_117 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SCALING_METHOD",_117)
    return 
   if (_1=="simPrimalPhaseoneMethod"):
    try:
     _118=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _118) and (_118 <= 10)):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_118)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
    except mosek_fusion_ValueConversionError as _119:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"):
    try:
     _120=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _120) and (_120 <= 10)):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_120)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
    except mosek_fusion_ValueConversionError as _121:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"):
    try:
     _122=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _122):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_122)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
    except mosek_fusion_ValueConversionError as _123:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   if (_1=="simHotstart"):
    _124=mosek.fusion.Parameters.__string_1to_1simhotstart_1value_S(_2)
    if (_124 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART",_124)
    return 
   if (_1=="simBasisFactorUse"):
    _125=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_125 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_BASIS_FACTOR_USE",_125)
    return 
   if (_1=="simDegen"):
    _126=mosek.fusion.Parameters.__string_1to_1simdegen_1value_S(_2)
    if (_126 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_DEGEN",_126)
    return 
   if (_1=="simReformulation"):
    _127=mosek.fusion.Parameters.__string_1to_1simreform_1value_S(_2)
    if (_127 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_REFORMULATION",_127)
    return 
   if (_1=="simExploitDupvec"):
    _128=mosek.fusion.Parameters.__string_1to_1simdupvec_1value_S(_2)
    if (_128 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_EXPLOIT_DUPVEC",_128)
    return 
   if (_1=="simSaveLu"):
    _129=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_129 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SAVE_LU",_129)
    return 
   if (_1=="simNonSingular"):
    _130=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_130 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_NON_SINGULAR",_130)
    return 
   if (_1=="simDualCrash"):
    try:
     _131=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _131):
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",_131)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
    except mosek_fusion_ValueConversionError as _132:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   if (_1=="infeasPreferPrimal"):
    _133=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_133 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
    _0._task_1put_1param_SI("MSK_IPAR_INFEAS_PREFER_PRIMAL",_133)
    return 
   if (_1=="mioRootRepeatPresolveLevel"):
    try:
     _134=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _134) and (_134 <= 1)):
      _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_134)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
    except mosek_fusion_ValueConversionError as _135:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   if (_1=="mioCutCmir"):
    _136=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_136 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CMIR",_136)
    return 
   if (_1=="mioCutClique"):
    _137=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_137 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CLIQUE",_137)
    return 
   if (_1=="mioCutImpliedBound"):
    _138=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_138 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_IMPLIED_BOUND",_138)
    return 
   if (_1=="mioCutKnapsackCover"):
    _139=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_139 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_KNAPSACK_COVER",_139)
    return 
   if (_1=="mioCutGmi"):
    _140=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_140 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_GMI",_140)
    return 
   if (_1=="mioConstructSol"):
    _141=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_141 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConstructSol)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CONSTRUCT_SOL",_141)
    return 
   if (_1=="presolveLindepRelWorkTrh"):
    try:
     _142=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_142)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
    except mosek_fusion_ValueConversionError as _143:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"):
    try:
     _144=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True:
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_144)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    except mosek_fusion_ValueConversionError as _145:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   if (_1=="cacheLicense"):
    _146=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_146 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
    _0._task_1put_1param_SI("MSK_IPAR_CACHE_LICENSE",_146)
    return 
   if (_1=="intpntRegularizationUse"):
    _147=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_147 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_REGULARIZATION_USE",_147)
    return 
   if (_1=="simSolveForm"):
    _148=mosek.fusion.Parameters.__string_1to_1solveform_1value_S(_2)
    if (_148 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SOLVE_FORM",_148)
    return 
   if (_1=="simSwitchOptimizer"):
    _149=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_149 < 0):
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SWITCH_OPTIMIZER",_149)
    return 
   if (_1=="mioRinsMaxNodes"):
    try:
     _150=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((- 1) <= _150):
      _0._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",_150)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
    except mosek_fusion_ValueConversionError as _151:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="optimizerMaxTime"):
    try:
     _152=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_152)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
    except mosek_fusion_ValueConversionError as _153:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"):
    try:
     _154=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_154)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
    except mosek_fusion_ValueConversionError as _155:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"):
    try:
     _156=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_156)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
    except mosek_fusion_ValueConversionError as _157:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"):
    try:
     _158=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_158)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
    except mosek_fusion_ValueConversionError as _159:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"):
    try:
     _160=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_160)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
    except mosek_fusion_ValueConversionError as _161:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"):
    try:
     _162=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-14 <= _162):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_162)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
    except mosek_fusion_ValueConversionError as _163:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"):
    try:
     _164=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _164) and (_164 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_164)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
    except mosek_fusion_ValueConversionError as _165:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"):
    try:
     _166=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-06 <= _166) and (_166 <= 9.999990e-01)):
      _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_166)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
    except mosek_fusion_ValueConversionError as _167:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"):
    try:
     _168=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-04 <= _168) and (_168 <= 9.999990e-01)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_168)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
    except mosek_fusion_ValueConversionError as _169:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"):
    try:
     _170=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _170) and (_170 <= 9.999000e-01)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_170)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
    except mosek_fusion_ValueConversionError as _171:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"):
    try:
     _172=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _172) and (_172 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_172)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
    except mosek_fusion_ValueConversionError as _173:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"):
    try:
     _174=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _174) and (_174 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_174)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
    except mosek_fusion_ValueConversionError as _175:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"):
    try:
     _176=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _176) and (_176 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_176)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
    except mosek_fusion_ValueConversionError as _177:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"):
    try:
     _178=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _178) and (_178 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_178)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
    except mosek_fusion_ValueConversionError as _179:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"):
    try:
     _180=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _180) and (_180 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_180)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
    except mosek_fusion_ValueConversionError as _181:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"):
    try:
     _182=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _182) and (_182 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_182)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
    except mosek_fusion_ValueConversionError as _183:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"):
    try:
     _184=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _184) and (_184 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_184)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
    except mosek_fusion_ValueConversionError as _185:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"):
    try:
     _186=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _186) and (_186 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_186)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
    except mosek_fusion_ValueConversionError as _187:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"):
    try:
     _188=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e+00 <= _188):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_188)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
    except mosek_fusion_ValueConversionError as _189:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"):
    try:
     _190=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _190) and (_190 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_190)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
    except mosek_fusion_ValueConversionError as _191:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntQoTolRelGap"):
    try:
     _192=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _192) and (_192 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_REL_GAP",_192)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolRelGap)")
    except mosek_fusion_ValueConversionError as _193:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolRelGap)")
   if (_1=="intpntQoTolPfeas"):
    try:
     _194=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _194) and (_194 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_PFEAS",_194)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolPfeas)")
    except mosek_fusion_ValueConversionError as _195:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolPfeas)")
   if (_1=="intpntQoTolDfeas"):
    try:
     _196=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _196) and (_196 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_DFEAS",_196)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolDfeas)")
    except mosek_fusion_ValueConversionError as _197:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolDfeas)")
   if (_1=="intpntQoTolMuRed"):
    try:
     _198=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _198) and (_198 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_MU_RED",_198)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolMuRed)")
    except mosek_fusion_ValueConversionError as _199:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolMuRed)")
   if (_1=="intpntQoTolNearRel"):
    try:
     _200=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e+00 <= _200):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_NEAR_REL",_200)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolNearRel)")
    except mosek_fusion_ValueConversionError as _201:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolNearRel)")
   if (_1=="intpntQoTolInfeas"):
    try:
     _202=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _202) and (_202 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_QO_TOL_INFEAS",_202)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolInfeas)")
    except mosek_fusion_ValueConversionError as _203:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntQoTolInfeas)")
   if (_1=="intpntTolPsafe"):
    try:
     _204=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-04 <= _204):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_204)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
    except mosek_fusion_ValueConversionError as _205:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"):
    try:
     _206=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-04 <= _206):
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_206)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
    except mosek_fusion_ValueConversionError as _207:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"):
    try:
     _208=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_208)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
    except mosek_fusion_ValueConversionError as _209:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioDisableTermTime"):
    try:
     _210=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True:
      _0._task_1put_1param_SD("MSK_DPAR_MIO_DISABLE_TERM_TIME",_210)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDisableTermTime)")
    except mosek_fusion_ValueConversionError as _211:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDisableTermTime)")
   if (_1=="mioRelGapConst"):
    try:
     _212=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-15 <= _212):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_212)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
    except mosek_fusion_ValueConversionError as _213:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"):
    try:
     _214=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _214):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_214)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
    except mosek_fusion_ValueConversionError as _215:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioNearTolRelGap"):
    try:
     _216=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _216):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_NEAR_TOL_REL_GAP",_216)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolRelGap)")
    except mosek_fusion_ValueConversionError as _217:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolRelGap)")
   if (_1=="mioTolAbsGap"):
    try:
     _218=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _218):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_218)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
    except mosek_fusion_ValueConversionError as _219:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioNearTolAbsGap"):
    try:
     _220=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _220):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_NEAR_TOL_ABS_GAP",_220)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolAbsGap)")
    except mosek_fusion_ValueConversionError as _221:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNearTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"):
    try:
     _222=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _222):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_222)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
    except mosek_fusion_ValueConversionError as _223:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="basisTolX"):
    try:
     _224=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _224):
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_224)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
    except mosek_fusion_ValueConversionError as _225:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"):
    try:
     _226=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _226):
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_226)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
    except mosek_fusion_ValueConversionError as _227:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"):
    try:
     _228=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _228):
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_228)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
    except mosek_fusion_ValueConversionError as _229:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"):
    try:
     _230=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _230):
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_230)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
    except mosek_fusion_ValueConversionError as _231:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolS"):
    try:
     _232=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _232):
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_232)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
    except mosek_fusion_ValueConversionError as _233:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"):
    try:
     _234=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-15 <= _234):
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_234)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
    except mosek_fusion_ValueConversionError as _235:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"):
    try:
     _236=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _236):
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_236)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
    except mosek_fusion_ValueConversionError as _237:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"):
    try:
     _238=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _238):
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_238)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
    except mosek_fusion_ValueConversionError as _239:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"):
    try:
     _240=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-12 <= _240):
      _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_240)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
    except mosek_fusion_ValueConversionError as _241:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"):
    try:
     _242=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-09 <= _242) and (_242 <= 1.000000e-03)):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_242)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
    except mosek_fusion_ValueConversionError as _243:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="anaSolInfeasTol"):
    try:
     _244=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _244):
      _0._task_1put_1param_SD("MSK_DPAR_ANA_SOL_INFEAS_TOL",_244)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (anaSolInfeasTol)")
    except mosek_fusion_ValueConversionError as _245:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (anaSolInfeasTol)")
   if (_1=="mioTolRelDualBoundImprovement"):
    try:
     _246=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _246) and (_246 <= 1.000000e+00)):
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_246)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
    except mosek_fusion_ValueConversionError as _247:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def __string_1to_1miocontsoltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1miocontsoltype_1value_S(_0)
  @staticmethod
  def __string_1to_1miocontsoltype_1value_S(_0):
   if (_0=="none"):
    return numpy.int32(0)
   if (_0=="root"):
    return numpy.int32(1)
   if (_0=="itg"):
    return numpy.int32(2)
   if (_0=="itgRel"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1dinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1dinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1dinf_1value_S(_0):
   if (_0=="sensitivityPrimalTime"):
    return numpy.int32(79)
   if (_0=="sensitivityDualTime"):
    return numpy.int32(78)
   if (_0=="intpntCompGap"):
    return numpy.int32(11)
   if (_0=="intpntGfeas"):
    return numpy.int32(57)
   if (_0=="intpntMu"):
    return numpy.int32(64)
   if (_0=="intpntInitIterTime"):
    return numpy.int32(59)
   if (_0=="intpntFactorTime"):
    return numpy.int32(55)
   if (_0=="intpntInitSearchTime"):
    return numpy.int32(60)
   if (_0=="intpntFormSearchTime"):
    return numpy.int32(56)
   if (_0=="intpntUpdateTime"):
    return numpy.int32(68)
   if (_0=="intpntFactorSetupTime"):
    return numpy.int32(52)
   if (_0=="intpntFactorSchurTime"):
    return numpy.int32(46)
   if (_0=="intpntFactorHatSchurTime"):
    return numpy.int32(31)
   if (_0=="intpntFactorHatSchurPushTime"):
    return numpy.int32(30)
   if (_0=="intpntFactorHatSchurPullTime"):
    return numpy.int32(28)
   if (_0=="intpntFactorBarSchurTime"):
    return numpy.int32(15)
   if (_0=="intpntFactorBarSchurDeTabTime"):
    return numpy.int32(12)
   if (_0=="intpntFactorBarSchurSpTabTime"):
    return numpy.int32(14)
   if (_0=="intpntFactorSparseLTime"):
    return numpy.int32(54)
   if (_0=="intpntFactorDenseLTime"):
    return numpy.int32(20)
   if (_0=="intpntFactorHataTime"):
    return numpy.int32(34)
   if (_0=="intpntFactorHataSolveTime"):
    return numpy.int32(33)
   if (_0=="intpntFactorHatvTime"):
    return numpy.int32(41)
   if (_0=="intpntFactorHatathataTime"):
    return numpy.int32(36)
   if (_0=="intpntFactorHatvthatvTime"):
    return numpy.int32(43)
   if (_0=="intpntFactorDotlInitTime"):
    return numpy.int32(24)
   if (_0=="intpntFactorDotlFactorTime"):
    return numpy.int32(23)
   if (_0=="intpntFactorHatldInitTime"):
    return numpy.int32(39)
   if (_0=="intpntFactorHatldFactorTime"):
    return numpy.int32(38)
   if (_0=="intpntFactorDenseTime"):
    return numpy.int32(21)
   if (_0=="intpntIterNonCorrectorFlops"):
    return numpy.int32(61)
   if (_0=="intpntIterOneCorrectorFlops"):
    return numpy.int32(62)
   if (_0=="intpntSolveTime"):
    return numpy.int32(67)
   if (_0=="intpntIterRefTime"):
    return numpy.int32(63)
   if (_0=="intpntSolveSparseLTime"):
    return numpy.int32(66)
   if (_0=="intpntSolveDenseLTime"):
    return numpy.int32(65)
   if (_0=="intpntFactorSetupFlops"):
    return numpy.int32(48)
   if (_0=="intpntFactorSetupHatSchurFlops"):
    return numpy.int32(50)
   if (_0=="intpntFactorSchurFlops"):
    return numpy.int32(45)
   if (_0=="intpntFactorHatSchurFlops"):
    return numpy.int32(26)
   if (_0=="intpntFactorHatSchurPushFlops"):
    return numpy.int32(29)
   if (_0=="intpntFactorHatSchurPullFlops"):
    return numpy.int32(27)
   if (_0=="intpntFactorBarSchurFlops"):
    return numpy.int32(13)
   if (_0=="intpntFactorSparseLFlops"):
    return numpy.int32(53)
   if (_0=="intpntFactorMlOrderSparseLFlops"):
    return numpy.int32(44)
   if (_0=="intpntFactorGpOrderSparseLFlops"):
    return numpy.int32(25)
   if (_0=="intpntFactorDenseLFlops"):
    return numpy.int32(19)
   if (_0=="intpntFactorBvFlops"):
    return numpy.int32(16)
   if (_0=="intpntFactorBvtbvFlops"):
    return numpy.int32(17)
   if (_0=="intpntFactorHataFlops"):
    return numpy.int32(32)
   if (_0=="intpntFactorHatvFlops"):
    return numpy.int32(40)
   if (_0=="intpntFactorDenseFlops"):
    return numpy.int32(18)
   if (_0=="intpntFactorHatathataFlops"):
    return numpy.int32(35)
   if (_0=="intpntFactorHatvthatvFlops"):
    return numpy.int32(42)
   if (_0=="intpntFactorDotlFactorFlops"):
    return numpy.int32(22)
   if (_0=="intpntFactorHatldFactorFlops"):
    return numpy.int32(37)
   if (_0=="presolveAcoltTime"):
    return numpy.int32(69)
   if (_0=="presolveSetupTime"):
    return numpy.int32(74)
   if (_0=="presolveCheckproTime"):
    return numpy.int32(70)
   if (_0=="presolveDupconTime"):
    return numpy.int32(71)
   if (_0=="presolveDupvarTime"):
    return numpy.int32(72)
   if (_0=="presolveFinalTime"):
    return numpy.int32(73)
   if (_0=="presolveSubDomvarTime"):
    return numpy.int32(75)
   if (_0=="presolveSubRelaxTime"):
    return numpy.int32(76)
   if (_0=="primalSimplexInftime"):
    return numpy.int32(77)
   if (_0=="dualSimplexInftime"):
    return numpy.int32(10)
   if (_0=="intpntGpOrderSavedFlops"):
    return numpy.int32(58)
   if (_0=="intpntFactorSetupDetectDenseTime"):
    return numpy.int32(47)
   if (_0=="intpntFactorSetupMlOrderTime"):
    return numpy.int32(51)
   if (_0=="intpntFactorSetupGpOrderTime"):
    return numpy.int32(49)
   if (_0=="biCrashTime"):
    return numpy.int32(1)
   if (_0=="biCrashLuTime"):
    return numpy.int32(0)
   if (_0=="biFactorTime"):
    return numpy.int32(5)
   if (_0=="biFactorWork"):
    return numpy.int32(6)
   if (_0=="biPrimalDone"):
    return numpy.int32(7)
   if (_0=="biDualDone"):
    return numpy.int32(2)
   if (_0=="simPrimalObj"):
    return numpy.int32(83)
   if (_0=="simPrimalFeas"):
    return numpy.int32(82)
   if (_0=="simDualObj"):
    return numpy.int32(81)
   if (_0=="simDualFeas"):
    return numpy.int32(80)
   if (_0=="biPrimalObj"):
    return numpy.int32(9)
   if (_0=="biDualObj"):
    return numpy.int32(4)
   if (_0=="biPrimalFeas"):
    return numpy.int32(8)
   if (_0=="biDualFeas"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1presolvemode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1presolvemode_1value_S(_0)
  @staticmethod
  def __string_1to_1presolvemode_1value_S(_0):
   if (_0=="off"):
    return numpy.int32(0)
   if (_0=="on"):
    return numpy.int32(1)
   if (_0=="free"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1optimizertype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1optimizertype_1value_S(_0)
  @staticmethod
  def __string_1to_1optimizertype_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(2)
   if (_0=="intpnt"):
    return numpy.int32(4)
   if (_0=="conic"):
    return numpy.int32(0)
   if (_0=="primalSimplex"):
    return numpy.int32(6)
   if (_0=="dualSimplex"):
    return numpy.int32(1)
   if (_0=="freeSimplex"):
    return numpy.int32(3)
   if (_0=="mixedInt"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1stakey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1stakey_1value_S(_0)
  @staticmethod
  def __string_1to_1stakey_1value_S(_0):
   if (_0=="unk"):
    return numpy.int32(0)
   if (_0=="bas"):
    return numpy.int32(1)
   if (_0=="supbas"):
    return numpy.int32(2)
   if (_0=="low"):
    return numpy.int32(3)
   if (_0=="upr"):
    return numpy.int32(4)
   if (_0=="fix"):
    return numpy.int32(5)
   if (_0=="inf"):
    return numpy.int32(6)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1iinfitem_1value_S(_0):
   if (_0=="anaProNumCon"):
    return numpy.int32(0)
   if (_0=="anaProNumConLo"):
    return numpy.int32(3)
   if (_0=="anaProNumConUp"):
    return numpy.int32(5)
   if (_0=="anaProNumConRa"):
    return numpy.int32(4)
   if (_0=="anaProNumConEq"):
    return numpy.int32(1)
   if (_0=="anaProNumConFr"):
    return numpy.int32(2)
   if (_0=="anaProNumVar"):
    return numpy.int32(6)
   if (_0=="anaProNumVarLo"):
    return numpy.int32(12)
   if (_0=="anaProNumVarUp"):
    return numpy.int32(14)
   if (_0=="anaProNumVarRa"):
    return numpy.int32(13)
   if (_0=="anaProNumVarEq"):
    return numpy.int32(9)
   if (_0=="anaProNumVarFr"):
    return numpy.int32(10)
   if (_0=="anaProNumVarCont"):
    return numpy.int32(8)
   if (_0=="anaProNumVarBin"):
    return numpy.int32(7)
   if (_0=="anaProNumVarInt"):
    return numpy.int32(11)
   if (_0=="optimizeResponse"):
    return numpy.int32(51)
   if (_0=="intpntIter"):
    return numpy.int32(16)
   if (_0=="intpntFactorDimDense"):
    return numpy.int32(15)
   if (_0=="intpntSolveDual"):
    return numpy.int32(18)
   if (_0=="mioNodeDepth"):
    return numpy.int32(26)
   if (_0=="mioNumcon"):
    return numpy.int32(37)
   if (_0=="mioNumvar"):
    return numpy.int32(39)
   if (_0=="mioNumint"):
    return numpy.int32(38)
   if (_0=="mioPresolvedNumcont"):
    return numpy.int32(43)
   if (_0=="mioPresolvedNumbin"):
    return numpy.int32(41)
   if (_0=="mioPresolvedNumcon"):
    return numpy.int32(42)
   if (_0=="mioPresolvedNumvar"):
    return numpy.int32(45)
   if (_0=="mioPresolvedNumint"):
    return numpy.int32(44)
   if (_0=="mioCliqueTableSize"):
    return numpy.int32(20)
   if (_0=="mioConstructSolution"):
    return numpy.int32(22)
   if (_0=="mioConstructNumRoundings"):
    return numpy.int32(21)
   if (_0=="mioNumIntSolutions"):
    return numpy.int32(33)
   if (_0=="mioObjBoundDefined"):
    return numpy.int32(40)
   if (_0=="mioNumActiveNodes"):
    return numpy.int32(27)
   if (_0=="mioNumRelax"):
    return numpy.int32(35)
   if (_0=="mioNumBranch"):
    return numpy.int32(28)
   if (_0=="mioTotalNumCuts"):
    return numpy.int32(47)
   if (_0=="mioNumCmirCuts"):
    return numpy.int32(30)
   if (_0=="mioNumCliqueCuts"):
    return numpy.int32(29)
   if (_0=="mioNumImpliedBoundCuts"):
    return numpy.int32(32)
   if (_0=="mioNumKnapsackCoverCuts"):
    return numpy.int32(34)
   if (_0=="mioNumGomoryCuts"):
    return numpy.int32(31)
   if (_0=="mioNumRepeatedPresolve"):
    return numpy.int32(36)
   if (_0=="mioInitialSolution"):
    return numpy.int32(23)
   if (_0=="mioUserObjCut"):
    return numpy.int32(48)
   if (_0=="mioRelgapSatisfied"):
    return numpy.int32(46)
   if (_0=="mioAbsgapSatisfied"):
    return numpy.int32(19)
   if (_0=="mioNearRelgapSatisfied"):
    return numpy.int32(25)
   if (_0=="mioNearAbsgapSatisfied"):
    return numpy.int32(24)
   if (_0=="rdProtype"):
    return numpy.int32(58)
   if (_0=="rdNumcon"):
    return numpy.int32(53)
   if (_0=="rdNumvar"):
    return numpy.int32(57)
   if (_0=="rdNumbarvar"):
    return numpy.int32(52)
   if (_0=="rdNumintvar"):
    return numpy.int32(55)
   if (_0=="rdNumq"):
    return numpy.int32(56)
   if (_0=="simDualDegIter"):
    return numpy.int32(59)
   if (_0=="simDualInfIter"):
    return numpy.int32(62)
   if (_0=="simDualHotstartLu"):
    return numpy.int32(61)
   if (_0=="simPrimalIter"):
    return numpy.int32(70)
   if (_0=="simDualIter"):
    return numpy.int32(63)
   if (_0=="intpntNumThreads"):
    return numpy.int32(17)
   if (_0=="simPrimalInfIter"):
    return numpy.int32(69)
   if (_0=="simPrimalDegIter"):
    return numpy.int32(66)
   if (_0=="simPrimalHotstart"):
    return numpy.int32(67)
   if (_0=="simPrimalHotstartLu"):
    return numpy.int32(68)
   if (_0=="simDualHotstart"):
    return numpy.int32(60)
   if (_0=="solItrProsta"):
    return numpy.int32(76)
   if (_0=="solItrSolsta"):
    return numpy.int32(77)
   if (_0=="solBasProsta"):
    return numpy.int32(72)
   if (_0=="solBasSolsta"):
    return numpy.int32(73)
   if (_0=="solItgProsta"):
    return numpy.int32(74)
   if (_0=="solItgSolsta"):
    return numpy.int32(75)
   if (_0=="simNumcon"):
    return numpy.int32(64)
   if (_0=="simNumvar"):
    return numpy.int32(65)
   if (_0=="optNumcon"):
    return numpy.int32(49)
   if (_0=="optNumvar"):
    return numpy.int32(50)
   if (_0=="stoNumARealloc"):
    return numpy.int32(78)
   if (_0=="rdNumcone"):
    return numpy.int32(54)
   if (_0=="simSolveDual"):
    return numpy.int32(71)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simreform_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simreform_1value_S(_0)
  @staticmethod
  def __string_1to_1simreform_1value_S(_0):
   if (_0=="on"):
    return numpy.int32(1)
   if (_0=="off"):
    return numpy.int32(0)
   if (_0=="free"):
    return numpy.int32(2)
   if (_0=="aggressive"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1value_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1value_1value_S(_0)
  @staticmethod
  def __string_1to_1value_1value_S(_0):
   if (_0=="maxStrLen"):
    return numpy.int32(1024)
   if (_0=="licenseBufferLength"):
    return numpy.int32(21)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1scalingmethod_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1scalingmethod_1value_S(_0)
  @staticmethod
  def __string_1to_1scalingmethod_1value_S(_0):
   if (_0=="pow2"):
    return numpy.int32(0)
   if (_0=="free"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1soltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1soltype_1value_S(_0)
  @staticmethod
  def __string_1to_1soltype_1value_S(_0):
   if (_0=="bas"):
    return numpy.int32(1)
   if (_0=="itr"):
    return numpy.int32(0)
   if (_0=="itg"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1startpointtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1startpointtype_1value_S(_0)
  @staticmethod
  def __string_1to_1startpointtype_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="guess"):
    return numpy.int32(1)
   if (_0=="constant"):
    return numpy.int32(2)
   if (_0=="satisfyBounds"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1language_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1language_1value_S(_0)
  @staticmethod
  def __string_1to_1language_1value_S(_0):
   if (_0=="eng"):
    return numpy.int32(0)
   if (_0=="dan"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1checkconvexitytype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1checkconvexitytype_1value_S(_0)
  @staticmethod
  def __string_1to_1checkconvexitytype_1value_S(_0):
   if (_0=="none"):
    return numpy.int32(0)
   if (_0=="simple"):
    return numpy.int32(1)
   if (_0=="full"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1variabletype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1variabletype_1value_S(_0)
  @staticmethod
  def __string_1to_1variabletype_1value_S(_0):
   if (_0=="typeCont"):
    return numpy.int32(0)
   if (_0=="typeInt"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mpsformat_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mpsformat_1value_S(_0)
  @staticmethod
  def __string_1to_1mpsformat_1value_S(_0):
   if (_0=="strict"):
    return numpy.int32(0)
   if (_0=="relaxed"):
    return numpy.int32(1)
   if (_0=="free"):
    return numpy.int32(2)
   if (_0=="cplex"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1nametype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1nametype_1value_S(_0)
  @staticmethod
  def __string_1to_1nametype_1value_S(_0):
   if (_0=="gen"):
    return numpy.int32(0)
   if (_0=="mps"):
    return numpy.int32(1)
   if (_0=="lp"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1compresstype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1compresstype_1value_S(_0)
  @staticmethod
  def __string_1to_1compresstype_1value_S(_0):
   if (_0=="none"):
    return numpy.int32(0)
   if (_0=="free"):
    return numpy.int32(1)
   if (_0=="gzip"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simdupvec_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simdupvec_1value_S(_0)
  @staticmethod
  def __string_1to_1simdupvec_1value_S(_0):
   if (_0=="on"):
    return numpy.int32(1)
   if (_0=="off"):
    return numpy.int32(0)
   if (_0=="free"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dparam_1value_S(_0)
  @staticmethod
  def __string_1to_1dparam_1value_S(_0):
   if (_0=="dataTolCjLarge"):
    return numpy.int32(14)
   if (_0=="dataTolCHuge"):
    return numpy.int32(13)
   if (_0=="dataTolAij"):
    return numpy.int32(8)
   if (_0=="dataTolAijLarge"):
    return numpy.int32(10)
   if (_0=="dataTolAijHuge"):
    return numpy.int32(9)
   if (_0=="dataSymMatTol"):
    return numpy.int32(5)
   if (_0=="dataSymMatTolLarge"):
    return numpy.int32(7)
   if (_0=="dataSymMatTolHuge"):
    return numpy.int32(6)
   if (_0=="dataTolBoundInf"):
    return numpy.int32(11)
   if (_0=="dataTolBoundWrn"):
    return numpy.int32(12)
   if (_0=="dataTolQij"):
    return numpy.int32(15)
   if (_0=="dataTolX"):
    return numpy.int32(16)
   if (_0=="semidefiniteTolApprox"):
    return numpy.int32(65)
   if (_0=="optimizerMaxTime"):
    return numpy.int32(58)
   if (_0=="lowerObjCut"):
    return numpy.int32(46)
   if (_0=="upperObjCut"):
    return numpy.int32(68)
   if (_0=="upperObjCutFiniteTrh"):
    return numpy.int32(69)
   if (_0=="lowerObjCutFiniteTrh"):
    return numpy.int32(47)
   if (_0=="intpntTolRelGap"):
    return numpy.int32(43)
   if (_0=="intpntNlTolRelGap"):
    return numpy.int32(28)
   if (_0=="intpntTolStepSize"):
    return numpy.int32(45)
   if (_0=="simLuTolRelPiv"):
    return numpy.int32(66)
   if (_0=="intpntTolRelStep"):
    return numpy.int32(44)
   if (_0=="intpntNlTolRelStep"):
    return numpy.int32(29)
   if (_0=="intpntNlMeritBal"):
    return numpy.int32(23)
   if (_0=="intpntTolPath"):
    return numpy.int32(40)
   if (_0=="intpntTolPfeas"):
    return numpy.int32(41)
   if (_0=="intpntTolDfeas"):
    return numpy.int32(36)
   if (_0=="intpntTolMuRed"):
    return numpy.int32(39)
   if (_0=="intpntNlTolPfeas"):
    return numpy.int32(27)
   if (_0=="intpntNlTolDfeas"):
    return numpy.int32(24)
   if (_0=="intpntNlTolMuRed"):
    return numpy.int32(25)
   if (_0=="intpntNlTolNearRel"):
    return numpy.int32(26)
   if (_0=="intpntTolInfeas"):
    return numpy.int32(38)
   if (_0=="intpntCoTolRelGap"):
    return numpy.int32(22)
   if (_0=="intpntCoTolPfeas"):
    return numpy.int32(21)
   if (_0=="intpntCoTolDfeas"):
    return numpy.int32(17)
   if (_0=="intpntCoTolMuRed"):
    return numpy.int32(19)
   if (_0=="intpntCoTolNearRel"):
    return numpy.int32(20)
   if (_0=="intpntCoTolInfeas"):
    return numpy.int32(18)
   if (_0=="intpntQoTolRelGap"):
    return numpy.int32(35)
   if (_0=="intpntQoTolPfeas"):
    return numpy.int32(34)
   if (_0=="intpntQoTolDfeas"):
    return numpy.int32(30)
   if (_0=="intpntQoTolMuRed"):
    return numpy.int32(32)
   if (_0=="intpntQoTolNearRel"):
    return numpy.int32(33)
   if (_0=="intpntQoTolInfeas"):
    return numpy.int32(31)
   if (_0=="intpntTolPsafe"):
    return numpy.int32(42)
   if (_0=="intpntTolDsafe"):
    return numpy.int32(37)
   if (_0=="mioMaxTime"):
    return numpy.int32(49)
   if (_0=="mioDisableTermTime"):
    return numpy.int32(48)
   if (_0=="mioRelGapConst"):
    return numpy.int32(52)
   if (_0=="mioTolRelGap"):
    return numpy.int32(57)
   if (_0=="mioNearTolRelGap"):
    return numpy.int32(51)
   if (_0=="mioTolAbsGap"):
    return numpy.int32(53)
   if (_0=="mioNearTolAbsGap"):
    return numpy.int32(50)
   if (_0=="mioTolAbsRelaxInt"):
    return numpy.int32(54)
   if (_0=="basisTolX"):
    return numpy.int32(3)
   if (_0=="basisTolS"):
    return numpy.int32(2)
   if (_0=="basisRelTolS"):
    return numpy.int32(1)
   if (_0=="presolveTolX"):
    return numpy.int32(63)
   if (_0=="presolveTolS"):
    return numpy.int32(62)
   if (_0=="presolveTolAij"):
    return numpy.int32(60)
   if (_0=="presolveTolAbsLindep"):
    return numpy.int32(59)
   if (_0=="presolveTolRelLindep"):
    return numpy.int32(61)
   if (_0=="simplexAbsTolPiv"):
    return numpy.int32(67)
   if (_0=="mioTolFeas"):
    return numpy.int32(55)
   if (_0=="anaSolInfeasTol"):
    return numpy.int32(0)
   if (_0=="checkConvexityRelTol"):
    return numpy.int32(4)
   if (_0=="qcqoReformulateRelDropTol"):
    return numpy.int32(64)
   if (_0=="mioTolRelDualBoundImprovement"):
    return numpy.int32(56)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1inftype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1inftype_1value_S(_0)
  @staticmethod
  def __string_1to_1inftype_1value_S(_0):
   if (_0=="douType"):
    return numpy.int32(0)
   if (_0=="intType"):
    return numpy.int32(1)
   if (_0=="lintType"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1problemtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1problemtype_1value_S(_0)
  @staticmethod
  def __string_1to_1problemtype_1value_S(_0):
   if (_0=="lo"):
    return numpy.int32(0)
   if (_0=="qo"):
    return numpy.int32(1)
   if (_0=="qcqo"):
    return numpy.int32(2)
   if (_0=="geco"):
    return numpy.int32(3)
   if (_0=="conic"):
    return numpy.int32(4)
   if (_0=="mixed"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1orderingtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1orderingtype_1value_S(_0)
  @staticmethod
  def __string_1to_1orderingtype_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="appminloc"):
    return numpy.int32(1)
   if (_0=="experimental"):
    return numpy.int32(2)
   if (_0=="tryGraphpar"):
    return numpy.int32(3)
   if (_0=="forceGraphpar"):
    return numpy.int32(4)
   if (_0=="none"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dataformat_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dataformat_1value_S(_0)
  @staticmethod
  def __string_1to_1dataformat_1value_S(_0):
   if (_0=="extension"):
    return numpy.int32(0)
   if (_0=="mps"):
    return numpy.int32(1)
   if (_0=="lp"):
    return numpy.int32(2)
   if (_0=="op"):
    return numpy.int32(3)
   if (_0=="xml"):
    return numpy.int32(4)
   if (_0=="freeMps"):
    return numpy.int32(5)
   if (_0=="task"):
    return numpy.int32(6)
   if (_0=="cb"):
    return numpy.int32(7)
   if (_0=="jsonTask"):
    return numpy.int32(8)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simdegen_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simdegen_1value_S(_0)
  @staticmethod
  def __string_1to_1simdegen_1value_S(_0):
   if (_0=="none"):
    return numpy.int32(0)
   if (_0=="free"):
    return numpy.int32(1)
   if (_0=="aggressive"):
    return numpy.int32(2)
   if (_0=="moderate"):
    return numpy.int32(3)
   if (_0=="minimum"):
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1onoffkey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1onoffkey_1value_S(_0)
  @staticmethod
  def __string_1to_1onoffkey_1value_S(_0):
   if (_0=="on"):
    return numpy.int32(1)
   if (_0=="off"):
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1transpose_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1transpose_1value_S(_0)
  @staticmethod
  def __string_1to_1transpose_1value_S(_0):
   if (_0=="no"):
    return numpy.int32(0)
   if (_0=="yes"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mionodeseltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mionodeseltype_1value_S(_0)
  @staticmethod
  def __string_1to_1mionodeseltype_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="first"):
    return numpy.int32(1)
   if (_0=="best"):
    return numpy.int32(2)
   if (_0=="worst"):
    return numpy.int32(3)
   if (_0=="hybrid"):
    return numpy.int32(4)
   if (_0=="pseudo"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1rescode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1rescode_1value_S(_0)
  @staticmethod
  def __string_1to_1rescode_1value_S(_0):
   if (_0=="ok"):
    return numpy.int32(0)
   if (_0=="wrnOpenParamFile"):
    return numpy.int32(50)
   if (_0=="wrnLargeBound"):
    return numpy.int32(51)
   if (_0=="wrnLargeLoBound"):
    return numpy.int32(52)
   if (_0=="wrnLargeUpBound"):
    return numpy.int32(53)
   if (_0=="wrnLargeConFx"):
    return numpy.int32(54)
   if (_0=="wrnLargeCj"):
    return numpy.int32(57)
   if (_0=="wrnLargeAij"):
    return numpy.int32(62)
   if (_0=="wrnZeroAij"):
    return numpy.int32(63)
   if (_0=="wrnNameMaxLen"):
    return numpy.int32(65)
   if (_0=="wrnSparMaxLen"):
    return numpy.int32(66)
   if (_0=="wrnMpsSplitRhsVector"):
    return numpy.int32(70)
   if (_0=="wrnMpsSplitRanVector"):
    return numpy.int32(71)
   if (_0=="wrnMpsSplitBouVector"):
    return numpy.int32(72)
   if (_0=="wrnLpOldQuadFormat"):
    return numpy.int32(80)
   if (_0=="wrnLpDropVariable"):
    return numpy.int32(85)
   if (_0=="wrnNzInUprTri"):
    return numpy.int32(200)
   if (_0=="wrnDroppedNzQobj"):
    return numpy.int32(201)
   if (_0=="wrnIgnoreInteger"):
    return numpy.int32(250)
   if (_0=="wrnNoGlobalOptimizer"):
    return numpy.int32(251)
   if (_0=="wrnMioInfeasibleFinal"):
    return numpy.int32(270)
   if (_0=="wrnSolFilter"):
    return numpy.int32(300)
   if (_0=="wrnUndefSolFileName"):
    return numpy.int32(350)
   if (_0=="wrnSolFileIgnoredCon"):
    return numpy.int32(351)
   if (_0=="wrnSolFileIgnoredVar"):
    return numpy.int32(352)
   if (_0=="wrnTooFewBasisVars"):
    return numpy.int32(400)
   if (_0=="wrnTooManyBasisVars"):
    return numpy.int32(405)
   if (_0=="wrnNoNonlinearFunctionWrite"):
    return numpy.int32(450)
   if (_0=="wrnLicenseExpire"):
    return numpy.int32(500)
   if (_0=="wrnLicenseServer"):
    return numpy.int32(501)
   if (_0=="wrnEmptyName"):
    return numpy.int32(502)
   if (_0=="wrnUsingGenericNames"):
    return numpy.int32(503)
   if (_0=="wrnLicenseFeatureExpire"):
    return numpy.int32(505)
   if (_0=="wrnParamNameDou"):
    return numpy.int32(510)
   if (_0=="wrnParamNameInt"):
    return numpy.int32(511)
   if (_0=="wrnParamNameStr"):
    return numpy.int32(512)
   if (_0=="wrnParamStrValue"):
    return numpy.int32(515)
   if (_0=="wrnParamIgnoredCmio"):
    return numpy.int32(516)
   if (_0=="wrnZerosInSparseRow"):
    return numpy.int32(705)
   if (_0=="wrnZerosInSparseCol"):
    return numpy.int32(710)
   if (_0=="wrnIncompleteLinearDependencyCheck"):
    return numpy.int32(800)
   if (_0=="wrnEliminatorSpace"):
    return numpy.int32(801)
   if (_0=="wrnPresolveOutofspace"):
    return numpy.int32(802)
   if (_0=="wrnWriteChangedNames"):
    return numpy.int32(803)
   if (_0=="wrnWriteDiscardedCfix"):
    return numpy.int32(804)
   if (_0=="wrnConstructSolutionInfeas"):
    return numpy.int32(805)
   if (_0=="wrnConstructInvalidSolItg"):
    return numpy.int32(807)
   if (_0=="wrnConstructNoSolItg"):
    return numpy.int32(810)
   if (_0=="wrnDuplicateConstraintNames"):
    return numpy.int32(850)
   if (_0=="wrnDuplicateVariableNames"):
    return numpy.int32(851)
   if (_0=="wrnDuplicateBarvariableNames"):
    return numpy.int32(852)
   if (_0=="wrnDuplicateConeNames"):
    return numpy.int32(853)
   if (_0=="wrnAnaLargeBounds"):
    return numpy.int32(900)
   if (_0=="wrnAnaCZero"):
    return numpy.int32(901)
   if (_0=="wrnAnaEmptyCols"):
    return numpy.int32(902)
   if (_0=="wrnAnaCloseBounds"):
    return numpy.int32(903)
   if (_0=="wrnAnaAlmostIntBounds"):
    return numpy.int32(904)
   if (_0=="wrnQuadConesWithRootFixedAtZero"):
    return numpy.int32(930)
   if (_0=="wrnRquadConesWithRootFixedAtZero"):
    return numpy.int32(931)
   if (_0=="wrnNoDualizer"):
    return numpy.int32(950)
   if (_0=="wrnSymMatLarge"):
    return numpy.int32(960)
   if (_0=="errLicense"):
    return numpy.int32(1000)
   if (_0=="errLicenseExpired"):
    return numpy.int32(1001)
   if (_0=="errLicenseVersion"):
    return numpy.int32(1002)
   if (_0=="errSizeLicense"):
    return numpy.int32(1005)
   if (_0=="errProbLicense"):
    return numpy.int32(1006)
   if (_0=="errFileLicense"):
    return numpy.int32(1007)
   if (_0=="errMissingLicenseFile"):
    return numpy.int32(1008)
   if (_0=="errSizeLicenseCon"):
    return numpy.int32(1010)
   if (_0=="errSizeLicenseVar"):
    return numpy.int32(1011)
   if (_0=="errSizeLicenseIntvar"):
    return numpy.int32(1012)
   if (_0=="errOptimizerLicense"):
    return numpy.int32(1013)
   if (_0=="errFlexlm"):
    return numpy.int32(1014)
   if (_0=="errLicenseServer"):
    return numpy.int32(1015)
   if (_0=="errLicenseMax"):
    return numpy.int32(1016)
   if (_0=="errLicenseMoseklmDaemon"):
    return numpy.int32(1017)
   if (_0=="errLicenseFeature"):
    return numpy.int32(1018)
   if (_0=="errPlatformNotLicensed"):
    return numpy.int32(1019)
   if (_0=="errLicenseCannotAllocate"):
    return numpy.int32(1020)
   if (_0=="errLicenseCannotConnect"):
    return numpy.int32(1021)
   if (_0=="errLicenseInvalidHostid"):
    return numpy.int32(1025)
   if (_0=="errLicenseServerVersion"):
    return numpy.int32(1026)
   if (_0=="errLicenseNoServerSupport"):
    return numpy.int32(1027)
   if (_0=="errLicenseNoServerLine"):
    return numpy.int32(1028)
   if (_0=="errOpenDl"):
    return numpy.int32(1030)
   if (_0=="errOlderDll"):
    return numpy.int32(1035)
   if (_0=="errNewerDll"):
    return numpy.int32(1036)
   if (_0=="errLinkFileDll"):
    return numpy.int32(1040)
   if (_0=="errThreadMutexInit"):
    return numpy.int32(1045)
   if (_0=="errThreadMutexLock"):
    return numpy.int32(1046)
   if (_0=="errThreadMutexUnlock"):
    return numpy.int32(1047)
   if (_0=="errThreadCreate"):
    return numpy.int32(1048)
   if (_0=="errThreadCondInit"):
    return numpy.int32(1049)
   if (_0=="errUnknown"):
    return numpy.int32(1050)
   if (_0=="errSpace"):
    return numpy.int32(1051)
   if (_0=="errFileOpen"):
    return numpy.int32(1052)
   if (_0=="errFileRead"):
    return numpy.int32(1053)
   if (_0=="errFileWrite"):
    return numpy.int32(1054)
   if (_0=="errDataFileExt"):
    return numpy.int32(1055)
   if (_0=="errInvalidFileName"):
    return numpy.int32(1056)
   if (_0=="errInvalidSolFileName"):
    return numpy.int32(1057)
   if (_0=="errEndOfFile"):
    return numpy.int32(1059)
   if (_0=="errNullEnv"):
    return numpy.int32(1060)
   if (_0=="errNullTask"):
    return numpy.int32(1061)
   if (_0=="errInvalidStream"):
    return numpy.int32(1062)
   if (_0=="errNoInitEnv"):
    return numpy.int32(1063)
   if (_0=="errInvalidTask"):
    return numpy.int32(1064)
   if (_0=="errNullPointer"):
    return numpy.int32(1065)
   if (_0=="errLivingTasks"):
    return numpy.int32(1066)
   if (_0=="errBlankName"):
    return numpy.int32(1070)
   if (_0=="errDupName"):
    return numpy.int32(1071)
   if (_0=="errInvalidObjName"):
    return numpy.int32(1075)
   if (_0=="errInvalidConName"):
    return numpy.int32(1076)
   if (_0=="errInvalidVarName"):
    return numpy.int32(1077)
   if (_0=="errInvalidConeName"):
    return numpy.int32(1078)
   if (_0=="errInvalidBarvarName"):
    return numpy.int32(1079)
   if (_0=="errSpaceLeaking"):
    return numpy.int32(1080)
   if (_0=="errSpaceNoInfo"):
    return numpy.int32(1081)
   if (_0=="errReadFormat"):
    return numpy.int32(1090)
   if (_0=="errMpsFile"):
    return numpy.int32(1100)
   if (_0=="errMpsInvField"):
    return numpy.int32(1101)
   if (_0=="errMpsInvMarker"):
    return numpy.int32(1102)
   if (_0=="errMpsNullConName"):
    return numpy.int32(1103)
   if (_0=="errMpsNullVarName"):
    return numpy.int32(1104)
   if (_0=="errMpsUndefConName"):
    return numpy.int32(1105)
   if (_0=="errMpsUndefVarName"):
    return numpy.int32(1106)
   if (_0=="errMpsInvConKey"):
    return numpy.int32(1107)
   if (_0=="errMpsInvBoundKey"):
    return numpy.int32(1108)
   if (_0=="errMpsInvSecName"):
    return numpy.int32(1109)
   if (_0=="errMpsNoObjective"):
    return numpy.int32(1110)
   if (_0=="errMpsSplittedVar"):
    return numpy.int32(1111)
   if (_0=="errMpsMulConName"):
    return numpy.int32(1112)
   if (_0=="errMpsMulQsec"):
    return numpy.int32(1113)
   if (_0=="errMpsMulQobj"):
    return numpy.int32(1114)
   if (_0=="errMpsInvSecOrder"):
    return numpy.int32(1115)
   if (_0=="errMpsMulCsec"):
    return numpy.int32(1116)
   if (_0=="errMpsConeType"):
    return numpy.int32(1117)
   if (_0=="errMpsConeOverlap"):
    return numpy.int32(1118)
   if (_0=="errMpsConeRepeat"):
    return numpy.int32(1119)
   if (_0=="errMpsNonSymmetricQ"):
    return numpy.int32(1120)
   if (_0=="errMpsDuplicateQElement"):
    return numpy.int32(1121)
   if (_0=="errMpsInvalidObjsense"):
    return numpy.int32(1122)
   if (_0=="errMpsTabInField2"):
    return numpy.int32(1125)
   if (_0=="errMpsTabInField3"):
    return numpy.int32(1126)
   if (_0=="errMpsTabInField5"):
    return numpy.int32(1127)
   if (_0=="errMpsInvalidObjName"):
    return numpy.int32(1128)
   if (_0=="errLpIncompatible"):
    return numpy.int32(1150)
   if (_0=="errLpEmpty"):
    return numpy.int32(1151)
   if (_0=="errLpDupSlackName"):
    return numpy.int32(1152)
   if (_0=="errWriteMpsInvalidName"):
    return numpy.int32(1153)
   if (_0=="errLpInvalidVarName"):
    return numpy.int32(1154)
   if (_0=="errLpFreeConstraint"):
    return numpy.int32(1155)
   if (_0=="errWriteOpfInvalidVarName"):
    return numpy.int32(1156)
   if (_0=="errLpFileFormat"):
    return numpy.int32(1157)
   if (_0=="errWriteLpFormat"):
    return numpy.int32(1158)
   if (_0=="errReadLpMissingEndTag"):
    return numpy.int32(1159)
   if (_0=="errLpFormat"):
    return numpy.int32(1160)
   if (_0=="errWriteLpNonUniqueName"):
    return numpy.int32(1161)
   if (_0=="errReadLpNonexistingName"):
    return numpy.int32(1162)
   if (_0=="errLpWriteConicProblem"):
    return numpy.int32(1163)
   if (_0=="errLpWriteGecoProblem"):
    return numpy.int32(1164)
   if (_0=="errWritingFile"):
    return numpy.int32(1166)
   if (_0=="errOpfFormat"):
    return numpy.int32(1168)
   if (_0=="errOpfNewVariable"):
    return numpy.int32(1169)
   if (_0=="errInvalidNameInSolFile"):
    return numpy.int32(1170)
   if (_0=="errLpInvalidConName"):
    return numpy.int32(1171)
   if (_0=="errOpfPrematureEof"):
    return numpy.int32(1172)
   if (_0=="errJsonSyntax"):
    return numpy.int32(1175)
   if (_0=="errJsonString"):
    return numpy.int32(1176)
   if (_0=="errJsonNumberOverflow"):
    return numpy.int32(1177)
   if (_0=="errJsonFormat"):
    return numpy.int32(1178)
   if (_0=="errJsonData"):
    return numpy.int32(1179)
   if (_0=="errJsonMissingData"):
    return numpy.int32(1180)
   if (_0=="errArgumentLenneq"):
    return numpy.int32(1197)
   if (_0=="errArgumentType"):
    return numpy.int32(1198)
   if (_0=="errNrArguments"):
    return numpy.int32(1199)
   if (_0=="errInArgument"):
    return numpy.int32(1200)
   if (_0=="errArgumentDimension"):
    return numpy.int32(1201)
   if (_0=="errIndexIsTooSmall"):
    return numpy.int32(1203)
   if (_0=="errIndexIsTooLarge"):
    return numpy.int32(1204)
   if (_0=="errParamName"):
    return numpy.int32(1205)
   if (_0=="errParamNameDou"):
    return numpy.int32(1206)
   if (_0=="errParamNameInt"):
    return numpy.int32(1207)
   if (_0=="errParamNameStr"):
    return numpy.int32(1208)
   if (_0=="errParamIndex"):
    return numpy.int32(1210)
   if (_0=="errParamIsTooLarge"):
    return numpy.int32(1215)
   if (_0=="errParamIsTooSmall"):
    return numpy.int32(1216)
   if (_0=="errParamValueStr"):
    return numpy.int32(1217)
   if (_0=="errParamType"):
    return numpy.int32(1218)
   if (_0=="errInfDouIndex"):
    return numpy.int32(1219)
   if (_0=="errInfIntIndex"):
    return numpy.int32(1220)
   if (_0=="errIndexArrIsTooSmall"):
    return numpy.int32(1221)
   if (_0=="errIndexArrIsTooLarge"):
    return numpy.int32(1222)
   if (_0=="errInfLintIndex"):
    return numpy.int32(1225)
   if (_0=="errArgIsTooSmall"):
    return numpy.int32(1226)
   if (_0=="errArgIsTooLarge"):
    return numpy.int32(1227)
   if (_0=="errInvalidWhichsol"):
    return numpy.int32(1228)
   if (_0=="errInfDouName"):
    return numpy.int32(1230)
   if (_0=="errInfIntName"):
    return numpy.int32(1231)
   if (_0=="errInfType"):
    return numpy.int32(1232)
   if (_0=="errInfLintName"):
    return numpy.int32(1234)
   if (_0=="errIndex"):
    return numpy.int32(1235)
   if (_0=="errWhichsol"):
    return numpy.int32(1236)
   if (_0=="errSolitem"):
    return numpy.int32(1237)
   if (_0=="errWhichitemNotAllowed"):
    return numpy.int32(1238)
   if (_0=="errMaxnumcon"):
    return numpy.int32(1240)
   if (_0=="errMaxnumvar"):
    return numpy.int32(1241)
   if (_0=="errMaxnumbarvar"):
    return numpy.int32(1242)
   if (_0=="errMaxnumqnz"):
    return numpy.int32(1243)
   if (_0=="errTooSmallMaxNumNz"):
    return numpy.int32(1245)
   if (_0=="errInvalidIdx"):
    return numpy.int32(1246)
   if (_0=="errInvalidMaxNum"):
    return numpy.int32(1247)
   if (_0=="errNumconlim"):
    return numpy.int32(1250)
   if (_0=="errNumvarlim"):
    return numpy.int32(1251)
   if (_0=="errTooSmallMaxnumanz"):
    return numpy.int32(1252)
   if (_0=="errInvAptre"):
    return numpy.int32(1253)
   if (_0=="errMulAElement"):
    return numpy.int32(1254)
   if (_0=="errInvBk"):
    return numpy.int32(1255)
   if (_0=="errInvBkc"):
    return numpy.int32(1256)
   if (_0=="errInvBkx"):
    return numpy.int32(1257)
   if (_0=="errInvVarType"):
    return numpy.int32(1258)
   if (_0=="errSolverProbtype"):
    return numpy.int32(1259)
   if (_0=="errObjectiveRange"):
    return numpy.int32(1260)
   if (_0=="errFirst"):
    return numpy.int32(1261)
   if (_0=="errLast"):
    return numpy.int32(1262)
   if (_0=="errNegativeSurplus"):
    return numpy.int32(1263)
   if (_0=="errNegativeAppend"):
    return numpy.int32(1264)
   if (_0=="errUndefSolution"):
    return numpy.int32(1265)
   if (_0=="errBasis"):
    return numpy.int32(1266)
   if (_0=="errInvSkc"):
    return numpy.int32(1267)
   if (_0=="errInvSkx"):
    return numpy.int32(1268)
   if (_0=="errInvSkn"):
    return numpy.int32(1274)
   if (_0=="errInvSkStr"):
    return numpy.int32(1269)
   if (_0=="errInvSk"):
    return numpy.int32(1270)
   if (_0=="errInvConeTypeStr"):
    return numpy.int32(1271)
   if (_0=="errInvConeType"):
    return numpy.int32(1272)
   if (_0=="errInvalidSurplus"):
    return numpy.int32(1275)
   if (_0=="errInvNameItem"):
    return numpy.int32(1280)
   if (_0=="errProItem"):
    return numpy.int32(1281)
   if (_0=="errInvalidFormatType"):
    return numpy.int32(1283)
   if (_0=="errFirsti"):
    return numpy.int32(1285)
   if (_0=="errLasti"):
    return numpy.int32(1286)
   if (_0=="errFirstj"):
    return numpy.int32(1287)
   if (_0=="errLastj"):
    return numpy.int32(1288)
   if (_0=="errMaxLenIsTooSmall"):
    return numpy.int32(1289)
   if (_0=="errNonlinearEquality"):
    return numpy.int32(1290)
   if (_0=="errNonconvex"):
    return numpy.int32(1291)
   if (_0=="errNonlinearRanged"):
    return numpy.int32(1292)
   if (_0=="errConQNotPsd"):
    return numpy.int32(1293)
   if (_0=="errConQNotNsd"):
    return numpy.int32(1294)
   if (_0=="errObjQNotPsd"):
    return numpy.int32(1295)
   if (_0=="errObjQNotNsd"):
    return numpy.int32(1296)
   if (_0=="errArgumentPermArray"):
    return numpy.int32(1299)
   if (_0=="errConeIndex"):
    return numpy.int32(1300)
   if (_0=="errConeSize"):
    return numpy.int32(1301)
   if (_0=="errConeOverlap"):
    return numpy.int32(1302)
   if (_0=="errConeRepVar"):
    return numpy.int32(1303)
   if (_0=="errMaxnumcone"):
    return numpy.int32(1304)
   if (_0=="errConeType"):
    return numpy.int32(1305)
   if (_0=="errConeTypeStr"):
    return numpy.int32(1306)
   if (_0=="errConeOverlapAppend"):
    return numpy.int32(1307)
   if (_0=="errRemoveConeVariable"):
    return numpy.int32(1310)
   if (_0=="errSolFileInvalidNumber"):
    return numpy.int32(1350)
   if (_0=="errHugeC"):
    return numpy.int32(1375)
   if (_0=="errHugeAij"):
    return numpy.int32(1380)
   if (_0=="errDuplicateAij"):
    return numpy.int32(1385)
   if (_0=="errLowerBoundIsANan"):
    return numpy.int32(1390)
   if (_0=="errUpperBoundIsANan"):
    return numpy.int32(1391)
   if (_0=="errInfiniteBound"):
    return numpy.int32(1400)
   if (_0=="errInvQobjSubi"):
    return numpy.int32(1401)
   if (_0=="errInvQobjSubj"):
    return numpy.int32(1402)
   if (_0=="errInvQobjVal"):
    return numpy.int32(1403)
   if (_0=="errInvQconSubk"):
    return numpy.int32(1404)
   if (_0=="errInvQconSubi"):
    return numpy.int32(1405)
   if (_0=="errInvQconSubj"):
    return numpy.int32(1406)
   if (_0=="errInvQconVal"):
    return numpy.int32(1407)
   if (_0=="errQconSubiTooSmall"):
    return numpy.int32(1408)
   if (_0=="errQconSubiTooLarge"):
    return numpy.int32(1409)
   if (_0=="errQobjUpperTriangle"):
    return numpy.int32(1415)
   if (_0=="errQconUpperTriangle"):
    return numpy.int32(1417)
   if (_0=="errFixedBoundValues"):
    return numpy.int32(1425)
   if (_0=="errNonlinearFunctionsNotAllowed"):
    return numpy.int32(1428)
   if (_0=="errUserFuncRet"):
    return numpy.int32(1430)
   if (_0=="errUserFuncRetData"):
    return numpy.int32(1431)
   if (_0=="errUserNloFunc"):
    return numpy.int32(1432)
   if (_0=="errUserNloEval"):
    return numpy.int32(1433)
   if (_0=="errUserNloEvalHessubi"):
    return numpy.int32(1440)
   if (_0=="errUserNloEvalHessubj"):
    return numpy.int32(1441)
   if (_0=="errInvalidObjectiveSense"):
    return numpy.int32(1445)
   if (_0=="errUndefinedObjectiveSense"):
    return numpy.int32(1446)
   if (_0=="errYIsUndefined"):
    return numpy.int32(1449)
   if (_0=="errNanInDoubleData"):
    return numpy.int32(1450)
   if (_0=="errNanInBlc"):
    return numpy.int32(1461)
   if (_0=="errNanInBuc"):
    return numpy.int32(1462)
   if (_0=="errNanInC"):
    return numpy.int32(1470)
   if (_0=="errNanInBlx"):
    return numpy.int32(1471)
   if (_0=="errNanInBux"):
    return numpy.int32(1472)
   if (_0=="errInvalidAij"):
    return numpy.int32(1473)
   if (_0=="errSymMatInvalid"):
    return numpy.int32(1480)
   if (_0=="errSymMatHuge"):
    return numpy.int32(1482)
   if (_0=="errInvProblem"):
    return numpy.int32(1500)
   if (_0=="errMixedConicAndNl"):
    return numpy.int32(1501)
   if (_0=="errGlobalInvConicProblem"):
    return numpy.int32(1503)
   if (_0=="errInvOptimizer"):
    return numpy.int32(1550)
   if (_0=="errMioNoOptimizer"):
    return numpy.int32(1551)
   if (_0=="errNoOptimizerVarType"):
    return numpy.int32(1552)
   if (_0=="errFinalSolution"):
    return numpy.int32(1560)
   if (_0=="errPostsolve"):
    return numpy.int32(1580)
   if (_0=="errOverflow"):
    return numpy.int32(1590)
   if (_0=="errNoBasisSol"):
    return numpy.int32(1600)
   if (_0=="errBasisFactor"):
    return numpy.int32(1610)
   if (_0=="errBasisSingular"):
    return numpy.int32(1615)
   if (_0=="errFactor"):
    return numpy.int32(1650)
   if (_0=="errFeasrepairCannotRelax"):
    return numpy.int32(1700)
   if (_0=="errFeasrepairSolvingRelaxed"):
    return numpy.int32(1701)
   if (_0=="errFeasrepairInconsistentBound"):
    return numpy.int32(1702)
   if (_0=="errRepairInvalidProblem"):
    return numpy.int32(1710)
   if (_0=="errRepairOptimizationFailed"):
    return numpy.int32(1711)
   if (_0=="errNameMaxLen"):
    return numpy.int32(1750)
   if (_0=="errNameIsNull"):
    return numpy.int32(1760)
   if (_0=="errInvalidCompression"):
    return numpy.int32(1800)
   if (_0=="errInvalidIomode"):
    return numpy.int32(1801)
   if (_0=="errNoPrimalInfeasCer"):
    return numpy.int32(2000)
   if (_0=="errNoDualInfeasCer"):
    return numpy.int32(2001)
   if (_0=="errNoSolutionInCallback"):
    return numpy.int32(2500)
   if (_0=="errInvMarki"):
    return numpy.int32(2501)
   if (_0=="errInvMarkj"):
    return numpy.int32(2502)
   if (_0=="errInvNumi"):
    return numpy.int32(2503)
   if (_0=="errInvNumj"):
    return numpy.int32(2504)
   if (_0=="errCannotCloneNl"):
    return numpy.int32(2505)
   if (_0=="errCannotHandleNl"):
    return numpy.int32(2506)
   if (_0=="errInvalidAccmode"):
    return numpy.int32(2520)
   if (_0=="errTaskIncompatible"):
    return numpy.int32(2560)
   if (_0=="errTaskInvalid"):
    return numpy.int32(2561)
   if (_0=="errTaskWrite"):
    return numpy.int32(2562)
   if (_0=="errLuMaxNumTries"):
    return numpy.int32(2800)
   if (_0=="errInvalidUtf8"):
    return numpy.int32(2900)
   if (_0=="errInvalidWchar"):
    return numpy.int32(2901)
   if (_0=="errNoDualForItgSol"):
    return numpy.int32(2950)
   if (_0=="errNoSnxForBasSol"):
    return numpy.int32(2953)
   if (_0=="errInternal"):
    return numpy.int32(3000)
   if (_0=="errApiArrayTooSmall"):
    return numpy.int32(3001)
   if (_0=="errApiCbConnect"):
    return numpy.int32(3002)
   if (_0=="errApiFatalError"):
    return numpy.int32(3005)
   if (_0=="errApiInternal"):
    return numpy.int32(3999)
   if (_0=="errSenFormat"):
    return numpy.int32(3050)
   if (_0=="errSenUndefName"):
    return numpy.int32(3051)
   if (_0=="errSenIndexRange"):
    return numpy.int32(3052)
   if (_0=="errSenBoundInvalidUp"):
    return numpy.int32(3053)
   if (_0=="errSenBoundInvalidLo"):
    return numpy.int32(3054)
   if (_0=="errSenIndexInvalid"):
    return numpy.int32(3055)
   if (_0=="errSenInvalidRegexp"):
    return numpy.int32(3056)
   if (_0=="errSenSolutionStatus"):
    return numpy.int32(3057)
   if (_0=="errSenNumerical"):
    return numpy.int32(3058)
   if (_0=="errSenUnhandledProblemType"):
    return numpy.int32(3080)
   if (_0=="errUnbStepSize"):
    return numpy.int32(3100)
   if (_0=="errIdenticalTasks"):
    return numpy.int32(3101)
   if (_0=="errAdInvalidCodelist"):
    return numpy.int32(3102)
   if (_0=="errInternalTestFailed"):
    return numpy.int32(3500)
   if (_0=="errXmlInvalidProblemType"):
    return numpy.int32(3600)
   if (_0=="errInvalidAmplStub"):
    return numpy.int32(3700)
   if (_0=="errInt64ToInt32Cast"):
    return numpy.int32(3800)
   if (_0=="errSizeLicenseNumcores"):
    return numpy.int32(3900)
   if (_0=="errInfeasUndefined"):
    return numpy.int32(3910)
   if (_0=="errNoBarxForSolution"):
    return numpy.int32(3915)
   if (_0=="errNoBarsForSolution"):
    return numpy.int32(3916)
   if (_0=="errBarVarDim"):
    return numpy.int32(3920)
   if (_0=="errSymMatInvalidRowIndex"):
    return numpy.int32(3940)
   if (_0=="errSymMatInvalidColIndex"):
    return numpy.int32(3941)
   if (_0=="errSymMatNotLowerTringular"):
    return numpy.int32(3942)
   if (_0=="errSymMatInvalidValue"):
    return numpy.int32(3943)
   if (_0=="errSymMatDuplicate"):
    return numpy.int32(3944)
   if (_0=="errInvalidSymMatDim"):
    return numpy.int32(3950)
   if (_0=="errInvalidFileFormatForSymMat"):
    return numpy.int32(4000)
   if (_0=="errInvalidFileFormatForCones"):
    return numpy.int32(4005)
   if (_0=="errInvalidFileFormatForGeneralNl"):
    return numpy.int32(4010)
   if (_0=="errDuplicateConstraintNames"):
    return numpy.int32(4500)
   if (_0=="errDuplicateVariableNames"):
    return numpy.int32(4501)
   if (_0=="errDuplicateBarvariableNames"):
    return numpy.int32(4502)
   if (_0=="errDuplicateConeNames"):
    return numpy.int32(4503)
   if (_0=="errNonUniqueArray"):
    return numpy.int32(5000)
   if (_0=="errArgumentIsTooLarge"):
    return numpy.int32(5005)
   if (_0=="errMioInternal"):
    return numpy.int32(5010)
   if (_0=="errInvalidProblemType"):
    return numpy.int32(6000)
   if (_0=="errUnhandledSolutionStatus"):
    return numpy.int32(6010)
   if (_0=="errUpperTriangle"):
    return numpy.int32(6020)
   if (_0=="errLauSingularMatrix"):
    return numpy.int32(7000)
   if (_0=="errLauNotPositiveDefinite"):
    return numpy.int32(7001)
   if (_0=="errLauInvalidLowerTriangularMatrix"):
    return numpy.int32(7002)
   if (_0=="errLauUnknown"):
    return numpy.int32(7005)
   if (_0=="errLauArgM"):
    return numpy.int32(7010)
   if (_0=="errLauArgN"):
    return numpy.int32(7011)
   if (_0=="errLauArgK"):
    return numpy.int32(7012)
   if (_0=="errLauArgTransa"):
    return numpy.int32(7015)
   if (_0=="errLauArgTransb"):
    return numpy.int32(7016)
   if (_0=="errLauArgUplo"):
    return numpy.int32(7017)
   if (_0=="errLauArgTrans"):
    return numpy.int32(7018)
   if (_0=="errLauInvalidSparseSymmetricMatrix"):
    return numpy.int32(7019)
   if (_0=="errCbfParse"):
    return numpy.int32(7100)
   if (_0=="errCbfObjSense"):
    return numpy.int32(7101)
   if (_0=="errCbfNoVariables"):
    return numpy.int32(7102)
   if (_0=="errCbfTooManyConstraints"):
    return numpy.int32(7103)
   if (_0=="errCbfTooManyVariables"):
    return numpy.int32(7104)
   if (_0=="errCbfNoVersionSpecified"):
    return numpy.int32(7105)
   if (_0=="errCbfSyntax"):
    return numpy.int32(7106)
   if (_0=="errCbfDuplicateObj"):
    return numpy.int32(7107)
   if (_0=="errCbfDuplicateCon"):
    return numpy.int32(7108)
   if (_0=="errCbfDuplicateVar"):
    return numpy.int32(7109)
   if (_0=="errCbfDuplicateInt"):
    return numpy.int32(7110)
   if (_0=="errCbfInvalidVarType"):
    return numpy.int32(7111)
   if (_0=="errCbfInvalidConType"):
    return numpy.int32(7112)
   if (_0=="errCbfInvalidDomainDimension"):
    return numpy.int32(7113)
   if (_0=="errCbfDuplicateObjacoord"):
    return numpy.int32(7114)
   if (_0=="errCbfDuplicateBcoord"):
    return numpy.int32(7115)
   if (_0=="errCbfDuplicateAcoord"):
    return numpy.int32(7116)
   if (_0=="errCbfTooFewVariables"):
    return numpy.int32(7117)
   if (_0=="errCbfTooFewConstraints"):
    return numpy.int32(7118)
   if (_0=="errCbfTooFewInts"):
    return numpy.int32(7119)
   if (_0=="errCbfTooManyInts"):
    return numpy.int32(7120)
   if (_0=="errCbfInvalidIntIndex"):
    return numpy.int32(7121)
   if (_0=="errCbfUnsupported"):
    return numpy.int32(7122)
   if (_0=="errCbfDuplicatePsdvar"):
    return numpy.int32(7123)
   if (_0=="errCbfInvalidPsdvarDimension"):
    return numpy.int32(7124)
   if (_0=="errCbfTooFewPsdvar"):
    return numpy.int32(7125)
   if (_0=="errMioInvalidRootOptimizer"):
    return numpy.int32(7130)
   if (_0=="errMioInvalidNodeOptimizer"):
    return numpy.int32(7131)
   if (_0=="errToconicConstrQNotPsd"):
    return numpy.int32(7150)
   if (_0=="errToconicConstraintFx"):
    return numpy.int32(7151)
   if (_0=="errToconicConstraintRa"):
    return numpy.int32(7152)
   if (_0=="errToconicConstrNotConic"):
    return numpy.int32(7153)
   if (_0=="errToconicObjectiveNotPsd"):
    return numpy.int32(7155)
   if (_0=="errServerConnect"):
    return numpy.int32(8000)
   if (_0=="errServerProtocol"):
    return numpy.int32(8001)
   if (_0=="errServerStatus"):
    return numpy.int32(8002)
   if (_0=="errServerToken"):
    return numpy.int32(8003)
   if (_0=="trmMaxIterations"):
    return numpy.int32(10000)
   if (_0=="trmMaxTime"):
    return numpy.int32(10001)
   if (_0=="trmObjectiveRange"):
    return numpy.int32(10002)
   if (_0=="trmMioNearRelGap"):
    return numpy.int32(10003)
   if (_0=="trmMioNearAbsGap"):
    return numpy.int32(10004)
   if (_0=="trmMioNumRelaxs"):
    return numpy.int32(10008)
   if (_0=="trmMioNumBranches"):
    return numpy.int32(10009)
   if (_0=="trmNumMaxNumIntSolutions"):
    return numpy.int32(10015)
   if (_0=="trmStall"):
    return numpy.int32(10006)
   if (_0=="trmUserCallback"):
    return numpy.int32(10007)
   if (_0=="trmMaxNumSetbacks"):
    return numpy.int32(10020)
   if (_0=="trmNumericalProblem"):
    return numpy.int32(10025)
   if (_0=="trmInternal"):
    return numpy.int32(10030)
   if (_0=="trmInternalStop"):
    return numpy.int32(10031)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1scalingtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1scalingtype_1value_S(_0)
  @staticmethod
  def __string_1to_1scalingtype_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="none"):
    return numpy.int32(1)
   if (_0=="moderate"):
    return numpy.int32(2)
   if (_0=="aggressive"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1prosta_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1prosta_1value_S(_0)
  @staticmethod
  def __string_1to_1prosta_1value_S(_0):
   if (_0=="unknown"):
    return numpy.int32(0)
   if (_0=="primAndDualFeas"):
    return numpy.int32(1)
   if (_0=="primFeas"):
    return numpy.int32(2)
   if (_0=="dualFeas"):
    return numpy.int32(3)
   if (_0=="nearPrimAndDualFeas"):
    return numpy.int32(8)
   if (_0=="nearPrimFeas"):
    return numpy.int32(9)
   if (_0=="nearDualFeas"):
    return numpy.int32(10)
   if (_0=="primInfeas"):
    return numpy.int32(4)
   if (_0=="dualInfeas"):
    return numpy.int32(5)
   if (_0=="primAndDualInfeas"):
    return numpy.int32(6)
   if (_0=="illPosed"):
    return numpy.int32(7)
   if (_0=="primInfeasOrUnbounded"):
    return numpy.int32(11)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1rescodetype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1rescodetype_1value_S(_0)
  @staticmethod
  def __string_1to_1rescodetype_1value_S(_0):
   if (_0=="ok"):
    return numpy.int32(0)
   if (_0=="wrn"):
    return numpy.int32(1)
   if (_0=="trm"):
    return numpy.int32(2)
   if (_0=="err"):
    return numpy.int32(3)
   if (_0=="unk"):
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1parametertype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1parametertype_1value_S(_0)
  @staticmethod
  def __string_1to_1parametertype_1value_S(_0):
   if (_0=="invalidType"):
    return numpy.int32(0)
   if (_0=="douType"):
    return numpy.int32(1)
   if (_0=="intType"):
    return numpy.int32(2)
   if (_0=="strType"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1dinfitem_1value_S(_0):
   if (_0=="biTime"):
    return numpy.int32(5)
   if (_0=="biPrimalTime"):
    return numpy.int32(4)
   if (_0=="biDualTime"):
    return numpy.int32(3)
   if (_0=="biCleanTime"):
    return numpy.int32(2)
   if (_0=="biCleanPrimalTime"):
    return numpy.int32(1)
   if (_0=="biCleanDualTime"):
    return numpy.int32(0)
   if (_0=="intpntTime"):
    return numpy.int32(13)
   if (_0=="intpntOrderTime"):
    return numpy.int32(10)
   if (_0=="intpntPrimalObj"):
    return numpy.int32(12)
   if (_0=="intpntDualObj"):
    return numpy.int32(7)
   if (_0=="intpntPrimalFeas"):
    return numpy.int32(11)
   if (_0=="intpntDualFeas"):
    return numpy.int32(6)
   if (_0=="intpntOptStatus"):
    return numpy.int32(9)
   if (_0=="simTime"):
    return numpy.int32(47)
   if (_0=="simPrimalTime"):
    return numpy.int32(46)
   if (_0=="simDualTime"):
    return numpy.int32(43)
   if (_0=="simObj"):
    return numpy.int32(45)
   if (_0=="simFeas"):
    return numpy.int32(44)
   if (_0=="mioTime"):
    return numpy.int32(31)
   if (_0=="mioRootPresolveTime"):
    return numpy.int32(30)
   if (_0=="mioRootOptimizerTime"):
    return numpy.int32(29)
   if (_0=="mioOptimizerTime"):
    return numpy.int32(26)
   if (_0=="mioHeuristicTime"):
    return numpy.int32(19)
   if (_0=="toConicTime"):
    return numpy.int32(91)
   if (_0=="mioConstructSolutionObj"):
    return numpy.int32(16)
   if (_0=="mioObjInt"):
    return numpy.int32(24)
   if (_0=="mioObjBound"):
    return numpy.int32(23)
   if (_0=="mioObjRelGap"):
    return numpy.int32(25)
   if (_0=="mioObjAbsGap"):
    return numpy.int32(22)
   if (_0=="mioUserObjCut"):
    return numpy.int32(32)
   if (_0=="mioCmirSeparationTime"):
    return numpy.int32(15)
   if (_0=="mioCliqueSeparationTime"):
    return numpy.int32(14)
   if (_0=="mioKnapsackCoverSeparationTime"):
    return numpy.int32(21)
   if (_0=="mioGmiSeparationTime"):
    return numpy.int32(18)
   if (_0=="mioImpliedBoundTime"):
    return numpy.int32(20)
   if (_0=="mioRootCutgenTime"):
    return numpy.int32(28)
   if (_0=="mioProbingTime"):
    return numpy.int32(27)
   if (_0=="optimizerTime"):
    return numpy.int32(33)
   if (_0=="presolveTime"):
    return numpy.int32(36)
   if (_0=="mioDualBoundAfterPresolve"):
    return numpy.int32(17)
   if (_0=="presolveEliTime"):
    return numpy.int32(34)
   if (_0=="presolveLindepTime"):
    return numpy.int32(35)
   if (_0=="rdTime"):
    return numpy.int32(42)
   if (_0=="solItrPrimalObj"):
    return numpy.int32(86)
   if (_0=="solItrPviolcon"):
    return numpy.int32(88)
   if (_0=="solItrPviolvar"):
    return numpy.int32(90)
   if (_0=="solItrPviolbarvar"):
    return numpy.int32(87)
   if (_0=="solItrPviolcones"):
    return numpy.int32(89)
   if (_0=="solItrDualObj"):
    return numpy.int32(71)
   if (_0=="solItrDviolcon"):
    return numpy.int32(73)
   if (_0=="solItrDviolvar"):
    return numpy.int32(75)
   if (_0=="solItrDviolbarvar"):
    return numpy.int32(72)
   if (_0=="solItrDviolcones"):
    return numpy.int32(74)
   if (_0=="solItrNrmXc"):
    return numpy.int32(83)
   if (_0=="solItrNrmXx"):
    return numpy.int32(84)
   if (_0=="solItrNrmBarx"):
    return numpy.int32(77)
   if (_0=="solItrNrmY"):
    return numpy.int32(85)
   if (_0=="solItrNrmSlc"):
    return numpy.int32(78)
   if (_0=="solItrNrmSuc"):
    return numpy.int32(81)
   if (_0=="solItrNrmSlx"):
    return numpy.int32(79)
   if (_0=="solItrNrmSux"):
    return numpy.int32(82)
   if (_0=="solItrNrmSnx"):
    return numpy.int32(80)
   if (_0=="solItrNrmBars"):
    return numpy.int32(76)
   if (_0=="solBasPrimalObj"):
    return numpy.int32(59)
   if (_0=="solBasPviolcon"):
    return numpy.int32(60)
   if (_0=="solBasPviolvar"):
    return numpy.int32(61)
   if (_0=="solBasDualObj"):
    return numpy.int32(48)
   if (_0=="solBasDviolcon"):
    return numpy.int32(49)
   if (_0=="solBasDviolvar"):
    return numpy.int32(50)
   if (_0=="solBasNrmXc"):
    return numpy.int32(56)
   if (_0=="solBasNrmXx"):
    return numpy.int32(57)
   if (_0=="solBasNrmBarx"):
    return numpy.int32(51)
   if (_0=="solBasNrmY"):
    return numpy.int32(58)
   if (_0=="solBasNrmSlc"):
    return numpy.int32(52)
   if (_0=="solBasNrmSuc"):
    return numpy.int32(54)
   if (_0=="solBasNrmSlx"):
    return numpy.int32(53)
   if (_0=="solBasNrmSux"):
    return numpy.int32(55)
   if (_0=="solItgPrimalObj"):
    return numpy.int32(65)
   if (_0=="solItgPviolcon"):
    return numpy.int32(67)
   if (_0=="solItgPviolvar"):
    return numpy.int32(70)
   if (_0=="solItgPviolbarvar"):
    return numpy.int32(66)
   if (_0=="solItgPviolcones"):
    return numpy.int32(68)
   if (_0=="solItgPviolitg"):
    return numpy.int32(69)
   if (_0=="solItgNrmXc"):
    return numpy.int32(63)
   if (_0=="solItgNrmXx"):
    return numpy.int32(64)
   if (_0=="solItgNrmBarx"):
    return numpy.int32(62)
   if (_0=="intpntFactorNumFlops"):
    return numpy.int32(8)
   if (_0=="qcqoReformulateTime"):
    return numpy.int32(39)
   if (_0=="qcqoReformulateMaxPerturbation"):
    return numpy.int32(38)
   if (_0=="qcqoReformulateWorstCholeskyDiagScaling"):
    return numpy.int32(41)
   if (_0=="qcqoReformulateWorstCholeskyColumnScaling"):
    return numpy.int32(40)
   if (_0=="primalRepairPenaltyObj"):
    return numpy.int32(37)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miomode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1miomode_1value_S(_0)
  @staticmethod
  def __string_1to_1miomode_1value_S(_0):
   if (_0=="ignored"):
    return numpy.int32(0)
   if (_0=="satisfied"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1xmlwriteroutputtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1xmlwriteroutputtype_1value_S(_0)
  @staticmethod
  def __string_1to_1xmlwriteroutputtype_1value_S(_0):
   if (_0=="row"):
    return numpy.int32(0)
   if (_0=="col"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simseltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simseltype_1value_S(_0)
  @staticmethod
  def __string_1to_1simseltype_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="full"):
    return numpy.int32(1)
   if (_0=="ase"):
    return numpy.int32(2)
   if (_0=="devex"):
    return numpy.int32(3)
   if (_0=="se"):
    return numpy.int32(4)
   if (_0=="partial"):
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1liinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1liinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1liinf_1value_S(_0):
   if (_0=="intpntLenbarvar"):
    return numpy.int32(5)
   if (_0=="intpntFactorNumNzBefore"):
    return numpy.int32(2)
   if (_0=="intpntFactorMlOrderSparseLNz"):
    return numpy.int32(1)
   if (_0=="intpntFactorGpOrderSparseLNz"):
    return numpy.int32(0)
   if (_0=="presolveStackSize"):
    return numpy.int32(6)
   if (_0=="intpntFactorVNz"):
    return numpy.int32(4)
   if (_0=="intpntFactorUpdatedVNz"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iomode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iomode_1value_S(_0)
  @staticmethod
  def __string_1to_1iomode_1value_S(_0):
   if (_0=="read"):
    return numpy.int32(0)
   if (_0=="write"):
    return numpy.int32(1)
   if (_0=="readwrite"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1streamtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1streamtype_1value_S(_0)
  @staticmethod
  def __string_1to_1streamtype_1value_S(_0):
   if (_0=="log"):
    return numpy.int32(0)
   if (_0=="msg"):
    return numpy.int32(1)
   if (_0=="err"):
    return numpy.int32(2)
   if (_0=="wrn"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1conetype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1conetype_1value_S(_0)
  @staticmethod
  def __string_1to_1conetype_1value_S(_0):
   if (_0=="quad"):
    return numpy.int32(0)
   if (_0=="rquad"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mark_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mark_1value_S(_0)
  @staticmethod
  def __string_1to_1mark_1value_S(_0):
   if (_0=="lo"):
    return numpy.int32(0)
   if (_0=="up"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1feature_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1feature_1value_S(_0)
  @staticmethod
  def __string_1to_1feature_1value_S(_0):
   if (_0=="pts"):
    return numpy.int32(0)
   if (_0=="pton"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1symmattype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1symmattype_1value_S(_0)
  @staticmethod
  def __string_1to_1symmattype_1value_S(_0):
   if (_0=="sparse"):
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1callbackcode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1callbackcode_1value_S(_0)
  @staticmethod
  def __string_1to_1callbackcode_1value_S(_0):
   if (_0=="beginRootCutgen"):
    return numpy.int32(22)
   if (_0=="imRootCutgen"):
    return numpy.int32(76)
   if (_0=="endRootCutgen"):
    return numpy.int32(51)
   if (_0=="beginOptimizer"):
    return numpy.int32(12)
   if (_0=="endOptimizer"):
    return numpy.int32(41)
   if (_0=="beginPresolve"):
    return numpy.int32(13)
   if (_0=="updatePresolve"):
    return numpy.int32(88)
   if (_0=="imPresolve"):
    return numpy.int32(70)
   if (_0=="endPresolve"):
    return numpy.int32(42)
   if (_0=="beginIntpnt"):
    return numpy.int32(9)
   if (_0=="intpnt"):
    return numpy.int32(79)
   if (_0=="imIntpnt"):
    return numpy.int32(62)
   if (_0=="endIntpnt"):
    return numpy.int32(38)
   if (_0=="beginConic"):
    return numpy.int32(1)
   if (_0=="conic"):
    return numpy.int32(27)
   if (_0=="imConic"):
    return numpy.int32(57)
   if (_0=="endConic"):
    return numpy.int32(30)
   if (_0=="primalSimplex"):
    return numpy.int32(81)
   if (_0=="dualSimplex"):
    return numpy.int32(28)
   if (_0=="beginBi"):
    return numpy.int32(0)
   if (_0=="imBi"):
    return numpy.int32(56)
   if (_0=="endBi"):
    return numpy.int32(29)
   if (_0=="beginPrimalBi"):
    return numpy.int32(14)
   if (_0=="imPrimalBi"):
    return numpy.int32(71)
   if (_0=="updatePrimalBi"):
    return numpy.int32(89)
   if (_0=="endPrimalBi"):
    return numpy.int32(43)
   if (_0=="beginDualBi"):
    return numpy.int32(2)
   if (_0=="imDualBi"):
    return numpy.int32(58)
   if (_0=="updateDualBi"):
    return numpy.int32(85)
   if (_0=="endDualBi"):
    return numpy.int32(31)
   if (_0=="beginSimplexBi"):
    return numpy.int32(24)
   if (_0=="imSimplexBi"):
    return numpy.int32(78)
   if (_0=="beginPrimalSimplexBi"):
    return numpy.int32(19)
   if (_0=="updatePrimalSimplexBi"):
    return numpy.int32(91)
   if (_0=="endPrimalSimplexBi"):
    return numpy.int32(48)
   if (_0=="beginDualSimplexBi"):
    return numpy.int32(6)
   if (_0=="updateDualSimplexBi"):
    return numpy.int32(87)
   if (_0=="endDualSimplexBi"):
    return numpy.int32(35)
   if (_0=="endSimplexBi"):
    return numpy.int32(53)
   if (_0=="beginMio"):
    return numpy.int32(11)
   if (_0=="imMio"):
    return numpy.int32(65)
   if (_0=="newIntMio"):
    return numpy.int32(80)
   if (_0=="endMio"):
    return numpy.int32(40)
   if (_0=="beginSimplex"):
    return numpy.int32(23)
   if (_0=="beginDualSimplex"):
    return numpy.int32(5)
   if (_0=="imDualSimplex"):
    return numpy.int32(60)
   if (_0=="updateDualSimplex"):
    return numpy.int32(86)
   if (_0=="endDualSimplex"):
    return numpy.int32(34)
   if (_0=="beginPrimalSimplex"):
    return numpy.int32(18)
   if (_0=="imPrimalSimplex"):
    return numpy.int32(73)
   if (_0=="updatePrimalSimplex"):
    return numpy.int32(90)
   if (_0=="endPrimalSimplex"):
    return numpy.int32(47)
   if (_0=="endSimplex"):
    return numpy.int32(52)
   if (_0=="beginInfeasAna"):
    return numpy.int32(8)
   if (_0=="endInfeasAna"):
    return numpy.int32(37)
   if (_0=="imPrimalSensivity"):
    return numpy.int32(72)
   if (_0=="imDualSensivity"):
    return numpy.int32(59)
   if (_0=="imMioIntpnt"):
    return numpy.int32(67)
   if (_0=="imMioPrimalSimplex"):
    return numpy.int32(68)
   if (_0=="imMioDualSimplex"):
    return numpy.int32(66)
   if (_0=="beginPrimalSetupBi"):
    return numpy.int32(17)
   if (_0=="endPrimalSetupBi"):
    return numpy.int32(46)
   if (_0=="beginDualSetupBi"):
    return numpy.int32(4)
   if (_0=="endDualSetupBi"):
    return numpy.int32(33)
   if (_0=="beginPrimalSensitivity"):
    return numpy.int32(16)
   if (_0=="endPrimalSensitivity"):
    return numpy.int32(45)
   if (_0=="beginDualSensitivity"):
    return numpy.int32(3)
   if (_0=="endDualSensitivity"):
    return numpy.int32(32)
   if (_0=="beginLicenseWait"):
    return numpy.int32(10)
   if (_0=="endLicenseWait"):
    return numpy.int32(39)
   if (_0=="imLicenseWait"):
    return numpy.int32(63)
   if (_0=="beginQcqoReformulate"):
    return numpy.int32(20)
   if (_0=="endQcqoReformulate"):
    return numpy.int32(49)
   if (_0=="imQoReformulate"):
    return numpy.int32(74)
   if (_0=="beginToConic"):
    return numpy.int32(25)
   if (_0=="endToConic"):
    return numpy.int32(54)
   if (_0=="beginFullConvexityCheck"):
    return numpy.int32(7)
   if (_0=="endFullConvexityCheck"):
    return numpy.int32(36)
   if (_0=="imFullConvexityCheck"):
    return numpy.int32(61)
   if (_0=="beginPrimalRepair"):
    return numpy.int32(15)
   if (_0=="endPrimalRepair"):
    return numpy.int32(44)
   if (_0=="beginRead"):
    return numpy.int32(21)
   if (_0=="imRead"):
    return numpy.int32(75)
   if (_0=="endRead"):
    return numpy.int32(50)
   if (_0=="beginWrite"):
    return numpy.int32(26)
   if (_0=="endWrite"):
    return numpy.int32(55)
   if (_0=="readOpfSection"):
    return numpy.int32(83)
   if (_0=="imLu"):
    return numpy.int32(64)
   if (_0=="imOrder"):
    return numpy.int32(69)
   if (_0=="imSimplex"):
    return numpy.int32(77)
   if (_0=="readOpf"):
    return numpy.int32(82)
   if (_0=="writeOpf"):
    return numpy.int32(92)
   if (_0=="solvingRemote"):
    return numpy.int32(84)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simhotstart_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simhotstart_1value_S(_0)
  @staticmethod
  def __string_1to_1simhotstart_1value_S(_0):
   if (_0=="none"):
    return numpy.int32(0)
   if (_0=="free"):
    return numpy.int32(1)
   if (_0=="statusKeys"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1liinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1liinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1liinfitem_1value_S(_0):
   if (_0=="mioPresolvedAnz"):
    return numpy.int32(8)
   if (_0=="mioSimplexIter"):
    return numpy.int32(10)
   if (_0=="mioIntpntIter"):
    return numpy.int32(7)
   if (_0=="biPrimalIter"):
    return numpy.int32(5)
   if (_0=="biDualIter"):
    return numpy.int32(4)
   if (_0=="biCleanPrimalIter"):
    return numpy.int32(3)
   if (_0=="biCleanDualIter"):
    return numpy.int32(1)
   if (_0=="biCleanPrimalDegIter"):
    return numpy.int32(2)
   if (_0=="biCleanDualDegIter"):
    return numpy.int32(0)
   if (_0=="intpntFactorNumNz"):
    return numpy.int32(6)
   if (_0=="rdNumanz"):
    return numpy.int32(11)
   if (_0=="rdNumqnz"):
    return numpy.int32(12)
   if (_0=="mioSimMaxiterSetbacks"):
    return numpy.int32(9)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1branchdir_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1branchdir_1value_S(_0)
  @staticmethod
  def __string_1to_1branchdir_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="up"):
    return numpy.int32(1)
   if (_0=="down"):
    return numpy.int32(2)
   if (_0=="near"):
    return numpy.int32(3)
   if (_0=="far"):
    return numpy.int32(4)
   if (_0=="rootLp"):
    return numpy.int32(5)
   if (_0=="guided"):
    return numpy.int32(6)
   if (_0=="pseudocost"):
    return numpy.int32(7)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1basindtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1basindtype_1value_S(_0)
  @staticmethod
  def __string_1to_1basindtype_1value_S(_0):
   if (_0=="never"):
    return numpy.int32(0)
   if (_0=="always"):
    return numpy.int32(1)
   if (_0=="noError"):
    return numpy.int32(2)
   if (_0=="ifFeasible"):
    return numpy.int32(3)
   if (_0=="reservered"):
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1iinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1iinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1iinf_1value_S(_0):
   if (_0=="presolveCompressedStackSize"):
    return numpy.int32(31)
   if (_0=="presolveLindepWork"):
    return numpy.int32(59)
   if (_0=="presolveLindepPivots"):
    return numpy.int32(57)
   if (_0=="presolveLindepSkipped"):
    return numpy.int32(58)
   if (_0=="presolveOutofspace"):
    return numpy.int32(77)
   if (_0=="presolveBadPrecision"):
    return numpy.int32(30)
   if (_0=="optObjectiveSense"):
    return numpy.int32(28)
   if (_0=="optimizer"):
    return numpy.int32(29)
   if (_0=="intpntFirRefIter"):
    return numpy.int32(9)
   if (_0=="intpntNumRefSteps"):
    return numpy.int32(14)
   if (_0=="intpntFactorDim"):
    return numpy.int32(2)
   if (_0=="intpntFactorNumDenseA"):
    return numpy.int32(4)
   if (_0=="intpntFactorNumDenseADup"):
    return numpy.int32(5)
   if (_0=="intpntFactorNumDenseW"):
    return numpy.int32(6)
   if (_0=="intpntFactorNumDenseWANull"):
    return numpy.int32(7)
   if (_0=="intpntNumcon"):
    return numpy.int32(21)
   if (_0=="intpntNumvar"):
    return numpy.int32(26)
   if (_0=="intpntNumbarvar"):
    return numpy.int32(15)
   if (_0=="intpntNumblo"):
    return numpy.int32(18)
   if (_0=="intpntNumbup"):
    return numpy.int32(20)
   if (_0=="intpntNumbfr"):
    return numpy.int32(16)
   if (_0=="intpntNumbfx"):
    return numpy.int32(17)
   if (_0=="intpntNumcone"):
    return numpy.int32(22)
   if (_0=="intpntNumconevar"):
    return numpy.int32(23)
   if (_0=="intpntNumbndcone"):
    return numpy.int32(19)
   if (_0=="intpntNumrqcones"):
    return numpy.int32(25)
   if (_0=="intpntNumqcones"):
    return numpy.int32(24)
   if (_0=="intpntMinconedim"):
    return numpy.int32(13)
   if (_0=="intpntMaxconedim"):
    return numpy.int32(12)
   if (_0=="intpntMaxbarvardim"):
    return numpy.int32(11)
   if (_0=="presolveNumcon"):
    return numpy.int32(66)
   if (_0=="presolveNumcfr"):
    return numpy.int32(62)
   if (_0=="presolveNumcfx"):
    return numpy.int32(63)
   if (_0=="presolveNumclo"):
    return numpy.int32(64)
   if (_0=="presolveNumcup"):
    return numpy.int32(68)
   if (_0=="presolveNumcra"):
    return numpy.int32(67)
   if (_0=="presolveNumcnl"):
    return numpy.int32(65)
   if (_0=="presolveNumvar"):
    return numpy.int32(70)
   if (_0=="presolveNumvfr"):
    return numpy.int32(71)
   if (_0=="presolveNumvfx"):
    return numpy.int32(72)
   if (_0=="presolveNumvlo"):
    return numpy.int32(73)
   if (_0=="presolveNumvup"):
    return numpy.int32(76)
   if (_0=="presolveNumvra"):
    return numpy.int32(75)
   if (_0=="presolveNumvnl"):
    return numpy.int32(74)
   if (_0=="presolveNumnza"):
    return numpy.int32(69)
   if (_0=="presolveFnumcon"):
    return numpy.int32(39)
   if (_0=="presolveFnumcfr"):
    return numpy.int32(35)
   if (_0=="presolveFnumcfx"):
    return numpy.int32(36)
   if (_0=="presolveFnumclo"):
    return numpy.int32(37)
   if (_0=="presolveFnumcup"):
    return numpy.int32(41)
   if (_0=="presolveFnumcra"):
    return numpy.int32(40)
   if (_0=="presolveFnumcnl"):
    return numpy.int32(38)
   if (_0=="presolveFnumvar"):
    return numpy.int32(43)
   if (_0=="presolveFnumvfr"):
    return numpy.int32(44)
   if (_0=="presolveFnumvfx"):
    return numpy.int32(45)
   if (_0=="presolveFnumvlo"):
    return numpy.int32(46)
   if (_0=="presolveFnumvup"):
    return numpy.int32(49)
   if (_0=="presolveFnumvra"):
    return numpy.int32(48)
   if (_0=="presolveFnumvnl"):
    return numpy.int32(47)
   if (_0=="presolveFnumnza"):
    return numpy.int32(42)
   if (_0=="presolveNumElimns"):
    return numpy.int32(61)
   if (_0=="presolveEliNumTries"):
    return numpy.int32(34)
   if (_0=="presolveEliNumFreedCon"):
    return numpy.int32(32)
   if (_0=="presolveEliNumFreedConTotal"):
    return numpy.int32(33)
   if (_0=="presolveLindepNumTries"):
    return numpy.int32(55)
   if (_0=="presolveLindepNum"):
    return numpy.int32(54)
   if (_0=="presolveForceConNum"):
    return numpy.int32(50)
   if (_0=="presolveForceConNumVar"):
    return numpy.int32(51)
   if (_0=="presolveForceVarNum"):
    return numpy.int32(52)
   if (_0=="presolveForceVarNumCon"):
    return numpy.int32(53)
   if (_0=="presolvePivOnConNum"):
    return numpy.int32(78)
   if (_0=="presolveNumDouBlocks"):
    return numpy.int32(60)
   if (_0=="intpntFactorNum"):
    return numpy.int32(3)
   if (_0=="intpntFactorNumSolve"):
    return numpy.int32(8)
   if (_0=="simPrimalHotstartNumBasics"):
    return numpy.int32(88)
   if (_0=="simPrimalHotstartBasisRank"):
    return numpy.int32(87)
   if (_0=="simDualHotstartNumBasics"):
    return numpy.int32(80)
   if (_0=="simDualHotstartBasisRank"):
    return numpy.int32(79)
   if (_0=="intpntGpOrderEmployed"):
    return numpy.int32(10)
   if (_0=="numLuFactorizations"):
    return numpy.int32(27)
   if (_0=="simPrimalTrust"):
    return numpy.int32(90)
   if (_0=="simDualTrust"):
    return numpy.int32(82)
   if (_0=="simPrimalNumSetbacks"):
    return numpy.int32(89)
   if (_0=="simDualNumSetbacks"):
    return numpy.int32(81)
   if (_0=="simNumDupvec"):
    return numpy.int32(85)
   if (_0=="simNumPrimalBoundswaps"):
    return numpy.int32(86)
   if (_0=="simNumDualBoundswaps"):
    return numpy.int32(83)
   if (_0=="simNumDualIntegerPivots"):
    return numpy.int32(84)
   if (_0=="biPrimalInfo"):
    return numpy.int32(1)
   if (_0=="biDualInfo"):
    return numpy.int32(0)
   if (_0=="presolveLindepNumTruncTries"):
    return numpy.int32(56)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1boundkey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1boundkey_1value_S(_0)
  @staticmethod
  def __string_1to_1boundkey_1value_S(_0):
   if (_0=="lo"):
    return numpy.int32(0)
   if (_0=="up"):
    return numpy.int32(1)
   if (_0=="fx"):
    return numpy.int32(2)
   if (_0=="fr"):
    return numpy.int32(3)
   if (_0=="ra"):
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solitem_1value_S(_0)
  @staticmethod
  def __string_1to_1solitem_1value_S(_0):
   if (_0=="xc"):
    return numpy.int32(0)
   if (_0=="xx"):
    return numpy.int32(1)
   if (_0=="y"):
    return numpy.int32(2)
   if (_0=="slc"):
    return numpy.int32(3)
   if (_0=="suc"):
    return numpy.int32(4)
   if (_0=="slx"):
    return numpy.int32(5)
   if (_0=="sux"):
    return numpy.int32(6)
   if (_0=="snx"):
    return numpy.int32(7)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1objsense_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1objsense_1value_S(_0)
  @staticmethod
  def __string_1to_1objsense_1value_S(_0):
   if (_0=="minimize"):
    return numpy.int32(0)
   if (_0=="maximize"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solsta_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solsta_1value_S(_0)
  @staticmethod
  def __string_1to_1solsta_1value_S(_0):
   if (_0=="unknown"):
    return numpy.int32(0)
   if (_0=="optimal"):
    return numpy.int32(1)
   if (_0=="primFeas"):
    return numpy.int32(2)
   if (_0=="dualFeas"):
    return numpy.int32(3)
   if (_0=="primAndDualFeas"):
    return numpy.int32(4)
   if (_0=="nearOptimal"):
    return numpy.int32(7)
   if (_0=="nearPrimFeas"):
    return numpy.int32(8)
   if (_0=="nearDualFeas"):
    return numpy.int32(9)
   if (_0=="nearPrimAndDualFeas"):
    return numpy.int32(10)
   if (_0=="primInfeasCer"):
    return numpy.int32(5)
   if (_0=="dualInfeasCer"):
    return numpy.int32(6)
   if (_0=="nearPrimInfeasCer"):
    return numpy.int32(11)
   if (_0=="nearDualInfeasCer"):
    return numpy.int32(12)
   if (_0=="primIllposedCer"):
    return numpy.int32(13)
   if (_0=="dualIllposedCer"):
    return numpy.int32(14)
   if (_0=="integerOptimal"):
    return numpy.int32(15)
   if (_0=="nearIntegerOptimal"):
    return numpy.int32(16)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iparam_1value_S(_0)
  @staticmethod
  def __string_1to_1iparam_1value_S(_0):
   if (_0=="autoUpdateSolInfo"):
    return numpy.int32(3)
   if (_0=="removeUnusedSolutions"):
    return numpy.int32(111)
   if (_0=="intpntHotstart"):
    return numpy.int32(18)
   if (_0=="mioMtUserCb"):
    return numpy.int32(70)
   if (_0=="numThreads"):
    return numpy.int32(80)
   if (_0=="intpntMultiThread"):
    return numpy.int32(22)
   if (_0=="timingLevel"):
    return numpy.int32(144)
   if (_0=="mtSpincount"):
    return numpy.int32(79)
   if (_0=="maxNumWarnings"):
    return numpy.int32(56)
   if (_0=="optimizer"):
    return numpy.int32(90)
   if (_0=="biMaxIterations"):
    return numpy.int32(8)
   if (_0=="licenseTrhExpiryWrn"):
    return numpy.int32(32)
   if (_0=="logCutSecondOpt"):
    return numpy.int32(39)
   if (_0=="logAnaPro"):
    return numpy.int32(35)
   if (_0=="logResponse"):
    return numpy.int32(49)
   if (_0=="logBi"):
    return numpy.int32(36)
   if (_0=="logBiFreq"):
    return numpy.int32(37)
   if (_0=="biCleanOptimizer"):
    return numpy.int32(5)
   if (_0=="intpntMaxNumRefinementSteps"):
    return numpy.int32(21)
   if (_0=="intpntStartingPoint"):
    return numpy.int32(28)
   if (_0=="intpntDiffStep"):
    return numpy.int32(17)
   if (_0=="intpntScaling"):
    return numpy.int32(26)
   if (_0=="intpntSolveForm"):
    return numpy.int32(27)
   if (_0=="logIntpnt"):
    return numpy.int32(44)
   if (_0=="intpntMaxIterations"):
    return numpy.int32(19)
   if (_0=="intpntOffColTrh"):
    return numpy.int32(23)
   if (_0=="intpntOrderMethod"):
    return numpy.int32(24)
   if (_0=="intpntBasis"):
    return numpy.int32(16)
   if (_0=="biIgnoreMaxIter"):
    return numpy.int32(6)
   if (_0=="biIgnoreNumError"):
    return numpy.int32(7)
   if (_0=="intpntMaxNumCor"):
    return numpy.int32(20)
   if (_0=="presolveUse"):
    return numpy.int32(100)
   if (_0=="presolveLevel"):
    return numpy.int32(95)
   if (_0=="logPresolve"):
    return numpy.int32(48)
   if (_0=="presolveLindepUse"):
    return numpy.int32(98)
   if (_0=="presolveEliminatorMaxNumTries"):
    return numpy.int32(94)
   if (_0=="presolveEliminatorMaxFill"):
    return numpy.int32(93)
   if (_0=="presolveMaxNumReductions"):
    return numpy.int32(99)
   if (_0=="simStabilityPriority"):
    return numpy.int32(137)
   if (_0=="simPrimalCrash"):
    return numpy.int32(127)
   if (_0=="logSim"):
    return numpy.int32(52)
   if (_0=="logSimMinor"):
    return numpy.int32(54)
   if (_0=="logSimFreq"):
    return numpy.int32(53)
   if (_0=="simPrimalRestrictSelection"):
    return numpy.int32(129)
   if (_0=="simPrimalSelection"):
    return numpy.int32(130)
   if (_0=="simDualRestrictSelection"):
    return numpy.int32(119)
   if (_0=="simDualSelection"):
    return numpy.int32(120)
   if (_0=="simMaxIterations"):
    return numpy.int32(124)
   if (_0=="simHotstartLu"):
    return numpy.int32(123)
   if (_0=="simRefactorFreq"):
    return numpy.int32(131)
   if (_0=="mioMode"):
    return numpy.int32(69)
   if (_0=="logMio"):
    return numpy.int32(45)
   if (_0=="logMioFreq"):
    return numpy.int32(46)
   if (_0=="mioMaxNumRelaxs"):
    return numpy.int32(67)
   if (_0=="mioMaxNumBranches"):
    return numpy.int32(66)
   if (_0=="mioMaxNumSolutions"):
    return numpy.int32(68)
   if (_0=="mioNodeSelection"):
    return numpy.int32(72)
   if (_0=="mioHeuristicLevel"):
    return numpy.int32(65)
   if (_0=="mioProbingLevel"):
    return numpy.int32(74)
   if (_0=="mioCutSelectionLevel"):
    return numpy.int32(64)
   if (_0=="mioVbDetectionLevel"):
    return numpy.int32(78)
   if (_0=="mioBranchDir"):
    return numpy.int32(57)
   if (_0=="mioRootOptimizer"):
    return numpy.int32(76)
   if (_0=="mioNodeOptimizer"):
    return numpy.int32(71)
   if (_0=="mioPerspectiveReformulate"):
    return numpy.int32(73)
   if (_0=="readDataFormat"):
    return numpy.int32(103)
   if (_0=="readDataCompressed"):
    return numpy.int32(102)
   if (_0=="readKeepFreeCon"):
    return numpy.int32(105)
   if (_0=="readMpsFormat"):
    return numpy.int32(108)
   if (_0=="writeMpsFormat"):
    return numpy.int32(163)
   if (_0=="readMpsWidth"):
    return numpy.int32(109)
   if (_0=="readDebug"):
    return numpy.int32(104)
   if (_0=="readLpQuotedNames"):
    return numpy.int32(107)
   if (_0=="writeDataFormat"):
    return numpy.int32(149)
   if (_0=="writeDataParam"):
    return numpy.int32(150)
   if (_0=="writeFreeCon"):
    return numpy.int32(151)
   if (_0=="writeGenericNames"):
    return numpy.int32(152)
   if (_0=="writeGenericNamesIo"):
    return numpy.int32(153)
   if (_0=="writeDataCompressed"):
    return numpy.int32(148)
   if (_0=="writeMpsInt"):
    return numpy.int32(164)
   if (_0=="writeLpStrictFormat"):
    return numpy.int32(161)
   if (_0=="writeLpQuotedNames"):
    return numpy.int32(160)
   if (_0=="writeLpLineWidth"):
    return numpy.int32(159)
   if (_0=="writeLpTermsPerLine"):
    return numpy.int32(162)
   if (_0=="writeLpFullObj"):
    return numpy.int32(158)
   if (_0=="writePrecision"):
    return numpy.int32(165)
   if (_0=="writeSolIgnoreInvalidNames"):
    return numpy.int32(169)
   if (_0=="writeSolHead"):
    return numpy.int32(168)
   if (_0=="writeSolConstraints"):
    return numpy.int32(167)
   if (_0=="writeSolVariables"):
    return numpy.int32(170)
   if (_0=="writeSolBarvariables"):
    return numpy.int32(166)
   if (_0=="writeBasHead"):
    return numpy.int32(146)
   if (_0=="writeBasConstraints"):
    return numpy.int32(145)
   if (_0=="writeBasVariables"):
    return numpy.int32(147)
   if (_0=="writeIntHead"):
    return numpy.int32(156)
   if (_0=="writeIntConstraints"):
    return numpy.int32(155)
   if (_0=="writeIntVariables"):
    return numpy.int32(157)
   if (_0=="solReadNameWidth"):
    return numpy.int32(141)
   if (_0=="solReadWidth"):
    return numpy.int32(142)
   if (_0=="infeasReportAuto"):
    return numpy.int32(14)
   if (_0=="infeasReportLevel"):
    return numpy.int32(15)
   if (_0=="infeasGenericNames"):
    return numpy.int32(12)
   if (_0=="logInfeasAna"):
    return numpy.int32(43)
   if (_0=="licenseWait"):
    return numpy.int32(33)
   if (_0=="licenseSuppressExpireWrns"):
    return numpy.int32(31)
   if (_0=="licensePauseTime"):
    return numpy.int32(30)
   if (_0=="licenseDebug"):
    return numpy.int32(29)
   if (_0=="solFilterKeepBasic"):
    return numpy.int32(139)
   if (_0=="solFilterKeepRanged"):
    return numpy.int32(140)
   if (_0=="log"):
    return numpy.int32(34)
   if (_0=="logExpand"):
    return numpy.int32(40)
   if (_0=="logFile"):
    return numpy.int32(42)
   if (_0=="logOrder"):
    return numpy.int32(47)
   if (_0=="logSensitivity"):
    return numpy.int32(50)
   if (_0=="logSensitivityOpt"):
    return numpy.int32(51)
   if (_0=="readTaskIgnoreParam"):
    return numpy.int32(110)
   if (_0=="writeTaskIncSol"):
    return numpy.int32(171)
   if (_0=="paramReadCaseName"):
    return numpy.int32(91)
   if (_0=="paramReadIgnError"):
    return numpy.int32(92)
   if (_0=="solutionCallback"):
    return numpy.int32(143)
   if (_0=="simScaling"):
    return numpy.int32(134)
   if (_0=="simScalingMethod"):
    return numpy.int32(135)
   if (_0=="simPrimalPhaseoneMethod"):
    return numpy.int32(128)
   if (_0=="simDualPhaseoneMethod"):
    return numpy.int32(118)
   if (_0=="simMaxNumSetbacks"):
    return numpy.int32(125)
   if (_0=="simHotstart"):
    return numpy.int32(122)
   if (_0=="simBasisFactorUse"):
    return numpy.int32(115)
   if (_0=="simDegen"):
    return numpy.int32(116)
   if (_0=="simReformulation"):
    return numpy.int32(132)
   if (_0=="simExploitDupvec"):
    return numpy.int32(121)
   if (_0=="simSaveLu"):
    return numpy.int32(133)
   if (_0=="simNonSingular"):
    return numpy.int32(126)
   if (_0=="simDualCrash"):
    return numpy.int32(117)
   if (_0=="logStorage"):
    return numpy.int32(55)
   if (_0=="infeasPreferPrimal"):
    return numpy.int32(13)
   if (_0=="readLpDropNewVarsInBou"):
    return numpy.int32(106)
   if (_0=="opfMaxTermsPerLine"):
    return numpy.int32(81)
   if (_0=="opfWriteHints"):
    return numpy.int32(83)
   if (_0=="opfWriteParameters"):
    return numpy.int32(84)
   if (_0=="opfWriteProblem"):
    return numpy.int32(85)
   if (_0=="opfWriteHeader"):
    return numpy.int32(82)
   if (_0=="opfWriteSolutions"):
    return numpy.int32(89)
   if (_0=="opfWriteSolBas"):
    return numpy.int32(86)
   if (_0=="opfWriteSolItg"):
    return numpy.int32(87)
   if (_0=="opfWriteSolItr"):
    return numpy.int32(88)
   if (_0=="primalRepairOptimizer"):
    return numpy.int32(101)
   if (_0=="mioRootRepeatPresolveLevel"):
    return numpy.int32(77)
   if (_0=="mioCutCmir"):
    return numpy.int32(60)
   if (_0=="mioCutClique"):
    return numpy.int32(59)
   if (_0=="mioCutImpliedBound"):
    return numpy.int32(62)
   if (_0=="mioCutKnapsackCover"):
    return numpy.int32(63)
   if (_0=="mioCutGmi"):
    return numpy.int32(61)
   if (_0=="sensitivityType"):
    return numpy.int32(114)
   if (_0=="mioConstructSol"):
    return numpy.int32(58)
   if (_0=="presolveLindepRelWorkTrh"):
    return numpy.int32(97)
   if (_0=="presolveLindepAbsWorkTrh"):
    return numpy.int32(96)
   if (_0=="sensitivityAll"):
    return numpy.int32(112)
   if (_0=="logFeasRepair"):
    return numpy.int32(41)
   if (_0=="cacheLicense"):
    return numpy.int32(9)
   if (_0=="intpntRegularizationUse"):
    return numpy.int32(25)
   if (_0=="simSolveForm"):
    return numpy.int32(136)
   if (_0=="simSwitchOptimizer"):
    return numpy.int32(138)
   if (_0=="writeIgnoreIncompatibleItems"):
    return numpy.int32(154)
   if (_0=="checkConvexity"):
    return numpy.int32(10)
   if (_0=="logCheckConvexity"):
    return numpy.int32(38)
   if (_0=="autoSortABeforeOpt"):
    return numpy.int32(2)
   if (_0=="sensitivityOptimizer"):
    return numpy.int32(113)
   if (_0=="writeXmlMode"):
    return numpy.int32(172)
   if (_0=="anaSolBasis"):
    return numpy.int32(0)
   if (_0=="anaSolPrintViolated"):
    return numpy.int32(1)
   if (_0=="basisSolveUsePlusOne"):
    return numpy.int32(4)
   if (_0=="compressStatfile"):
    return numpy.int32(11)
   if (_0=="mioRinsMaxNodes"):
    return numpy.int32(75)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1sparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1sparam_1value_S(_0)
  @staticmethod
  def __string_1to_1sparam_1value_S(_0):
   if (_0=="dataFileName"):
    return numpy.int32(1)
   if (_0=="paramReadFileName"):
    return numpy.int32(7)
   if (_0=="paramWriteFileName"):
    return numpy.int32(8)
   if (_0=="paramCommentSign"):
    return numpy.int32(6)
   if (_0=="debugFileName"):
    return numpy.int32(2)
   if (_0=="basSolFileName"):
    return numpy.int32(0)
   if (_0=="itrSolFileName"):
    return numpy.int32(4)
   if (_0=="intSolFileName"):
    return numpy.int32(3)
   if (_0=="solFilterXcLow"):
    return numpy.int32(16)
   if (_0=="solFilterXcUpr"):
    return numpy.int32(17)
   if (_0=="solFilterXxLow"):
    return numpy.int32(18)
   if (_0=="solFilterXxUpr"):
    return numpy.int32(19)
   if (_0=="readMpsObjName"):
    return numpy.int32(10)
   if (_0=="readMpsRanName"):
    return numpy.int32(11)
   if (_0=="readMpsRhsName"):
    return numpy.int32(12)
   if (_0=="readMpsBouName"):
    return numpy.int32(9)
   if (_0=="statFileName"):
    return numpy.int32(20)
   if (_0=="statName"):
    return numpy.int32(22)
   if (_0=="statKey"):
    return numpy.int32(21)
   if (_0=="writeLpGenVarName"):
    return numpy.int32(23)
   if (_0=="sensitivityResFileName"):
    return numpy.int32(15)
   if (_0=="sensitivityFileName"):
    return numpy.int32(14)
   if (_0=="mioDebugString"):
    return numpy.int32(5)
   if (_0=="remoteAccessToken"):
    return numpy.int32(13)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1intpnthotstart_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1intpnthotstart_1value_S(_0)
  @staticmethod
  def __string_1to_1intpnthotstart_1value_S(_0):
   if (_0=="none"):
    return numpy.int32(0)
   if (_0=="primal"):
    return numpy.int32(1)
   if (_0=="dual"):
    return numpy.int32(2)
   if (_0=="primalDual"):
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1uplo_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1uplo_1value_S(_0)
  @staticmethod
  def __string_1to_1uplo_1value_S(_0):
   if (_0=="lo"):
    return numpy.int32(0)
   if (_0=="up"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1sensitivitytype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1sensitivitytype_1value_S(_0)
  @staticmethod
  def __string_1to_1sensitivitytype_1value_S(_0):
   if (_0=="basis"):
    return numpy.int32(0)
   if (_0=="optimalPartition"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1accmode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1accmode_1value_S(_0)
  @staticmethod
  def __string_1to_1accmode_1value_S(_0):
   if (_0=="var"):
    return numpy.int32(0)
   if (_0=="con"):
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1problemitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1problemitem_1value_S(_0)
  @staticmethod
  def __string_1to_1problemitem_1value_S(_0):
   if (_0=="var"):
    return numpy.int32(0)
   if (_0=="con"):
    return numpy.int32(1)
   if (_0=="cone"):
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solveform_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solveform_1value_S(_0)
  @staticmethod
  def __string_1to_1solveform_1value_S(_0):
   if (_0=="free"):
    return numpy.int32(0)
   if (_0=="primal"):
    return numpy.int32(1)
   if (_0=="dual"):
    return numpy.int32(2)
   return numpy.int32((- 1))
 return Parameters
mosek_fusion_Parameters=__mk_mosek_fusion_Parameters()
del __mk_mosek_fusion_Parameters
def __mk_mosek_fusion_Utils_StringIntMap():
  class StringIntMap:
    def __init__ (self):
      self.__d = {}
    def _hasItem_S(self,key): return key in self.__d
    def _getItem_S(self,key): return self.__d[key]
    def _setItem_SI(self,key,val): self.__d[key] = val
    def _keys_(self): return numpy.array(list(self.__d.keys()))
    def _values_(self): return numpy.array(list(self.__d.values()))
    def _clone_(self):
      r = self.__class__()
      r.__d.update(self.__d)
      return r
  return StringIntMap
mosek_fusion_Utils_StringIntMap=__mk_mosek_fusion_Utils_StringIntMap()
def __mk_mosek_fusion_Utils_IntMap():
  class IntMap:
    def __init__ (self):
      self.__d = {}
    def _hasItem_J(self,key): return key in self.__d
    def _getItem_J(self,key): return self.__d[key]
    def _setItem_JI(self,key,val): self.__d[key] = val
    def _keys_(self): return numpy.array(list(self.__d.keys()))
    def _values_(self): return numpy.array(list(self.__d.values()))
    def _clone_(self):
      r = self.__class__()
      r.__d.update(self.__d)
      return r
  
  
  
  return IntMap
mosek_fusion_Utils_IntMap=__mk_mosek_fusion_Utils_IntMap()
def __mk_mosek_fusion_Utils_StringBuffer():
  class StringBuffer:
    def __init__(self):
      self.__buf = []
    def __a(self,v):
      self.__buf.append(str(v))
      return self 
    def __a_array(self,v):
      if v is None: self.__buf.append("None")
      else: self.__buf.append(str(v))
      return self
  
    _a_I   = __a
    _a_J   = __a
    _a_U   = __a
    _a_D   = __a
    _a_S   = __a
    _a_B   = __a
    _a__3I = __a_array
    def _a__3J(self,v):
      if v is not None: self.__buf.extend([ '[',','.join(['%i' % i for i in v]),']'])
      else:             self.__buf.append('None')  
      return self
    def _a__3D(self,v):
      if v is not None: self.__buf.extend([ '[',','.join(['%g' % i for i in v]),']'])
      else:             self.__buf.append('None')  
      return self
    _a__3S = __a_array
    def _lf_(self): 
      self.__buf.append('\n')
      return self
    def _clear_ (self):
      self.__buf = []
      return self
    def _toString_(self):
      return ''.join(self.__buf)
    def _toString_(self):
      return ''.join(self.__buf)
    def _consolePrint_(self):
      print(self._toString_())
      self._clear_()
      return(self)
  
  return StringBuffer
mosek_fusion_Utils_StringBuffer=__mk_mosek_fusion_Utils_StringBuffer()
def __mk_mosek_fusion_Utils_Tools():
  
  import random,ctypes,math
  class Tools:
    @staticmethod
    def __arraycopy(src,srcoffset,tgt,tgtoffset,size):
      if len(tgt) < tgtoffset+size or len(src) < srcoffset+size:
        raise IndexError("Copy slice out of range")
      tgt[tgtoffset:tgtoffset+size] = src[srcoffset:srcoffset+size]
  
    _arraycopy__3II_3III =  __arraycopy
    _arraycopy__3JI_3JII = __arraycopy
    _arraycopy__3_3II_3_3III = __arraycopy
    _arraycopy__3_3DI_3_3DII = __arraycopy
    _arraycopy__3DI_3DII = __arraycopy
    _arraycopy__3IJ_3IJJ = __arraycopy
    _arraycopy__3JJ_3JJJ = __arraycopy
    _arraycopy__3DJ_3DJJ = __arraycopy
  
    @staticmethod
    def __arrayclone(a): 
      if isinstance(a,numpy.ndarray):
        return a.copy()
      else:      
        return numpy.array(a)
  
    _arraycopy__3D = __arrayclone
    _arraycopy__3I = __arrayclone
    _arraycopy__3J = __arrayclone
    _arraycopy__3S = __arrayclone
  
    @staticmethod
    def __arraylength(a): return len(a)
  
    _arraylength__3Lmosek_4fusion_4Variable_2   = __arraylength
    _arraylength__3Lmosek_4fusion_4Constranit_2 = __arraylength  
    _arraylength__3Lmosek_4fusion_4Matrix_2     = __arraylength  
    _arraylength__3S   = __arraylength  
    _arraylength__3I   = __arraylength  
    _arraylength__3J   = __arraylength  
    _arraylength__3D   = __arraylength  
    _arraylength__3_3D = __arraylength  
    _arraylength__3_3I = __arraylength  
    _uarraylength__3I  = __arraylength 
    _uarraylength__3J  = __arraylength 
    _uarraylength__3D  = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Variable_2   = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Constraint_2 = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Matrix_2     = __arraylength 
    _uarraylength__3_3S = __arraylength 
    _uarraylength__3_3D = __arraylength 
    _uarraylength__3_3I = __arraylength 
  
    @staticmethod
    def __matrixheight(m): return m.shape[0]
    @staticmethod
    def __matrixwidth(m): return m.shape[1]
    
    _matrixheight__3_3D = __matrixheight
    _matrixwidth__3_3D  = __matrixwidth
    _matrixheight__3_3Lmosek_4fusion_4Matrix_2 = __matrixheight
    _matrixwidth__3_3Lmosek_4fusion_4Matrix_2  = __matrixwidth
   
    @staticmethod   
    def _range_J (last): return numpy.arange(last,dtype=numpy.int64)
    @staticmethod   
    def _range_JJ(first,last): return numpy.arange(first,last,dtype=numpy.int64)
    @staticmethod   
    def _range_JJJ(first,last,step): return numpy.arange(first,last,step,dtype=numpy.int64)
  
    @staticmethod   
    def _range_I (last): return numpy.arange(last,dtype=numpy.int32)
    @staticmethod   
    def _range_II(first,last): return numpy.arange(first,last,dtype=numpy.int32)
    @staticmethod   
    def _range_III(first,last,step): return numpy.arange(first,last,step,dtype=numpy.int32)
  
    @staticmethod   
    def _zeros_I (num): return  numpy.zeros((num,),dtype=numpy.float64)
    @staticmethod   
    def _zeros_II (dimi,dimj): return  numpy.zeros((dimi,dimj),dtype=numpy.float64)
    @staticmethod   
    def _ones_I(num):  return  numpy.ones((num,),numpy.float64)
    
    __rand = random.Random()
    @staticmethod   
    def _randInt_I(max):
      return Tools.__rand.randint(0,max-1)
      
    @staticmethod   
    def _argsort__3J_3I_3JII(perm,val1,val2,first,last):
      if last-first > 1:
        p = list(perm[first:last])
        p.sort(lambda lhs,rhs: cmp(val1[lhs],val1[rhs]) or cmp(val2[lhs],val2[rhs]))
        perm[first:last] = p
  
    @staticmethod   
    def _argsort__3J_3I_3I(perm,val1,val2):    
      Tools._argsort__3I_3I_3III(perm,val1,val2,0,len(perm))
    
    @staticmethod   
    def _argsort__3J_3I(perm,vals):
      Tools._argsort__3I_3III(perm,vals,0,len(perm))
  
    @staticmethod   
    def _argsort__3J_3III(perm,val,first,last):
      if last-first > 1:
        p = list(perm[first:last])
        p.sort(lambda lhs,rhs: cmp(val[lhs],val[rhs]))
        perm[first:last] = p
  
    @staticmethod
    def _sort__3I_II (vals,first,last):
      if last-first > 1:
        tmp = vals[first:last]
        tmp.sort()
        vals[first:last] = tmp
  
    @staticmethod   
    def _makevector_DI(val,num): 
      r = numpy.zeros((num,), numpy.float64)
      r[:] = val
      return r
    @staticmethod   
    def _makevector_II(val,num): 
      r = numpy.zeros((num,), numpy.int32)
      r[:] = val
      return r
    @staticmethod   
    def _makevector_JI(val,num): 
      r = numpy.zeros((num,), numpy.int64)
      r[:] = val
      return r
    @staticmethod   
    def _repeatrange_III(first,last,num):
      res = numpy.zeros(((last-first)*num,),numpy.int32)
      ra = numpy.arange(first,last)
      l = last-first
      for i in range(num):
        res[i*l:(i+1)*l] = ra
      return res
    @staticmethod   
    def _repeatrange_JJJ(first,last,num):
      res = numpy.zeros(((last-first)*num,),numpy.int64)
      ra = numpy.arange(first,last)
      l = last-first
      for i in range(num):
        res[i*l:(i+1)*l] = ra
      return res
    @staticmethod
    def  _stringvalue_I(v): return str(v)
    @staticmethod
    def  _stringvalue_J(v): return str(v)
  
    @staticmethod
    def _toDouble_S(v):    
      return float(v)
  
    @staticmethod
    def _sqrt_D(v):
      return math.sqrt(v)
    
    @staticmethod
    def _toInt_S(v):
      return int(v)
  
  
    @staticmethod 
    def _argsort2(perm,v,first,last):
      l = sorted(perm[first:last],key=lambda i: v[i])
      perm[first:last] = l
    
    @staticmethod 
    def _argsort2x(perm,v0,v1,first,last):
      l = sorted(perm[first:last],key=lambda i: (v0[i],v1[i]))
      perm[first:last] = l
  
  
  
    @staticmethod 
    def _argsort__3J_3IJJ(perm,v,first,last):
      return Tools._argsort2(perm,v,first,last)
    
    @staticmethod 
    def _argsort__3J_3JJJ(perm,v,first,last):
      return Tools._argsort2(perm,v,first,last)
  
    @staticmethod 
    def _argsort__3J_3I_3IJJ(perm,v0,v1,first,last):
      return Tools._argsort2x(perm,v0,v1,first,last)
    
    @staticmethod 
    def _argsort__3J_3J_3JJJ(perm,v0,v1,first,last):
      return Tools._argsort2x(perm,v0,v1,first,last)
  
    @staticmethod
    def _bucketsort__3JJJ_3III(perm,first,last,v,minval,maxval):
      if True:
        count = numpy.zeros((maxval-minval+2,),numpy.int64)
        for i in range(first,last): count[v[perm[i]]-minval+1] += 1
        ptrb = count.cumsum()
        rperm = numpy.zeros((last-first,),numpy.int64)
        for i in range(first,last):
          rperm[ptrb[v[perm[i]]-minval]] = perm[i]
          ptrb[v[perm[i]]-minval] += 1
        perm[first:last] = rperm
  
      else:
        perm_ct = perm.ctypes
        v_ct    = v.ctypes
        if perm_ct.strides[0] == 8:
          #print( perm_ct.strides[:], perm_ct.shape[:],perm_ct.get_data())
          arg_perm  = perm_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = False
        else:
          tmpperm = numpy.array(perm_ct[first:last],numpy.int64)
          arg_perm  = tmpperm.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = True
  
        if v_ct.strides[0] == 4:
          arg_v = v_ct.data_as(ctypes.POINTER(ctypes.c_int))
          copy_v = False
        else:
          tmpv = numpy.array(v_ct,numpy.int32)
          arg_v  = tmpv.ctypes.data_as(ctypes.POINTER(ctypes.c_int))
          copy_v = True
  
        n = last-first
        m = maxval - minval + 1
        workspace = (ctypes.c_longlong*(m+n))()
  
        mosek.__library__.MSK_bucketsort__3JS_3III_3V(arg_perm,first,last,arg_v,minval,maxval,workspace)
        del arg_perm,arg_v
  
        if copy_v: 
          v[:] = tmpv
          del tmpv
        if copy_perm: 
          perm[first:last] = tmpperm
          del tmpperm
  
      
    @staticmethod
    def _bucketsort__3JJJ_3JJJ(perm,first,last,v,minval,maxval):
      if True:
        count = numpy.zeros((maxval-minval+2,),numpy.int64)
        for i in range(first,last): count[v[perm[i]]-minval+1] += 1
        ptrb = count.cumsum()
        rperm = numpy.zeros((last-first,),numpy.int64)
        for i in range(first,last):
          rperm[ptrb[v[perm[i]]-minval]] = perm[i]
          ptrb[v[perm[i]]-minval] += 1
        perm[first:last] = rperm
        #print( rperm,v)
  
      else:
        perm_ct = perm.ctypes
        v_ct    = v.ctypes
        
       
        if perm_ct.strides[0] == 8:
          arg_perm  = perm_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = False
        else:
          tmpperm = numpy.array(perm_ct[first:last],numpy.int64)
          arg_perm  = tmpperm.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = True
  
  
        if v_ct.strides[0] == 8:
          arg_v = v_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_v = False
        else:
          tmpv = numpy.array(v_ct,numpy.int64)
          arg_v  = tmpv.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_v = True
  
        n = last-first
        m = maxval - minval + 1
        workspace = (ctypes.c_longlong*(m+n))()
  
        mosek.__library__.MSK_bucketsort__3JS_3JJJ_3V(arg_perm,first,last,arg_v,minval,maxval,workspace)
  
        if copy_v: v[:] = tmpv
        if copy_perm: perm[first:last] = tmpperm
  
  
  
  
  return Tools
mosek_fusion_Utils_Tools=__mk_mosek_fusion_Utils_Tools()
def __mk_mosek_fusion_SolverInfo():
  from bisect import bisect_left
  import mosek
  class SolverInfo:
    dinfnames  = [ "biCleanDualTime","biCleanPrimalTime","biCleanTime","biDualTime","biPrimalTime","biTime","intpntDualFeas","intpntDualObj","intpntFactorNumFlops","intpntOptStatus","intpntOrderTime","intpntPrimalFeas","intpntPrimalObj","intpntTime","mioCliqueSeparationTime","mioCmirSeparationTime","mioConstructSolutionObj","mioDualBoundAfterPresolve","mioGmiSeparationTime","mioHeuristicTime","mioImpliedBoundTime","mioKnapsackCoverSeparationTime","mioObjAbsGap","mioObjBound","mioObjInt","mioObjRelGap","mioOptimizerTime","mioProbingTime","mioRootCutgenTime","mioRootOptimizerTime","mioRootPresolveTime","mioTime","mioUserObjCut","optimizerTime","presolveEliTime","presolveLindepTime","presolveTime","primalRepairPenaltyObj","qcqoReformulateMaxPerturbation","qcqoReformulateTime","qcqoReformulateWorstCholeskyColumnScaling","qcqoReformulateWorstCholeskyDiagScaling","rdTime","simDualTime","simFeas","simObj","simPrimalTime","simTime","solBasDualObj","solBasDviolcon","solBasDviolvar","solBasNrmBarx","solBasNrmSlc","solBasNrmSlx","solBasNrmSuc","solBasNrmSux","solBasNrmXc","solBasNrmXx","solBasNrmY","solBasPrimalObj","solBasPviolcon","solBasPviolvar","solItgNrmBarx","solItgNrmXc","solItgNrmXx","solItgPrimalObj","solItgPviolbarvar","solItgPviolcon","solItgPviolcones","solItgPviolitg","solItgPviolvar","solItrDualObj","solItrDviolbarvar","solItrDviolcon","solItrDviolcones","solItrDviolvar","solItrNrmBars","solItrNrmBarx","solItrNrmSlc","solItrNrmSlx","solItrNrmSnx","solItrNrmSuc","solItrNrmSux","solItrNrmXc","solItrNrmXx","solItrNrmY","solItrPrimalObj","solItrPviolbarvar","solItrPviolcon","solItrPviolcones","solItrPviolvar","toConicTime" ];
    iinfnames  = [ "anaProNumCon","anaProNumConEq","anaProNumConFr","anaProNumConLo","anaProNumConRa","anaProNumConUp","anaProNumVar","anaProNumVarBin","anaProNumVarCont","anaProNumVarEq","anaProNumVarFr","anaProNumVarInt","anaProNumVarLo","anaProNumVarRa","anaProNumVarUp","intpntFactorDimDense","intpntIter","intpntNumThreads","intpntSolveDual","mioAbsgapSatisfied","mioCliqueTableSize","mioConstructNumRoundings","mioConstructSolution","mioInitialSolution","mioNearAbsgapSatisfied","mioNearRelgapSatisfied","mioNodeDepth","mioNumActiveNodes","mioNumBranch","mioNumCliqueCuts","mioNumCmirCuts","mioNumGomoryCuts","mioNumImpliedBoundCuts","mioNumIntSolutions","mioNumKnapsackCoverCuts","mioNumRelax","mioNumRepeatedPresolve","mioNumcon","mioNumint","mioNumvar","mioObjBoundDefined","mioPresolvedNumbin","mioPresolvedNumcon","mioPresolvedNumcont","mioPresolvedNumint","mioPresolvedNumvar","mioRelgapSatisfied","mioTotalNumCuts","mioUserObjCut","optNumcon","optNumvar","optimizeResponse","rdNumbarvar","rdNumcon","rdNumcone","rdNumintvar","rdNumq","rdNumvar","rdProtype","simDualDegIter","simDualHotstart","simDualHotstartLu","simDualInfIter","simDualIter","simNumcon","simNumvar","simPrimalDegIter","simPrimalHotstart","simPrimalHotstartLu","simPrimalInfIter","simPrimalIter","simSolveDual","solBasProsta","solBasSolsta","solItgProsta","solItgSolsta","solItrProsta","solItrSolsta","stoNumARealloc" ];
    liinfnames = [ "biCleanDualDegIter","biCleanDualIter","biCleanPrimalDegIter","biCleanPrimalIter","biDualIter","biPrimalIter","intpntFactorNumNz","mioIntpntIter","mioPresolvedAnz","mioSimMaxiterSetbacks","mioSimplexIter","rdNumanz","rdNumqnz" ];
    dinfsyms   = [ mosek.dinfitem.bi_clean_dual_time,mosek.dinfitem.bi_clean_primal_time,mosek.dinfitem.bi_clean_time,mosek.dinfitem.bi_dual_time,mosek.dinfitem.bi_primal_time,mosek.dinfitem.bi_time,mosek.dinfitem.intpnt_dual_feas,mosek.dinfitem.intpnt_dual_obj,mosek.dinfitem.intpnt_factor_num_flops,mosek.dinfitem.intpnt_opt_status,mosek.dinfitem.intpnt_order_time,mosek.dinfitem.intpnt_primal_feas,mosek.dinfitem.intpnt_primal_obj,mosek.dinfitem.intpnt_time,mosek.dinfitem.mio_clique_separation_time,mosek.dinfitem.mio_cmir_separation_time,mosek.dinfitem.mio_construct_solution_obj,mosek.dinfitem.mio_dual_bound_after_presolve,mosek.dinfitem.mio_gmi_separation_time,mosek.dinfitem.mio_heuristic_time,mosek.dinfitem.mio_implied_bound_time,mosek.dinfitem.mio_knapsack_cover_separation_time,mosek.dinfitem.mio_obj_abs_gap,mosek.dinfitem.mio_obj_bound,mosek.dinfitem.mio_obj_int,mosek.dinfitem.mio_obj_rel_gap,mosek.dinfitem.mio_optimizer_time,mosek.dinfitem.mio_probing_time,mosek.dinfitem.mio_root_cutgen_time,mosek.dinfitem.mio_root_optimizer_time,mosek.dinfitem.mio_root_presolve_time,mosek.dinfitem.mio_time,mosek.dinfitem.mio_user_obj_cut,mosek.dinfitem.optimizer_time,mosek.dinfitem.presolve_eli_time,mosek.dinfitem.presolve_lindep_time,mosek.dinfitem.presolve_time,mosek.dinfitem.primal_repair_penalty_obj,mosek.dinfitem.qcqo_reformulate_max_perturbation,mosek.dinfitem.qcqo_reformulate_time,mosek.dinfitem.qcqo_reformulate_worst_cholesky_column_scaling,mosek.dinfitem.qcqo_reformulate_worst_cholesky_diag_scaling,mosek.dinfitem.rd_time,mosek.dinfitem.sim_dual_time,mosek.dinfitem.sim_feas,mosek.dinfitem.sim_obj,mosek.dinfitem.sim_primal_time,mosek.dinfitem.sim_time,mosek.dinfitem.sol_bas_dual_obj,mosek.dinfitem.sol_bas_dviolcon,mosek.dinfitem.sol_bas_dviolvar,mosek.dinfitem.sol_bas_nrm_barx,mosek.dinfitem.sol_bas_nrm_slc,mosek.dinfitem.sol_bas_nrm_slx,mosek.dinfitem.sol_bas_nrm_suc,mosek.dinfitem.sol_bas_nrm_sux,mosek.dinfitem.sol_bas_nrm_xc,mosek.dinfitem.sol_bas_nrm_xx,mosek.dinfitem.sol_bas_nrm_y,mosek.dinfitem.sol_bas_primal_obj,mosek.dinfitem.sol_bas_pviolcon,mosek.dinfitem.sol_bas_pviolvar,mosek.dinfitem.sol_itg_nrm_barx,mosek.dinfitem.sol_itg_nrm_xc,mosek.dinfitem.sol_itg_nrm_xx,mosek.dinfitem.sol_itg_primal_obj,mosek.dinfitem.sol_itg_pviolbarvar,mosek.dinfitem.sol_itg_pviolcon,mosek.dinfitem.sol_itg_pviolcones,mosek.dinfitem.sol_itg_pviolitg,mosek.dinfitem.sol_itg_pviolvar,mosek.dinfitem.sol_itr_dual_obj,mosek.dinfitem.sol_itr_dviolbarvar,mosek.dinfitem.sol_itr_dviolcon,mosek.dinfitem.sol_itr_dviolcones,mosek.dinfitem.sol_itr_dviolvar,mosek.dinfitem.sol_itr_nrm_bars,mosek.dinfitem.sol_itr_nrm_barx,mosek.dinfitem.sol_itr_nrm_slc,mosek.dinfitem.sol_itr_nrm_slx,mosek.dinfitem.sol_itr_nrm_snx,mosek.dinfitem.sol_itr_nrm_suc,mosek.dinfitem.sol_itr_nrm_sux,mosek.dinfitem.sol_itr_nrm_xc,mosek.dinfitem.sol_itr_nrm_xx,mosek.dinfitem.sol_itr_nrm_y,mosek.dinfitem.sol_itr_primal_obj,mosek.dinfitem.sol_itr_pviolbarvar,mosek.dinfitem.sol_itr_pviolcon,mosek.dinfitem.sol_itr_pviolcones,mosek.dinfitem.sol_itr_pviolvar,mosek.dinfitem.to_conic_time ];
    iinfsyms   = [ mosek.iinfitem.ana_pro_num_con,mosek.iinfitem.ana_pro_num_con_eq,mosek.iinfitem.ana_pro_num_con_fr,mosek.iinfitem.ana_pro_num_con_lo,mosek.iinfitem.ana_pro_num_con_ra,mosek.iinfitem.ana_pro_num_con_up,mosek.iinfitem.ana_pro_num_var,mosek.iinfitem.ana_pro_num_var_bin,mosek.iinfitem.ana_pro_num_var_cont,mosek.iinfitem.ana_pro_num_var_eq,mosek.iinfitem.ana_pro_num_var_fr,mosek.iinfitem.ana_pro_num_var_int,mosek.iinfitem.ana_pro_num_var_lo,mosek.iinfitem.ana_pro_num_var_ra,mosek.iinfitem.ana_pro_num_var_up,mosek.iinfitem.intpnt_factor_dim_dense,mosek.iinfitem.intpnt_iter,mosek.iinfitem.intpnt_num_threads,mosek.iinfitem.intpnt_solve_dual,mosek.iinfitem.mio_absgap_satisfied,mosek.iinfitem.mio_clique_table_size,mosek.iinfitem.mio_construct_num_roundings,mosek.iinfitem.mio_construct_solution,mosek.iinfitem.mio_initial_solution,mosek.iinfitem.mio_near_absgap_satisfied,mosek.iinfitem.mio_near_relgap_satisfied,mosek.iinfitem.mio_node_depth,mosek.iinfitem.mio_num_active_nodes,mosek.iinfitem.mio_num_branch,mosek.iinfitem.mio_num_clique_cuts,mosek.iinfitem.mio_num_cmir_cuts,mosek.iinfitem.mio_num_gomory_cuts,mosek.iinfitem.mio_num_implied_bound_cuts,mosek.iinfitem.mio_num_int_solutions,mosek.iinfitem.mio_num_knapsack_cover_cuts,mosek.iinfitem.mio_num_relax,mosek.iinfitem.mio_num_repeated_presolve,mosek.iinfitem.mio_numcon,mosek.iinfitem.mio_numint,mosek.iinfitem.mio_numvar,mosek.iinfitem.mio_obj_bound_defined,mosek.iinfitem.mio_presolved_numbin,mosek.iinfitem.mio_presolved_numcon,mosek.iinfitem.mio_presolved_numcont,mosek.iinfitem.mio_presolved_numint,mosek.iinfitem.mio_presolved_numvar,mosek.iinfitem.mio_relgap_satisfied,mosek.iinfitem.mio_total_num_cuts,mosek.iinfitem.mio_user_obj_cut,mosek.iinfitem.opt_numcon,mosek.iinfitem.opt_numvar,mosek.iinfitem.optimize_response,mosek.iinfitem.rd_numbarvar,mosek.iinfitem.rd_numcon,mosek.iinfitem.rd_numcone,mosek.iinfitem.rd_numintvar,mosek.iinfitem.rd_numq,mosek.iinfitem.rd_numvar,mosek.iinfitem.rd_protype,mosek.iinfitem.sim_dual_deg_iter,mosek.iinfitem.sim_dual_hotstart,mosek.iinfitem.sim_dual_hotstart_lu,mosek.iinfitem.sim_dual_inf_iter,mosek.iinfitem.sim_dual_iter,mosek.iinfitem.sim_numcon,mosek.iinfitem.sim_numvar,mosek.iinfitem.sim_primal_deg_iter,mosek.iinfitem.sim_primal_hotstart,mosek.iinfitem.sim_primal_hotstart_lu,mosek.iinfitem.sim_primal_inf_iter,mosek.iinfitem.sim_primal_iter,mosek.iinfitem.sim_solve_dual,mosek.iinfitem.sol_bas_prosta,mosek.iinfitem.sol_bas_solsta,mosek.iinfitem.sol_itg_prosta,mosek.iinfitem.sol_itg_solsta,mosek.iinfitem.sol_itr_prosta,mosek.iinfitem.sol_itr_solsta,mosek.iinfitem.sto_num_a_realloc ];
    liinfsyms  = [ mosek.liinfitem.bi_clean_dual_deg_iter,mosek.liinfitem.bi_clean_dual_iter,mosek.liinfitem.bi_clean_primal_deg_iter,mosek.liinfitem.bi_clean_primal_iter,mosek.liinfitem.bi_dual_iter,mosek.liinfitem.bi_primal_iter,mosek.liinfitem.intpnt_factor_num_nz,mosek.liinfitem.mio_intpnt_iter,mosek.liinfitem.mio_presolved_anz,mosek.liinfitem.mio_sim_maxiter_setbacks,mosek.liinfitem.mio_simplex_iter,mosek.liinfitem.rd_numanz,mosek.liinfitem.rd_numqnz ];
    @staticmethod
    def _getdouinf(infname):
      idx = bisect_left(SolverInfo.dinfnames, infname)
      if idx != len(SolverInfo.dinfnames) and SolverInfo.dinfnames[idx] == infname:
        return SolverInfo.dinfsyms[idx]
      else:
        return None
    @staticmethod
    def _getintinf(infname):
      idx = bisect_left(SolverInfo.iinfnames, infname)
      if idx != len(SolverInfo.iinfnames) and SolverInfo.iinfnames[idx] == infname:
        return SolverInfo.iinfsyms[idx]
      else:
        return None
    @staticmethod
    def _getlintinf(infname):
      idx = bisect_left(SolverInfo.liinfnames, infname)
      if idx != len(SolverInfo.liinfnames) and SolverInfo.liinfnames[idx] == infname:
        return SolverInfo.liinfsyms[idx]
      else:
        return None
  return SolverInfo
mosek_fusion_SolverInfo=__mk_mosek_fusion_SolverInfo()
def __arg_match_Emosek_4fusion_4PSDKey_2__(v):
  return isinstance(v,mosek_fusion_PSDKey)
def __arg_alt_match_Emosek_4fusion_4PSDKey_2__(v):
  return isinstance(v,mosek_fusion_PSDKey)
def __arg_match_Lmosek_4fusion_4PSDConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDConstraint)
def __arg_alt_match_Lmosek_4fusion_4PSDConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDConstraint_2__(v)
def __arg_match_Emosek_4fusion_4SolutionType_2__(v):
  return isinstance(v,mosek_fusion_SolutionType)
def __arg_alt_match_Emosek_4fusion_4SolutionType_2__(v):
  return isinstance(v,mosek_fusion_SolutionType)
def __arg_match_Lmosek_4fusion_4RangedVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangedVariable)
def __arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4RangedVariable_2__(v)
def __arg_match_Lmosek_4fusion_4NDSparseArray_2__(v):
  return v is None or isinstance(v,mosek_fusion_NDSparseArray)
def __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(v):
  return __arg_match_Lmosek_4fusion_4NDSparseArray_2__(v)
def __arg_match__3_3D__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3D__(i) for i in v.flatten()])
def __arg_alt_match__3_3D__(v):
  return __arg_match__3_3D__(v) or __arg_match_listof__(v,__arg_alt_match__3D__)
def __arg_match_Lmosek_4fusion_4RangedConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangedConstraint)
def __arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4RangedConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4ModelVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_ModelVariable)
def __arg_alt_match_Lmosek_4fusion_4ModelVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4ModelVariable_2__(v)
def __arg_match_Lmosek_4fusion_4Set_2__(v):
  return v is None or isinstance(v,mosek_fusion_Set)
def __arg_alt_match_Lmosek_4fusion_4Set_2__(v):
  return __arg_match_Lmosek_4fusion_4Set_2__(v)
def __arg_match_Lmosek_4fusion_4QConeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_QConeDomain)
def __arg_alt_match_Lmosek_4fusion_4QConeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4QConeDomain_2__(v)
def __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinPSDDomain)
def __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(v)
def __arg_match__3Lmosek_4fusion_4Expression_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Expression) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Expression_2__(v):
  return __arg_match__3Lmosek_4fusion_4Expression_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Expression_2__)
def __arg_match_J__(v):
  return isinstance(v,numpy.int64) or isinstance(v,int) or isinstance(v,numpy.int32)
def __arg_alt_match_J__(v):
  return __arg_match_J__(v)
def __arg_match_Lmosek_4fusion_4Constraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_Constraint)
def __arg_alt_match_Lmosek_4fusion_4Constraint_2__(v):
  return __arg_match_Lmosek_4fusion_4Constraint_2__(v)
def __arg_match__3J__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.int64))
def __arg_alt_match__3J__(v):
  return __arg_match__3J__(v) or __arg_match_listof__(v,__arg_alt_match_J__)
def __arg_match__3_3J__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3J__(i) for i in v.flatten()])
def __arg_alt_match__3_3J__(v):
  return __arg_match__3_3J__(v) or __arg_match_listof__(v,__arg_alt_match__3J__)
def __arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearPSDConstraint)
def __arg_alt_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4SymRangedVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymRangedVariable)
def __arg_alt_match_Lmosek_4fusion_4SymRangedVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4SymRangedVariable_2__(v)
def __arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearPSDVariable)
def __arg_alt_match_Lmosek_4fusion_4LinearPSDVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v)
def __arg_match_Lmosek_4fusion_4ConstraintCache_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConstraintCache)
def __arg_alt_match_Lmosek_4fusion_4ConstraintCache_2__(v):
  return __arg_match_Lmosek_4fusion_4ConstraintCache_2__(v)
def __arg_match__3Lmosek_4fusion_4Variable_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Variable) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Variable_2__(v):
  return __arg_match__3Lmosek_4fusion_4Variable_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Variable_2__)
def __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricMatrix)
def __arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(v)
def __arg_match__3D__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.float64))
def __arg_alt_match__3D__(v):
  return __arg_match__3D__(v) or __arg_match_listof__(v,__arg_alt_match_D__)
def __arg_match_Lmosek_4fusion_4ConicVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConicVariable)
def __arg_alt_match_Lmosek_4fusion_4ConicVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4ConicVariable_2__(v)
def __arg_match_Lmosek_4fusion_4SymmetricRangeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricRangeDomain)
def __arg_alt_match_Lmosek_4fusion_4SymmetricRangeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricRangeDomain_2__(v)
def __arg_match_Lmosek_4fusion_4FlatExpr_2__(v):
  return v is None or isinstance(v,mosek_fusion_FlatExpr)
def __arg_alt_match_Lmosek_4fusion_4FlatExpr_2__(v):
  return __arg_match_Lmosek_4fusion_4FlatExpr_2__(v)
def __arg_match__3I__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.int32))
def __arg_alt_match__3I__(v):
  return __arg_match__3I__(v) or __arg_match_listof__(v,__arg_alt_match_I__) or isinstance(v,range)
def __arg_match__3_5D__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 2 and v.dtype == numpy.dtype(numpy.float64))
def __arg_alt_match__3_5D__(v):
  return _monty.arg_match_sloppy_array(v,__arg_alt_match_D__,2)
def __arg_match_LSystem_4StreamWriter_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4StreamWriter_2__(v):
  return __arg_match_LSystem_4StreamWriter_2__(v)
def __arg_match_Lmosek_4fusion_4LinearVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearVariable)
def __arg_alt_match_Lmosek_4fusion_4LinearVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearVariable_2__(v)
def __arg_match_Lmosek_4fusion_4RangeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangeDomain)
def __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4RangeDomain_2__(v)
def __arg_match_I__(v):
  return isinstance(v,numpy.int32) or isinstance(v,numpy.int64) or isinstance(v,int)
def __arg_alt_match_I__(v):
  return __arg_match_I__(v)
def __arg_match__3S__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == object and all([isinstance(i0,str) for i0 in v ])
def __arg_alt_match__3S__(v):
  return __arg_match__3S__(v) or __arg_match_listof__(v,__arg_alt_match_S__)
def __arg_match_Lmosek_4fusion_4PSDDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDDomain)
def __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDDomain_2__(v)
def __arg_match_Lmosek_4fusion_4LinearDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearDomain)
def __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearDomain_2__(v)
def __arg_match__3_5I__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 2 and v.dtype == numpy.dtype(numpy.int32))
def __arg_alt_match__3_5I__(v):
  return _monty.arg_match_sloppy_array(v,__arg_alt_match_I__,2)
def __arg_match_Emosek_4fusion_4SolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_SolutionStatus)
def __arg_alt_match_Emosek_4fusion_4SolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_SolutionStatus)
def __arg_match_LSystem_4CallbackHandler_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4CallbackHandler_2__(v):
  return __arg_match_LSystem_4CallbackHandler_2__(v)
def __arg_match_Lmosek_4fusion_4Matrix_2__(v):
  return v is None or isinstance(v,mosek_fusion_Matrix)
def __arg_alt_match_Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match_Lmosek_4fusion_4Matrix_2__(v)
def __arg_match_Emosek_4fusion_4AccSolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_AccSolutionStatus)
def __arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_AccSolutionStatus)
def __arg_match__3Lmosek_4fusion_4Constraint_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Constraint) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Constraint_2__(v):
  return __arg_match__3Lmosek_4fusion_4Constraint_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Constraint_2__)
def __arg_match_Lmosek_4fusion_4ModelConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_ModelConstraint)
def __arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4ModelConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v):
  return v is None or isinstance(v,mosek_fusion_Utils_StringBuffer)
def __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v):
  return __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v)
def __arg_match_Lmosek_4fusion_4PSDVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDVariable)
def __arg_alt_match_Lmosek_4fusion_4PSDVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDVariable_2__(v)
def __arg_match__3_3I__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3I__(i) for i in v.flatten()])
def __arg_alt_match__3_3I__(v):
  return __arg_match__3_3I__(v) or __arg_match_listof__(v,__arg_alt_match__3I__)
def __arg_match__3Lmosek_4fusion_4Set_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Set) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Set_2__(v):
  return __arg_match__3Lmosek_4fusion_4Set_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Set_2__)
def __arg_match_Lmosek_4fusion_4BaseVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_BaseVariable)
def __arg_alt_match_Lmosek_4fusion_4BaseVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4BaseVariable_2__(v)
def __arg_match_Lmosek_4fusion_4Model_2__(v):
  return v is None or isinstance(v,mosek_fusion_Model)
def __arg_alt_match_Lmosek_4fusion_4Model_2__(v):
  return __arg_match_Lmosek_4fusion_4Model_2__(v)
def __arg_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricLinearDomain)
def __arg_alt_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricLinearDomain_2__(v)
def __arg_match_Lmosek_4fusion_4FusionException_2__(v):
  return v is None or isinstance(v,mosek_fusion_FusionException)
def __arg_alt_match_Lmosek_4fusion_4FusionException_2__(v):
  return __arg_match_Lmosek_4fusion_4FusionException_2__(v)
def __arg_match_Lmosek_4fusion_4SolutionStruct_2__(v):
  return v is None or isinstance(v,mosek_fusion_SolutionStruct)
def __arg_alt_match_Lmosek_4fusion_4SolutionStruct_2__(v):
  return __arg_match_Lmosek_4fusion_4SolutionStruct_2__(v)
def __arg_match_Emosek_4fusion_4RelationKey_2__(v):
  return isinstance(v,mosek_fusion_RelationKey)
def __arg_alt_match_Emosek_4fusion_4RelationKey_2__(v):
  return isinstance(v,mosek_fusion_RelationKey)
def __arg_match__3_3Lmosek_4fusion_4Expression_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Expression_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Expression_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Expression_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Expression_2__)
def __arg_match__3_3Lmosek_4fusion_4Matrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Matrix_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Matrix_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Matrix_2__)
def __arg_match_Lmosek_4fusion_4LinearConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearConstraint)
def __arg_alt_match_Lmosek_4fusion_4LinearConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearConstraint_2__(v)
def __arg_match_Emosek_4fusion_4QConeKey_2__(v):
  return isinstance(v,mosek_fusion_QConeKey)
def __arg_alt_match_Emosek_4fusion_4QConeKey_2__(v):
  return isinstance(v,mosek_fusion_QConeKey)
def __arg_match_Lmosek_4fusion_4Variable_2__(v):
  return v is None or isinstance(v,mosek_fusion_Variable)
def __arg_alt_match_Lmosek_4fusion_4Variable_2__(v):
  return __arg_match_Lmosek_4fusion_4Variable_2__(v)
def __arg_match_Lmosek_4fusion_4SymLinearVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymLinearVariable)
def __arg_alt_match_Lmosek_4fusion_4SymLinearVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4SymLinearVariable_2__(v)
def __arg_match_LSystem_4DataCallbackHandler_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4DataCallbackHandler_2__(v):
  return __arg_match_LSystem_4DataCallbackHandler_2__(v)
def __arg_match_Emosek_4fusion_4ObjectiveSense_2__(v):
  return isinstance(v,mosek_fusion_ObjectiveSense)
def __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(v):
  return isinstance(v,mosek_fusion_ObjectiveSense)
def __arg_match_Lmosek_4fusion_4Expression_2__(v):
  return v is None or isinstance(v,mosek_fusion_Expression)
def __arg_alt_match_Lmosek_4fusion_4Expression_2__(v):
  return __arg_match_Lmosek_4fusion_4Expression_2__(v)
def __arg_match__3_3Lmosek_4fusion_4Variable_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Variable_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Variable_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Variable_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Variable_2__)
def __arg_match_Lmosek_4fusion_4ConicConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConicConstraint)
def __arg_alt_match_Lmosek_4fusion_4ConicConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4ConicConstraint_2__(v)
def __arg_match__3Lmosek_4fusion_4Matrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Matrix) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match__3Lmosek_4fusion_4Matrix_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Matrix_2__)
def __arg_match_Lmosek_4fusion_4SymmetricExpr_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricExpr)
def __arg_alt_match_Lmosek_4fusion_4SymmetricExpr_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricExpr_2__(v)
def __arg_match_D__(v):
  return isinstance(v,numpy.float64) or isinstance(v,float) or isinstance(v,int) or isinstance(v,numpy.int32) or isinstance(v,numpy.int64)
def __arg_alt_match_D__(v):
  return __arg_match_D__(v)
def __arg_match__3Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_SymmetricMatrix) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return __arg_match__3Lmosek_4fusion_4SymmetricMatrix_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__)
def __arg_match_Z__(v):
  return isinstance(v,bool) or isinstance(v,numpy.bool_)
def __arg_alt_match_Z__(v):
  return __arg_match_Z__(v)
def __arg_match_S__(v):
  return isinstance(v,str)
def __arg_alt_match_S__(v):
  return __arg_match_S__(v)
def __arg_match_listof__(v,f): return isinstance(v,list) and all([ f(i) for i in v])
import mosek
import mosek.fusion
import mosek.fusion.Utils
from . import fragments
